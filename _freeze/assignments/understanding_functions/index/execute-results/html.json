{
  "hash": "80949515c5d6c449ff29fb009040dd56",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nauthor: \"Ryan M. Moore, PhD\"\ndate-modified: last-modified\ndate: \"2025-03-02\"\njupyter: python3\n---\n\n# Assignment 2: Functions & Problem Solving {.unnumbered}\n\nWelcome to your second Python programming assignment! Building on the fundamentals we covered in Assignment 1, we'll now explore more advanced concepts like dictionaries, functions, and algorithmic thinking. These tools will help you tackle more complex bioinformatics challenges.\n\nAs with the previous assignment, each section follows a \"learn by example\" approach. I'll walk you through examples that demonstrate key concepts, and then you'll apply similar techniques to solve bioinformatics problems.\n\n## Requirements\n\nFor each problem you will need to write a function. Ensure that the function has a docstring comment that follows Google's Style Guide (as discussed in Tutorial 4).\n\nAdditionally, each problem has some \"checks\" that should run without error.\n\nFinally, you must demonstrate a good-faith effort by:\n\n- Showing clear understanding of the problems\n- Making genuine attempts to complete all tasks\n- Providing mostly correct solutions\n\n## Part 1: Amino Acid Counting\n\nIn part 1, I will give you examples that are very similar to the problem you will need to solve. This will help you to build confidence and practice adapting existing solutions to your specific needs.\n\n_Note: Typing out your own solutions instead of copy-pasting my example code and tweaking variable names is a much better way to learn. You'll gain a deeper understanding by writing the code yourself!_\n\n### Part 1: Examples\n\nFor the examples, we will practice by counting words in a sentence. We'll use a dictionary where each word is a key and the count is the value.\n\n#### Example 1.1: Counting words\n\nCreate a function called `count_words` that takes a sentence (string) as input and returns a dictionary where each key is a word from the sentence and each value is the number of times that word appears. (To keep things simple, let's assume that sentences won't have any punctuation and that \"words\" are chunks of text separated by whitespace.)\n\n::: {#c9930d35 .cell execution_count=1}\n``` {.python .cell-code}\ndef count_words(text):\n    \"\"\"\n    Count occurrences of each word in a text.\n\n    Args:\n        text (str): The input text to analyze.\n\n    Returns:\n        dict: A dictionary where keys are words and values are their counts.\n    \"\"\"\n\n    # A dictionary to store the counts of all the words\n    word_counts = {}\n\n    # Convert the text to all lowercase, then split it on whitespace.\n    words = text.lower().split()\n\n    # Loop through each of the words\n    for word in words:\n        # Check if we have already seen this word\n        if word in word_counts:\n            # If we have seen the word, increment the count\n            word_counts[word] += 1\n        else:\n            # If we haven't seen the word, start the count at 1\n            word_counts[word] = 1\n\n    # Return the dictionary of counts\n    return word_counts\n\n\ncount_words(\"i like to eat apple pie and to eat apple cake\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n{'i': 1,\n 'like': 1,\n 'to': 2,\n 'eat': 2,\n 'apple': 2,\n 'pie': 1,\n 'and': 1,\n 'cake': 1}\n```\n:::\n:::\n\n\n#### Example 1.2: Printing word counts\n\nCreate a function called `print_word_counts` that takes a dictionary of word counts as input and prints each word alongside its count in a readable format (e.g., \"word => count\").\n\n::: {#31ae4c21 .cell execution_count=2}\n``` {.python .cell-code}\ndef print_word_counts(word_counts):\n    \"\"\"Print words that appear in the text and their counts.\"\"\"\n\n    # Loop through every key-value pair in the dictionary\n    for word, count in word_counts.items():\n        # Print the data in a nice way\n        print(word, count, sep=\" => \")\n```\n:::\n\n\n#### Example 1.3: Printing all word counts\n\nCreate a function called `print_all_word_counts` that takes two parameters: a dictionary of word counts and a list of words. This function should print the count for each word in the provided list, displaying 0 for any words that don't appear in the dictionary.\n\n::: {#7564ca44 .cell execution_count=3}\n``` {.python .cell-code}\ndef print_all_word_counts(word_counts, all_possible_words):\n    \"\"\"Print all possible words and their counts, even those with zero count.\"\"\"\n\n    # Loop through every word given list of all words\n    for word in all_possible_words:\n        # Try and get the count of the word. Recall that `dict.get(x, default)`\n        # will return the `default` value if `x` is not found in the `dict`.\n        count = word_counts.get(word, 0)\n\n        # Print the data in a nice way\n        print(word, count, sep=\" => \")\n```\n:::\n\n\n#### Using the Previous Functions\n\nAnd here are some examples of using all three of these functions:\n\n::: {#39186813 .cell execution_count=4}\n``` {.python .cell-code}\nsentence = \"the cat ate my homework and ate my laptop\"\nall_words = [\n    \"a\",\n    \"and\",\n    \"the\",\n    \"cat\",\n    \"dog\",\n    \"ate\",\n    \"shredded\",\n    \"my\",\n    \"you\",\n    \"project\",\n    \"assignment\",\n    \"laptop\",\n]\n\ncounts = count_words(sentence)\nprint(\"Words in the text:\")\nprint_word_counts(counts)\n\nprint(\"\\nAll possible words:\")\nprint_all_word_counts(counts, all_words)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWords in the text:\nthe => 1\ncat => 1\nate => 2\nmy => 2\nhomework => 1\nand => 1\nlaptop => 1\n\nAll possible words:\na => 0\nand => 1\nthe => 1\ncat => 1\ndog => 0\nate => 2\nshredded => 0\nmy => 2\nyou => 0\nproject => 0\nassignment => 0\nlaptop => 1\n```\n:::\n:::\n\n\n#### Example 1.4: Combining Functions Into a Pipeline\n\nCreate a function called `count_and_print_words` that uses the above functions to take a sentence, count the words in the sentence, then print out the counts of the words in that sentence.\n\n::: {#feca7bfd .cell execution_count=5}\n``` {.python .cell-code}\ndef count_and_print_words(sentence):\n    \"\"\"\n    Counts words in a sentence and prints their occurrences.\n\n    Args:\n        sentence (str): The input text to analyze for word frequencies.\n    \"\"\"\n    word_counts = count_words(sentence)\n    print_word_counts(word_counts)\n\n\ncount_and_print_words(\"the cat ate my homework and ate my laptop\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthe => 1\ncat => 1\nate => 2\nmy => 2\nhomework => 1\nand => 1\nlaptop => 1\n```\n:::\n:::\n\n\n### Problem 1.1: Count Amino Acids\n\nNow that you have seen some examples, let's get to the first problem.\n\nCreate a function called `count_amino_acids` that accepts a protein sequence string and returns a dictionary with the count of each amino acid present in that sequence.\n\n#### Requirements\n\n- Do not use the built-in `Counter` or `defaultdict` collections\n- Do not use the `str.count()` method\n- Use a regular dictionary and iteration similar to the example problem\n\n#### Problem 1.1: Solution\n\n::: {#dc5fed74 .cell execution_count=6}\n``` {.python .cell-code}\n# Write your code here!\n```\n:::\n\n\nAfter you fill in the code above, you should run this code to check your work!\n\n_Note: You will need to put brackets around `python` in the next line to be able to run the code._\n\n```python\n# Example usage\nprotein = \"MNQNLLVTKRDGSTERINLDKIHRVLDWAAEG\"\namino_acid_counts = count_amino_acids(protein)\n\nexpected_output = {\n    \"M\": 1,\n    \"N\": 3,\n    \"Q\": 1,\n    \"L\": 4,\n    \"V\": 2,\n    \"T\": 2,\n    \"K\": 2,\n    \"R\": 3,\n    \"D\": 3,\n    \"G\": 2,\n    \"S\": 1,\n    \"E\": 2,\n    \"I\": 2,\n    \"H\": 1,\n    \"W\": 1,\n    \"A\": 2,\n}\n\nassert amino_acid_counts == expected_output\n```\n\n### Problem 1.2: Print Amino Acid Counts\n\nCreate a function called `print_amino_acid_counts` that takes a dictionary of amino acids counts and prints each amino acid and its count in a nice way.\n\n#### Problem 1.2: Solution\n\n::: {#a2575d2a .cell execution_count=7}\n``` {.python .cell-code}\n# Write your code here!\n```\n:::\n\n\nAfter you fill in the code above, you should run this code to check your work!\n\n\n_Note: You will need to put brackets around `python` in the next line to be able to run the code._\n\n```python\n# Example usage\nprotein = \"MNQNLLVTKRDGSTERINLDKIHRVLDWAAEG\"\namino_acid_counts = {\"R\": 3, \"D\": 3, \"G\": 2, \"S\": 1, \"E\": 2}\nprint_amino_acid_counts(amino_acid_counts)\n```\n\n### Problem 1.3: Print All Amino Acid Counts\n\nCreate a second version of the printing function called `print_all_amino_acid_counts` that prints counts for all 20 common amino acids, even those with zero counts. Here are all the single-letter codes for the amino acids as a Python list: `all_amino_acids = [\"A\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"K\", \"L\", \"M\", \"N\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"V\", \"W\", \"Y\"]`.\n\n#### Problem 1.3: Solution\n\n::: {#4b47bb5e .cell execution_count=8}\n``` {.python .cell-code}\n# Write your code here!\n```\n:::\n\n\nAfter you fill in the code above, you should run this code to check your work!\n\n_Note: You will need to put brackets around `python` in the next line to be able to run the code._\n\n```python\n# Example usage\namino_acid_counts = {\"R\": 3, \"D\": 3, \"G\": 2, \"S\": 1, \"E\": 2}\nprint_all_amino_acid_counts(amino_acid_counts)\n```\n\n### Problem 1.4: Combining Functions\n\nUsing the functions you created earlier, create a single function called `count_and_print_amino_acids` that takes a protein sequence as input, counts the occurrences of each amino acid in the sequence, and then prints out the counts of only those amino acids that are present in the sequence.\n\n#### Problem 1.4: Solution\n\n::: {#adadcdd0 .cell execution_count=9}\n``` {.python .cell-code}\n# Write your code here!\n```\n:::\n\n\nAfter you fill in the code above, you should run this code to check your work!\n\n_Note: You will need to put brackets around `python` in the next line to be able to run the code._\n\n```python\nprotein = \"MNQNLLVTKRDGSTERINLDKIHRVLDWAAEG\"\ncount_and_print_amino_acids(protein)\n```\n\n## Part 2: DNA Sequence Comparison\n\nIn part 2, rather than providing you with full example solutions, I will give you code samples to help you solve each problem. You will need to use techniques from part 1 in combination with ideas from the code samples to solve the problems.\n\n### Problem 2.1: Count DNA Matches\n\nWrite a function called `count_matches` that compares two nucleotide sequences of equal length and returns the number of positions where they match. You can assume that the two sequences are of equal length.\n\n#### Problem 2.1: Code Samples\n\nHere are some code samples to help you get started.\n\n##### Using zip to loop multiple collections at once\n\nWe can use `zip` to loop through the characters of multiple strings and other collections at the same time. [Zip](https://docs.python.org/3.3/library/functions.html#zip) is a handy function that we haven't really talked about, so, let's see some examples.\n\n::: {#cbaa7c79 .cell execution_count=10}\n``` {.python .cell-code}\n# Looping over two strings\nfor lowercase_letter, uppercase_letter in zip(\"apple\", \"APPLE\"):\n    print(lowercase_letter, uppercase_letter)\n\n# Looping over two lists\nfor a, b in zip([1, 2, 3], [10, 20, 30]):\n    print(a, b)\n\n# Creating a dictionary from two lists\nnames = [\"Pikachu\", \"Charmander\", \"Eevee\"]\ntypes = [\"Electric\", \"Fire\", \"Normal\"]\nprint(dict(zip(names, types)))\n\n# Zipping 3 lists\nrarities = [\"Rare\", \"Common\", \"Rare\"]\n# I use type_ here since 'type' is a reserved word in Python\nfor name, type_, rarity in zip(names, types, rarities):\n    print(f\"name: {name}, type: {type_}, rarity: {rarity}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na A\np P\np P\nl L\ne E\n1 10\n2 20\n3 30\n{'Pikachu': 'Electric', 'Charmander': 'Fire', 'Eevee': 'Normal'}\nname: Pikachu, type: Electric, rarity: Rare\nname: Charmander, type: Fire, rarity: Common\nname: Eevee, type: Normal, rarity: Rare\n```\n:::\n:::\n\n\nIf one of the items is shorter than the other, zip will only use up elements until the shorter one is exhausted:\n\n::: {#12d7c153 .cell execution_count=11}\n``` {.python .cell-code}\ntext_1 = \"apple\"\ntext_2 = \"pie\"\nfor letter_1, letter_2 in zip(text_1, text_2):\n    print(letter_1, letter_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na p\np i\np e\n```\n:::\n:::\n\n\n##### Tracking Values Across Loops\n\nSince the problem involves comparing nucleotides in a DNA sequence to nucleotides in another DNA sequence, and tracking the number of matches, you will need a way to track a variable across each iteration of a loop. Here is an example that tracks a running sum:\n\n::: {#48879cdf .cell execution_count=12}\n``` {.python .cell-code}\n# This tracks our current total\nrunning_sum = 0\n\nfor number in range(5):\n    # Update our running total by adding the new value\n    running_sum += number\n\nprint(running_sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10\n```\n:::\n:::\n\n\nNote that this is similar to the technique that you used in Miniproject 1.\n\nIf you want to get fancy, you could get the sum using a comprehension:\n\n::: {#0e03cce4 .cell execution_count=13}\n``` {.python .cell-code}\nprint(sum(x for x in range(5)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10\n```\n:::\n:::\n\n\nWhat if you are given numbers from 0 to 9 and want to count how many numbers are less than 5? With a comprehension, you can limit the amount of items you include in the sum.\n\n::: {#81d4746e .cell execution_count=14}\n``` {.python .cell-code}\nprint(sum(x < 5 for x in range(10)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n```\n:::\n:::\n\n\nWe can also use this comprehension + `sum` technique to count the number of letters in the first string that are \"less than\" their corresponding letter in the second string.\n\n::: {#147bdf74 .cell execution_count=15}\n``` {.python .cell-code}\nprint(sum(x < y for x, y in zip(\"abcde\", \"bcdcb\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n```\n:::\n:::\n\n\nThis example is a little obscure and requires some deeper Python knowledge: `True` and `False` have meaning in a numeric context -- `True` is like `1`, and `False` is like `0`. Check out this cool bit of code:\n\n::: {#7e3b4d14 .cell execution_count=16}\n``` {.python .cell-code}\nprint(True + True + False + True)\nprint((True + True + True) / (True + True))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n1.5\n```\n:::\n:::\n\n\nOkay, so why bother telling you this? There is a cool Python one-liner that you can do using a comprehension and the `sum` function to count the number of matching letters in two strings, which would solve Problem 2.1. You don't have to do it that way (you can use the basic `for` loop), but it is pretty neat if you can figure it out!\n\n#### Problem 2.1: Solution\n\n::: {#5ce42168 .cell execution_count=17}\n``` {.python .cell-code}\n# Write your code here!\n```\n:::\n\n\nAfter you fill in the code above, you should run this code to check your work!\n\n_Note: You will need to put brackets around `python` in the next line to be able to run the code._\n\n```python\n# Example usage\nseq_1 = \"ATCCTGCGTCTGAC\"\nseq_2 = \"AGCCTCCGTTTGAG\"\n\nassert count_matches(seq_1, seq_2) == 10\n```\n\n### Problem 2.2: Score DNA Alignment\n\nCreate a function called `score_alignment` that calculates a similarity score between two nucleotide sequences using a scoring matrix represented as a dictionary.\n\nIn this problem, you should:\n\n- Create a scoring function that uses a custom scoring matrix to evaluate the similarity between two strings.\n- The function takes three arguments:\n  - `text_1`: The first string to compare\n  - `text_2`: The second string to compare\n  - `scoring_matrix`: A dictionary where keys are tuples of character pairs `(char_1, char_2)`, and values are numeric scores representing how similar those characters are\n- The function should:\n  - Assume both strings are the same length\n  - For each position, look up the score for the character pair in the scoring matrix\n  - Sum these scores to produce a total similarity score\n  - Return this total score\n\nThis represents an improvement over simpler matching methods (like exact matches only) because it can account for characters that are similar but not identical. For example, in DNA sequences, transitions and transversions could have different scores.\n\nFor problem 2.2, you should create a dictionary to represent the following scoring matrix:\n\n```\n# Matches\nA, A => 2\nC, C => 2\nG, G => 2\nT, T => 2\n\n# Transitions\nA, G => -1\nG, A => -1\nC, T => -1\nT, C => -1\n\n# Transversions\nA, C => -2\nC, A => -2\nG, T => -2\nT, G => -2\nA, T => -2\nT, A => -2\nC, G => -2\nG, C => -2\n```\n\nIn this scoring scheme, matches are rewarded, and mismatches are always penalized, though [transitions are less penalized than transversions](https://www.mun.ca/biology/scarr/Transitions_vs_Transversions.html).\n\n#### Problem 2.2: Code Samples\n\nThis problem is a bit trickier! Let's put down some code samples that will help you solve this problem.\n\nWe can represent a scoring matrix as a dictionary that has tuples of letters for keys. In this case, our \"alphabet\" contains only three letters a, b, and c. Their similarity scores are:\n\n```\na, a =>  3\na, b =>  1\na, c => -1\nb, a =>  1.5\nb, b =>  5\nb, c =>  1\nc, a => -2\nc, b =>  0.5\nc, c =>  4\n```\n\nHere is how you could represent this as a dictionary:\n\n::: {#73638edb .cell execution_count=18}\n``` {.python .cell-code}\nscoring_matrix = {\n    (\"a\", \"a\"): 3,\n    (\"a\", \"b\"): 1,\n    (\"a\", \"c\"): -1,\n    (\"b\", \"a\"): 1.5,\n    (\"b\", \"b\"): 5,\n    (\"b\", \"c\"): 1,\n    (\"c\", \"a\"): -2,\n    (\"c\", \"b\"): 0.5,\n    (\"c\", \"c\"): 4,\n}\n```\n:::\n\n\nIf you want to look up the score for two letters, it might look something like this:\n\n::: {#34fe35b0 .cell execution_count=19}\n``` {.python .cell-code}\nletter_1 = \"c\"\nletter_2 = \"a\"\n\n# Try to find the pair of (\"c\", \"a\") in the dictionary.\n# If it is not found, return 0.\nscoring_matrix.get((letter_1, letter_2), 0)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n-2\n```\n:::\n:::\n\n\nWe return `0` as our default value so that the function doesn't give an error if some letter not in our alphabet is present in the string.\n\nCombine code similar to the above example with your solution to Problem 2.1, and you will be able to solve Problem 2.2.\n\n#### Problem 2.2: Solution\n\n::: {#af422877 .cell execution_count=20}\n``` {.python .cell-code}\nscoring_matrix = ...  # put the scoring matrix code here\n\n# Put the alignment score function here!\n```\n:::\n\n\nAfter you fill in the code above, you should run this code to check your work!\n\n_Note: You will need to put brackets around `python` in the next line to be able to run the code._\n\n```python\n# Example usage\ndna_1 = \"ATGCTAGCTA\"\ndna_2 = \"ACGCTATCTA\"\n\nassert alignment_score(dna_1, dna_2, scoring_matrix) == 13\n```\n\n## Part 3: Codon Processing\n\nIn molecular biology, codons (groups of three nucleotides) are the basic units of the genetic code. Processing DNA at the codon level is a common bioinformatics task.\n\nLet's create a function that processes text in 3-character chunks:\n\n### Problem 3.1: Codon Printing\n\nCreate a function called `print_codons` that prints text in chunks of 3 characters.\n\n#### Problem 3.1: Code Samples\n\nWhenever you see something like, \"process text in chunks\", you should be thinking about string slicing:\n\n::: {#e0cc5866 .cell execution_count=21}\n``` {.python .cell-code}\nsentence = \"the_cat_eats\"\n\nprint(sentence[0:3])\nprint(sentence[4:7])\nprint(sentence[8:12])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthe\ncat\neats\n```\n:::\n:::\n\n\nFor codons, we want chunks of 3 characters. In this case, the length of the input string `\"the_cat_eats\"` is divisible by 3 so we don't have to worry about an incomplete chunk at the end. To keep things simple, we will use this assumption for the rest of the assignment as well. Let's use string slicing again to print the chunks:\n\n::: {#1cb4923b .cell execution_count=22}\n``` {.python .cell-code}\nprint(sentence[0:3])\nprint(sentence[3:6])\nprint(sentence[6:9])\nprint(sentence[9:12])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthe\n_ca\nt_e\nats\n```\n:::\n:::\n\n\nDo you see how we start at index of 0, then get a chunk of 3 characters, and then move the index to the start of the next chunk of 3 characters? Let's show that by using an index `i` rather than putting the numbers in manually.\n\n::: {#f082cd0a .cell execution_count=23}\n``` {.python .cell-code}\ni = 0\nprint(sentence[i:i+3])\n\ni += 3\nprint(sentence[i:i+3])\n\ni += 3\nprint(sentence[i:i+3])\n\ni += 3\nprint(sentence[i:i+3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthe\n_ca\nt_e\nats\n```\n:::\n:::\n\n\nSimple enough...but what about the stop condition? We are assuming that the strings are always divisible by three, so that simplifies things, but we still need to figure out when to stop.\n\nWe need to stop when `i` is less than the remaining chunk size from the end. In this case, if `i` is `10`, `11`, `12`, or higher, we should stop.\n\nTo do this you could either use a while loop, manually increment the counter, and manage the stop condition with a boolean expression, or use a for loop with the range function. Remember that you can set a `step` value for the range function. Check it out:\n\n::: {#55362afe .cell execution_count=24}\n``` {.python .cell-code}\nfor x in range(0, 12, 3):\n    print(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n3\n6\n9\n```\n:::\n:::\n\n\nNow, you just need to generalize the code by avoiding hard-coded numbers, and you'll have everything you need to solve the problem.\n\n#### Problem 3.1: Solution\n\n::: {#9374ff53 .cell execution_count=25}\n``` {.python .cell-code}\n# Write your code here!\n```\n:::\n\n\nAfter you fill in the code above, you should run this code to check your work!\n\n_Note: You will need to put brackets around `python` in the next line to be able to run the code._\n\n```python\n# Example usage\nprint_codons(\"ACTGACTATCATATAGTA\")\n```\n\n### Problem 3.2: Codon Counting\n\nCreate a function `count_codons` that counts occurrences of each 3-character chunk, and returns the counts as a dictionary.\n\n_Note: You're not allowed to use the `Counter` or `defaultdict` classes. Do the counting using a regular dictionary and looping._\n\nYou don’t need additional examples for this problem. You already have all the necessary components from the previous code samples and your solutions to earlier problems. Specifically, you need to combine the loop from Problem 3.1 that iterates through each codon with the counting logic from Problem 1.\n\n#### Problem 3.2: Solution\n\n::: {#4bb6b014 .cell execution_count=26}\n``` {.python .cell-code}\n# Write your code here!\n```\n:::\n\n\nAfter you fill in the code above, you should run this code to check your work!\n\n_Note: You will need to put brackets around `python` in the next line to be able to run the code._\n\n```python\nprint(count_codons(\"ACTGACTATCATATAGTA\"))\n```\n\n## Summary\n\nIn this assignment, you've built functions for basic DNA and protein sequence analysis. You’ve learned to:\n\n- Use dictionaries to count and store information about biological sequences\n- Create functions to compare sequences and calculate similarity scores\n- Process DNA at the codon level\n\nThese skills are fundamental to bioinformatics programming and will help you tackle more complex problems. By breaking tasks into smaller functions and using the right data structures, you're building a strong foundation in computational thinking for data analysis.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}