{
  "hash": "7d862c07b95cfa3422f2ee87c148dec5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nauthor: \"Ryan M. Moore, PhD\"\ndate-modified: last-modified\ndate: \"2025-02-08\"\njupyter: python3\n---\n\n# Assignment 1: Getting Started with Python {.unnumbered}\n\nWelcome to your first Python programming assignment! We'll start with the fundamentals, focusing on basic operations that will serve as building blocks for more complex bioinformatics tasks later on.  This assignment builds on concepts from Tutorial 1 and introduces some additional string operations that you'll find particularly useful in handling biological sequence data.\n\nTo make learning easier, each section follows a \"learn by example\" approach. First, I'll walk you through a complete example that demonstrates key concepts. Rather than using life science content directly, these examples will use more familiar, silly scenarios to clearly illustrate the problem-solving techniques you'll need. Then, you'll tackle a similar practice problem with a life science application where you can apply what you've learned. The example problems are specifically designed to parallel the actual assigned problems, so you can use similar problem-solving strategies to complete your work.\n\nThink of this as building a toolkit -- we'll start with basic tools and gradually add more sophisticated ones as we progress.\n\n## Suggestions for Code Organization\n\nWhen you're first learning to code, it's helpful to break down your calculations into smaller, clearer steps.\n\nInstead of this condensed approach:\n\n::: {#149b4505 .cell execution_count=1}\n``` {.python .cell-code}\nsentence = \"kittens love balls of yarn\"\n\nvowel_ratio = (\n    sentence.count(\"a\")\n    + sentence.count(\"e\")\n    + sentence.count(\"i\")\n    + sentence.count(\"o\")\n    + sentence.count(\"u\")\n) / len(sentence)\n\nprint(vowel_ratio)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.2692307692307692\n```\n:::\n:::\n\n\nConsider breaking it down like this:\n\n::: {#9274de6d .cell execution_count=2}\n``` {.python .cell-code}\nsentence = \"kittens love balls of yarn\"\n\n# Count the number of each vowel\na_count = sentence.count(\"a\")\ne_count = sentence.count(\"e\")\ni_count = sentence.count(\"i\")\no_count = sentence.count(\"o\")\nu_count = sentence.count(\"u\")\n\n# Add up the vowel counts\nvowel_count = a_count + e_count + i_count + o_count + u_count\n\n# Get the total length of the sentence\nsentence_length = len(sentence)\n\n# Calculate the vowel ratio\nvowel_ratio = vowel_count / sentence_length\n\nprint(vowel_ratio)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.2692307692307692\n```\n:::\n:::\n\n\nThis step-by-step approach is more verbose, but it can provide some advantages, especially as you are learning to code:\n\n- It's easier to debug (you can check each intermediate value)\n- It's more readable and self-documenting\n\nAs you gain more experience, you'll develop an intuition for when to use more concise code versus when to break things down. For now, focus on writing code that you (and others) can easily understand and troubleshoot.\n\n## Basic DNA Sequence Analysis\n\nLet's start with some basic text operations.  We'll learn how to store text in variables, combine pieces of text together, and count specific characters.\n\nOne particularly useful feature we'll explore is something called a \"string method\". Basically, these are built-in tools that help you analyze and modify text. For instance, we can use the `count` string method to \"count\" how many times a particular character appears in a piece of text.\n\n### Example\n\nIn this example, we want to create a friendly greeting for someone and then figure out how enthusiastic that greeting is by counting exclamation marks. Let's break it down into clear steps:\n\n1. Create variables for a greeting (`Hello`) and a name (`Ryan`)\n2. Join them together with a space and add some exclamation marks (`!`) to the end\n3. Print the result of (2)\n4. Count the number of exclamation marks\n5. Print the result of (4)\n\nBreaking problems down into small, manageable steps like this is a crucial skill in programming. Just like how you might break down a complex laboratory protocol into distinct steps, programming tasks become much more approachable when divided into smaller pieces.\n\n#### Solution\n\nBelow is a complete solution to the problem we just broke down. I've added comments that point back to each step from our list -- this helps show how each line of code connects to our original plan. When you write your own solution, you don't need to include these \"step-reference\" comments. They're just here to help you see how the pieces fit together and build that mental connection between planning and implementation.\n\n::: {#13210a15 .cell execution_count=3}\n``` {.python .cell-code}\n# Step 1\ngreeting = \"Hello\"\nname = \"Ryan\"\n\n# Step 2\nmessage = greeting + \" \" + name + \"!!\"\n\n# Step 3\nprint(message)\n\n# Step 4\nexclamation_mark_count = message.count(\"!\")\n\n# Step 5\nprint(exclamation_mark_count)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello Ryan!!\n2\n```\n:::\n:::\n\n\nYou might notice something new here: `message.count(\"!\")`. This is one of Python's [string methods](https://docs.python.org/3/library/stdtypes.html#string-methods) -- basically a built-in tool that can perform specific operations on text.  We'll explore these string methods more thoroughly later, but for now, just know that `count()` does exactly what its name suggests:  it counts how many times a particular character or pattern appears in your text.\n\nLet's look at some simple examples:\n\n::: {#1e764989 .cell execution_count=4}\n``` {.python .cell-code}\np_count = \"apple pie\".count(\"p\")\nprint(p_count)\n\nname = \"Juan Carlos\"\na_count = name.count(\"a\")\nprint(a_count)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n2\n```\n:::\n:::\n\n\nWhen we write `\"apple pie\".count(\"p\")`, we're essentially asking Python \"How many times does the letter `p` appear in the text `apple pie`?\"\n\nThe `count()` method isn't limited to single characters -- it can also count longer patterns. Here's an example:\n\n::: {#791c0499 .cell execution_count=5}\n``` {.python .cell-code}\nsilly_string = \"ab abab ab\"\nab_count = silly_string.count(\"ab\")\nprint(ab_count)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n```\n:::\n:::\n\n\n### Problem\n\nIn this problem, we'll work with some DNA sequences, joining them together and analyzing the combined sequence to count specific nucleotides and patterns. You could think of this as a simplified version of looking for motifs or counting nucleotide usage.\n\n1. Create variables for three DNA fragments, `ATATAACTG`, `CTATGTAC`, and `GGTGAGTAT`\n2. Join (concatenate) the three DNA fragments into one\n3. Print the result of (2)\n4. Count how many `A` nucleotides there are in the joined sequence created in (2)\n5. Print the result of (4)\n6. Count the number of occurrences of the substring `AT` in the joined sequence created in (2)\n7. Print the result of (6)\n\n#### Solution\n\n::: {#d602cd27 .cell execution_count=6}\n``` {.python .cell-code}\n# Put the code for your solution here!\n```\n:::\n\n\n## DNA Composition Analysis\n\nDNA sequence analysis often starts with understanding basic nucleotide composition. While simple, these calculations form the foundation for many bioinformatics tasks and can help validate your data quality.\n\nLet's build on our string operations to analyze DNA sequences by counting bases and calculating GC content.\n\n### Example\n\nBefore getting to the DNA string problem, let's practice working with strings by analyzing the spaces in a sentence. We'll count the spaces, calculate what percentage of the sentence they represent, and format our output nicely. Here's the step-by-step breakdown:\n\n1. Create a variable for the sentence: `the tiny kitten chomps the pencil and eats the homework`\n2. Count the number of spaces (`\" \"`) in the sentence\n3. Print the result of (2) in a nice way using an f-string\n    a. Don't just print out the number, rather print a nice phrase like `the sentence has 9 spaces` or something similar.\n4. Calculate the percentage of spaces in the sentence\n    a. E.g., if there are 5 spaces and 20 total characters, the percent spaces would be 25%.\n5. Print the result of (4) in a nice way using an f-string\n    a. The percent should only have one decimal place of precision!\n    b. E.g., rather than `the sentence has 16.363636363636363% spaces`, you should print `then sentence has 16.4% spaces`.\n\n#### Solution\n\nTo print things in a nice, formatted way, we will use Python's [Formatted String Literals](https://docs.python.org/3/tutorial/inputoutput.html#formatted-string-literals), or \"f-strings\".\n\nLet's take a look:\n\n::: {#6d8808b2 .cell execution_count=7}\n``` {.python .cell-code}\n# Step 1\nsentence = \"the tiny kitten chomps the pencil and eats the homework\"\n\n# Step 2\nspace_count = sentence.count(\" \")\n\n# Step 3\nprint(f\"the sentence has {space_count} spaces\")\n\n# Step 4\nsentence_length = len(sentence)\nspace_ratio = space_count / sentence_length\nspace_percentage = space_ratio * 100\n\n# Step 5\nprint(f\"the sentence has {space_percentage:.1f}% spaces\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthe sentence has 9 spaces\nthe sentence has 16.4% spaces\n```\n:::\n:::\n\n\nAs with our previous example, we can see how each instruction maps directly to its corresponding code. While this level of detail isn't always necessary, it's very helpful during the learning process.\n\nPay attention to the `.1f` part of the f-string from Step 5.  That allows us to control the amount of precision that is printed.  F-strings have a [lot more things like that]((https://docs.python.org/3/tutorial/inputoutput.html#formatted-string-literals) to help you create nicely formatted output.\n\n### Problem\n\nWe often need to analyze DNA sequences by counting specific nucleotides and calculating metrics like GC content, which can tell us important things about the DNA's properties and origin. Here is the problem statement:\n\n> Given a DNA string `GGAAGTTTTCCATTTTTAGTAAGAATTGATTT`, calculate the GC percentage and display it in a nicely formatted way.\n\nLet's solve this problem step by step:\n\n1. Create a variable for the DNA string: `GGAAGTTTTCCATTTTTAGTAAGAATTGATTT`\n2. Count the number of `G`s in the sequence\n3. Count the number of `C`s in the sequence\n4. Print the result of (2) and (3) in a nice way using an f-string\n    a. E.g., something like `the sequence has 5 Gs and 10 Cs`\n5. Calculate the GC percentage of the given DNA string\n    a. The GC percentage of a DNA string is the number of Gs plus the number of Cs divided by the total length of the sequence.\n6. Print the result of (5) in a nice way using an f-string\n    a. The percent should only have one decimal place of precision!\n    b. E.g., rather than `the GC percentage is 45.66666666666%`, you should print `the GC percentage is 45.7%`.\n\n\n#### Solution\n\n::: {#8da01855 .cell execution_count=8}\n``` {.python .cell-code}\n# Put the code for your solution here!\n```\n:::\n\n\n## Gene Structure Analysis\n\nWhen working with genetic sequences, we often need to analyze their structure and make decisions based on specific patterns or features we find. In this exercise, we'll explore how to use Python's string handling capabilities and if/then logic to examine DNA sequences.\n\nThink of it as creating a set of simple rules for your computer to follow, similar to the mental checklist you might use when manually analyzing sequences, but more systematic.\n\n### Example\n\nAs usual, let's try a small example that covers the concepts you can use to solve the real problem.  We want to write a program that can look at a sentence and tell us if it's \"good\" based on two criteria: it needs to be long enough, and it needs proper ending punctuation.\n\nHere are the step-by-step instructions:\n\n1. Create a variable to hold the sentence: `My favorite class is Programming!!`\n2. Create a variable to hold the minimum length threshold of `20` characters\n3. Check the criteria for a good sentence:\n    a. Determine if the given sentence is long enough\n    b. Determine if the given sentence ends with either a period (`.`) or an exclamation mark (`!`)\n4. Determine if the sentence is \"good\"\n    a. A sentence is \"good\" if it is long enough (3a) and ends in either a period or an exclamation mark (3b)\n5. Use an f-string to print a nice message about whether the sentence is good or not good\n\n#### Solution\n\nLet's take a look at one solution to the problem.  For reference, I have included comments to connect each line of code back to the original instructions.\n\n::: {#5bfde81f .cell execution_count=9}\n``` {.python .cell-code}\n# Step 1\nsentence = \"My favorite class is Programming!!\"\n\n# Step 2\nminimum_length_threshold = 20\n\n# Step 3a\nis_too_short = len(sentence) < minimum_length_threshold\n\n# Step 3b\nends_with_period = sentence.endswith(\".\")\nends_with_exclamation = sentence.endswith(\"!\")\nends_with_punctuation = ends_with_period or ends_with_exclamation\n\n# Step 4\nis_good_sentence = not is_too_short and ends_with_punctuation\n\n# Step 5\nif is_good_sentence:\n    print(f\"the sentence '{sentence}' is good :D\")\nelse:\n    print(f\"the sentence '{sentence}' is not good D:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthe sentence 'My favorite class is Programming!!' is good :D\n```\n:::\n:::\n\n\nNote the use of `sentence.endswith(...)`.  This is another one of Python's string methods.  It tells you whether or not a string ends with the given argument.  In this case, `sentence.endswith(\".\")` is checking if the `sentence` ends with a `.`.  There is also a string method called `startswith`.  Can you guess what it does?  (You can find the answer on the Python docs for [str.startswith](https://docs.python.org/3/library/stdtypes.html#str.startswith)).\n\nLet's look at how we can potentially improve our code's readability. In the original version, we first checked if a sentence was too short (step 3a) and then had to use `not` to negate that condition in step 4. Here's an alternative approach:\n\n```python\nis_long_enough = len(sentence) >= minimum_length_threshold\n\n# ... other code ...\n\nis_good_sentence = is_long_enough and ends_with_punctuation\n```\n\nBy checking if the sentence is 'long enough' instead of 'too short', we can use the condition directly without negation. This makes the logic more straightforward. Both approaches work fine -- choose whichever you find more intuitive and readable.\n\n### Problem\n\nNow that we have seen the example, let's try the real problem!\n\nWe often need to identify valid genes within DNA sequences. A \"good gene\" might need certain characteristics.  For example, it must be long enough to code for a protein, start with a specific sequence called a start codon, and end with one of several possible stop codons. Let's write code to check if a given DNA sequence meets these criteria.\n\nHere are the steps we will follow:\n\n1. Create variables to hold the following data, one variable for each object\n    a. start codon: `ATG`\n    b. stop codons:\n        i. `TAA`\n        ii. `TAG`\n        iii. `TGA`\n    c. minimum length threshold for a gene: `25`\n2. Create a variable to hold the gene: `ATGCAATTAATTAATTCAGCGTGTAAATTGTAA`\n3. Check the criteria for a good gene:\n    a. Determine if the gene is long enough (i.e., is the gene at least as long as the minimum length threshold given above?)\n    b. Determine if the gene starts with the given start codon (hint: use the `startswith` string method)\n    c. Determine if the gene ends with at least one of the three given stop codons (hint: use the `endswith` string method)\n4. Given the conditions calculated in (3), determine if the gene is a \"good gene\"\n    a. A gene is \"good\" if it is long enough (3a), has a start codon (3b) and has at least one of the stop codons (3c).\n5. Use an f-string to print a nice message about whether the gene is good or not\n\nIn these steps, it has you basically defining all your variables up front, and then performing all the calculations.  As you write code for your solution, keep the following questions in mind: Can you think of a better \"order\" for these steps? Do you think it would be more clear if the variable was defined directly above the expression in which it was used?  (You don't have to answer those questions in this assignment -- it's just something to keep in mind as you're learning.  Eventually, you will develop preferences for this sort of thing.)\n\n#### Solution\n\n::: {#abeeea1b .cell execution_count=10}\n``` {.python .cell-code}\n# Put the code for your solution here!\n```\n:::\n\n\n## More Complex Gene Analysis\n\nFor this last problem, you will need to combine concepts from the previous three problems.\n\nYou will be given multiple gene fragments (something like exons for example) that you will need to join together (concatenate), and then check some criteria to see if it is a good sequence or not.\n\nThis time, you will be given just the general task to accomplish, and you will have to create the step-by-step breakdown.  If you get stuck, look back at the previous three problems and see how we broke the problem down into small, actionable steps that you can program.\n\n### Problem\n\n> Given the three gene fragments `ATGCAATTAATGCT`, `CTGGGTAATTCAGCCC`, and `GTTGGCGTGTAAATTGTAA`, determine if the full DNA sequence resulting from their concatenation forms a \"good gene\".  In this context a good gene has at least 40 nucleotides, has the start codon `ATG`, has one of the three stop codons (`TAA`, `TAG`, or `TGA`), and has a GC percentage of at least 40% and no more than 60%.\n\n_Note: In your solution, you *must* check for all the criteria, even if you can see that one of the checks would fail._\n\n_Note: In your solution, do *not* rely on the same variables that you created above being in scope here as well.  For example, if you created a variable called `stop_codon_1 = \"TAA\"` a the problem above, you must recreate that variable in this code block as well._\n\n### Step-By-Step Breakdown\n\nStart by writing a step-by-step breakdown of the problem here.  Use the examples above as your guide, and write small, actionable steps that you can then write code to carry out.\n\n(... write the steps here ...)\n\n1. First step...\n2. Second step...\n... remaining steps ...\n\n### Solution\n\n::: {#29653ba4 .cell execution_count=11}\n``` {.python .cell-code}\n# Put the code for your solution here!\n```\n:::\n\n\n## Summary\n\nIn this first assignment, we explored fundamental Python programming concepts essential for bioinformatics work. Through progressively challenging exercises, we learned to manipulate strings, perform calculations, and implement logical conditions -- all crucial skills for bioinformatics and data analysis. We practiced breaking down complex problems into manageable steps, from basic string operations to more sophisticated gene analysis tasks. While we worked with simple examples here, this problem-solving approach is essential for tackling real-world bioinformatics challenges. These foundational programming techniques will serve as building blocks as we tackle more advanced challenges in future assignments and miniprojects.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}