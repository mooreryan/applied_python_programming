{
  "hash": "9343278d5e1bdcd8242608c6593463a5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nauthor: \"Ryan M. Moore, PhD\"\ndate-modified: last-modified\ndate: \"2025-03-04\"\njupyter: python3\n---\n\n# Introduction to Object-Oriented Programming\n\nThink about the natural world around you for a moment. You can imagine birds, trees, cells, and countless other entities. Each of these things has specific characteristics and behaviors that help you recognize them. One way to turn these entities into code is by using Classes and Objects.\n\nIn programming terms, an _object_ is sort of like a specific entity that exists in the real world:\n\n- A particular robin building a nest outside your window\n- An individual _E. coli_ cell growing in your Petri dish\n- A specific patient in a hospital\n\nJust like real-world things, objects have two key aspects:\n\n1. **Characteristic Properties**: what the object _is_ or _has_ (identity, color, size, weight)\n2. **Behaviors**: what the object can _do_ (fly, eat, divide)\n\nFor example, that robin outside your window has a particular color (characteristic) and can sing a specific song (behavior). The _E. coli_ cell in your Petri dish has a particular size (characteristic) and can metabolize lactose (behavior).\n\nIf objects are the specific things (like a particular robin or _E. coli_ cell) in your domain, then _classes_ are the blueprints or templates that define the characteristics and behaviors of those entities.\n\nFor instance, the `Robin` _class_ might specify that all robins have characteristics like species, wingspan, feather color, beak shape, plus behaviors such as flying, singing, and nest-building. But each individual robin _instance_ would have its own specific values for these characteristics and behaviors that depend on those specific characteristics.\n\n![An example robin class with two instances](/images/robin_class_light.svg \"An example robin class with two instances\"){fig-alt=\"Diagram of a Robin class with characteristics and behaviors and two instances of that class with specific characteristics\"}\n\nClasses enable us to create our own custom data types that model real-world entities. Instead of just having numbers and strings, we can have Birds, Bacteria, Patients, Proteins, and Molecules, each with their own specialized characteristics and behaviors.\n\nThis connection between our programs and the real-world domain we are modeling is what makes object-oriented programming powerful. It allows us to represent and manipulate complex biological entities in a way that feels natural and intuitive, mirroring how we already think about these systems in our research.\n\nFor the rest of this tutorial, we'll explore how to implement Object-Oriented Programming (OOP) in Python, giving you the tools to represent the biological systems you work with in a natural way.\n\n## Four Pillars of OOP {#sec-four-pillars-oop}\n\nWhen learning about object-oriented programming (OOP), you'll often hear about four fundamental concepts (pillars) that form its foundation. These concepts help us organize code in a way that mirrors how we think about real-world objects and their relationships:\n\n- **Encapsulation**: bundling data and methods that work on that data into a single unit (a class)\n  - Restricts direct access to some components\n  - Protects internal state of an object\n  - Hides data\n- **Abstraction**: showing only essential features while hiding complicated implementation details\n- **Polymorphism**: objects of different classes responding to the same method in their own ways\n- **Inheritance**: creating new classes that receive attributes and methods from existing classes\n\nWe'll introduce some of these concepts at a practical level in this tutorial and continue to explore them throughout the course.\n\n## Classes in Python: Syntax and Structure {#sec-class-basics}\n\nNow that we have some conceptual framework for object-oriented programming, let's look at how to write classes in Python. To define a class, we use the `class` keyword, followed by the name of the class. In the indented section that follows, we can define variables and functions that will be associated with the class and with instances of the class:\n\n::: {#c7b762e8 .cell execution_count=1}\n``` {.python .cell-code}\n# Define a class named \"Robin\".\n#\n# (Class names look LikeThis rather than like_this.)\nclass Robin:\n    # Class Attributes\n    common_name = \"American Robin\"\n    species = \"Turdus migratorius\"\n    beak_shape = \"pointy\"\n\n    # The special method to initialize instances of this class\n    def __init__(self, wingspan, weight, color):\n        self.wingspan = wingspan\n        self.weight = weight\n        self.color = color\n\n    # Define some instance methods that describe the behavior that Robins\n    # will have.\n\n    # Each of these methods will use `id(self)` so that you can see the identity\n    # of the object that it is being called on.\n\n    def fly(self, to):\n        print(f\"robin {id(self)} is flying to {to}!\")\n\n    def sing(self):\n        print(f\"robin {id(self)} is singing!\")\n\n    def eat(self, what):\n        print(f\"robin {id(self)} is eating {what}!\")\n\n    def build_nest(self, where):\n        print(f\"robin {id(self)} is building a nest {where}!\")\n```\n:::\n\n\nCreating an instance of a class looks a lot like calling a function:\n\n::: {#b4d5af04 .cell execution_count=2}\n``` {.python .cell-code}\nrobin = Robin(wingspan=35, weight=80, color=\"gray & reddish brown\")\n```\n:::\n\n\nYou can access the instance attributes using the \"dot\" syntax:\n\n::: {#46d48583 .cell execution_count=3}\n``` {.python .cell-code}\nprint(\n    f\"You see a {robin.color} robin \"\n    f\"that weighs {robin.weight} grams \"\n    f\"with a wingspan of {robin.wingspan} centimeters!\"\n    \"\\nThat's a nice find!!\\n\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nYou see a gray & reddish brown robin that weighs 80 grams with a wingspan of 35 centimeters!\nThat's a nice find!!\n\n```\n:::\n:::\n\n\nEven though we specified what each of the objects attributes should be when we created it, that doesn't mean we can't change them later if we need to. Let's say our robin eats a worm, and then it gains a little weight afterwards:\n\n::: {#6fb03ee5 .cell execution_count=4}\n``` {.python .cell-code}\n# Show the robin's current weight\nprint(f\"before eating the worm, the robin weighs {robin.weight} grams\")\n\n# The robin eats the worm\nrobin.eat(\"a delicious worm\")\n\n# Then it gains 2 grams of weight\nrobin.weight += 2\n\n# Show the robin's weight again\nprint(f\"after eating the worm, the robin weighs {robin.weight} grams\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbefore eating the worm, the robin weighs 80 grams\nrobin 4399923952 is eating a delicious worm!\nafter eating the worm, the robin weighs 82 grams\n```\n:::\n:::\n\n\nWe can access the object's behavior by \"calling\" its methods:\n\n::: {#84d902e8 .cell execution_count=5}\n``` {.python .cell-code}\nrobin.sing()\nrobin.fly(to=\"Mexico\")\nrobin.eat(what=\"a worm\")\nrobin.build_nest(where=\"in a tree\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nrobin 4399923952 is singing!\nrobin 4399923952 is flying to Mexico!\nrobin 4399923952 is eating a worm!\nrobin 4399923952 is building a nest in a tree!\n```\n:::\n:::\n\n\nMultiple distinct instances of the `Robin` class can be created. Check out how each of them has a different ID:\n\n::: {#58fbaec3 .cell execution_count=6}\n``` {.python .cell-code}\nrobin_1 = Robin(wingspan=35, weight=80, color=\"gray & reddish brown\")\nrobin_2 = Robin(wingspan=32, weight=78, color=\"gray & brownish orange\")\nrobin_3 = Robin(wingspan=36, weight=79, color=\"gray & reddish brown\")\n\nprint(robin_1)\nprint(robin_2)\nprint(robin_3)\n\nrobin_1.sing()\nrobin_2.sing()\nrobin_3.sing()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<__main__.Robin object at 0x109e9b4d0>\n<__main__.Robin object at 0x109e9b390>\n<__main__.Robin object at 0x10636e520>\nrobin 4461278416 is singing!\nrobin 4461278096 is singing!\nrobin 4399228192 is singing!\n```\n:::\n:::\n\n\nEven though all three of the `Robin` objects were created from the same class, they are distinct entities in our program. If we change something about one of them, it won't change the others:\n\n::: {#762f1f12 .cell execution_count=7}\n``` {.python .cell-code}\nprint(\n    \"before changing weight and color of robin 1,\",\n    \"the weight and color of robin 2 are:\",\n)\nprint(robin_2.weight)\nprint(robin_2.color)\n\n\nrobin_1.weight += 1\nrobin_1.color = \"mostly gray, with some reddish brown\"\n\nprint(\n    \"\\nafter changing weight and color of robin 1,\",\n    \"the weight and color of robin 2 are:\",\n)\nprint(robin_2.weight)\nprint(robin_2.color)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbefore changing weight and color of robin 1, the weight and color of robin 2 are:\n78\ngray & brownish orange\n\nafter changing weight and color of robin 1, the weight and color of robin 2 are:\n78\ngray & brownish orange\n```\n:::\n:::\n\n\nFinally, we can even give objects completely new attributes if we want to:\n\n::: {#533385a0 .cell execution_count=8}\n``` {.python .cell-code}\nrobin_1.favorite_food = \"french fries\"\n\nprint(robin_1.favorite_food)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfrench fries\n```\n:::\n:::\n\n\nBe careful with this though. That attribute will _not_ be available on all your objects. It will only exist on the specific object where you explicitly added it:\n\n::: {#6d750ead .cell execution_count=9}\n``` {.python .cell-code}\ntry:\n    print(robin_2.favorite_food)\nexcept AttributeError as error:\n    print(error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'Robin' object has no attribute 'favorite_food'\n```\n:::\n:::\n\n\nNext, let's dig into some more of the details of creating and using classes in Python.\n\n## Initializing Objects\n\nWhen you instantiate an object from a class in Python, it doesn't simply create an empty shell. Instead, it invokes a special initialization method called `__init__` (if defined). This method serves as the object's constructor, handling the necessary setup to ensure the newly created object is fully functional.\n\nLet's make a new class called `BlueJay` to illustrate some of the details:\n\n::: {#0a39125b .cell execution_count=10}\n``` {.python .cell-code}\nclass BlueJay:\n    def __init__(self):\n        self.wingspan = 38  # centimeters\n        self.color = \"blue\"\n```\n:::\n\n\nIn this class, the **init** method takes only one parameter, self, which refers to the newly created object. It assigns the instance attribute color a default value of \"blue\". Take a look:\n\n::: {#36a67577 .cell execution_count=11}\n``` {.python .cell-code}\nblue_jay = BlueJay()\nprint(blue_jay)\nprint(blue_jay.wingspan)\nprint(blue_jay.color)\n\n# We can change the value of an instance attribute after the object is created.\nblue_jay.wingspan = 35\nblue_jay.color = \"shockingly blue\"\n\nprint(blue_jay.wingspan)\nprint(blue_jay.color)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<__main__.BlueJay object at 0x1064181a0>\n38\nblue\n35\nshockingly blue\n```\n:::\n:::\n\n\nCreating an object then immediately updating its attributes is such a common operation that Python lets you do it all in one step. This is done by adding additional parameters to the `__init__` function:\n\n::: {#63c5b0c2 .cell execution_count=12}\n``` {.python .cell-code}\nclass BlueJay:\n    def __init__(self, wingspan, color):\n        self.wingspan = wingspan\n        self.color = color\n\n\nblue_jay = BlueJay(wingspan=36, color=\"bright blue\")\nprint(blue_jay)\nprint(blue_jay.wingspan)\nprint(blue_jay.color)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<__main__.BlueJay object at 0x109e43230>\n36\nbright blue\n```\n:::\n:::\n\n\nNow, we need to call `BlueJay` and provide the `color` and `wingspan` arguments. Failing to do so will result in an error:\n\n::: {#758f565c .cell execution_count=13}\n``` {.python .cell-code}\ntry:\n    BlueJay()\nexcept TypeError as error:\n    print(error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBlueJay.__init__() missing 2 required positional arguments: 'wingspan' and 'color'\n```\n:::\n:::\n\n\nThe error hints at Python's inner workings. It mentions that two required arguments are missing: `color` and `wingspan`. But hang on, doesn't `__init__` have three parameters?\n\nIt does! This reveals how Python handles class instantiation: it first _creates_ the object (via `__new__` behind the scenes), then _initializes_ it with `__init__`.\n\nWhen initializing, Python automatically passes the new object as the first argument (typically called `self`, but you could name it anything). You only need to provide the remaining arguments -- hence the error about missing two arguments, not three.\n\nRemember that `__init__` works like any other Python function. You can use all the parameter options we covered earlier (see @sec-function-parameters), such as default values for parameters like `color`:\n\n::: {#2bef2d07 .cell execution_count=14}\n``` {.python .cell-code}\nclass BlueJay:\n    def __init__(self, wingspan, color=\"blue\"):\n        self.wingspan = wingspan\n        self.color = color\n\nblue_jay = BlueJay(wingspan=35)\n\nprint(blue_jay.color)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nblue\n```\n:::\n:::\n\n\n### Validating Inputs\n\nThe `__init__` method plays a crucial role in validating data when creating class instances. For example, if we need to ensure birds can't have negative wingspans or empty color strings, we can build these checks directly into initialization. When someone creates a bird with invalid data, instead of failing, the code can substitute sensible defaults. This approach guarantees that all instances meet our basic requirements, protecting against bad input:\n\n::: {#46240af0 .cell execution_count=15}\n``` {.python .cell-code}\nclass BlueJay:\n    def __init__(self, wingspan, color=\"blue\"):\n        if wingspan < 0:\n            self.wingspan = 0\n        else:\n            self.wingspan = wingspan\n\n        if color == \"\":\n            self.color = \"blue\"\n        else:\n            self.color = color\n\n\nblue_jay = BlueJay(-234, \"\")\nprint(blue_jay.wingspan)\nprint(blue_jay.color)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\nblue\n```\n:::\n:::\n\n\nIf you can't identify a reasonable default value, the most straightforward approach is to simply raise an error. This strategy helps to prevent failures later on.\n\n::: {#9727bdbb .cell execution_count=16}\n``` {.python .cell-code}\nclass Bird:\n    def __init__(self, species):\n        if species == \"\":\n            raise ValueError(\"species name cannot be blank\")\n\n\ntry:\n    Bird(\"\")\nexcept ValueError as error:\n    print(error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nspecies name cannot be blank\n```\n:::\n:::\n\n\n## Attributes\n\nAttributes are the data that is associated with the class and with instances of that class.\n\n### Instance Attributes\n\nWhen initializing a BlueJay object, the `__init__` function sets up two attributes: `wingspan` and `color`. The `self` parameter refers to the actual instance being created, so `self.wingspan = 1234` creates a wingspan attribute on your new `BlueJay` object.\n\nInstance attributes are not shared between different instances of the same class:\n\n::: {#d31d877a .cell execution_count=17}\n``` {.python .cell-code}\ntiny_blue_jay = BlueJay(wingspan=28)\nbig_blue_jay = BlueJay(wingspan=40)\n\nprint(tiny_blue_jay.wingspan)\nprint(big_blue_jay.wingspan)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n28\n40\n```\n:::\n:::\n\n\nIf we change one after creation, it will not affect the other:\n\n::: {#4473ca9d .cell execution_count=18}\n``` {.python .cell-code}\ntiny_blue_jay.wingspan += 1\n\nprint(tiny_blue_jay.wingspan)\nprint(big_blue_jay.wingspan)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n29\n40\n```\n:::\n:::\n\n\nNice! Each object independently manages its state, completely separate from other objects. Just be careful with mutable values in instance attributes though. For example, if you store a bird's colors as a list (since birds can have multiple colors), you might run into some unexpected behavior:\n\n::: {#835a7cde .cell execution_count=19}\n``` {.python .cell-code}\ncolors = [\"blue\", \"white\", \"black\"]\n\n# Create two BlueJay instances with the same color list.\ntiny_blue_jay = BlueJay(wingspan=28, color=colors)\nbig_blue_jay = BlueJay(wingspan=40, color=colors)\nprint(tiny_blue_jay.color)\nprint(big_blue_jay.color)\n\n# Can you guess what will happen if we change one of the colors?\ntiny_blue_jay.color[0] = \"electric blue\"\nprint(\"\\nafter changing color[0] of tiny_blue_jay\")\nprint(tiny_blue_jay.color)\nprint(big_blue_jay.color)\n\n# Or add a color to one of them?\nprint(\"\\nafter appending a new color to big_blue_jay\")\nbig_blue_jay.color.append(\"light blue\")\nprint(tiny_blue_jay.color)\nprint(big_blue_jay.color)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['blue', 'white', 'black']\n['blue', 'white', 'black']\n\nafter changing color[0] of tiny_blue_jay\n['electric blue', 'white', 'black']\n['electric blue', 'white', 'black']\n\nafter appending a new color to big_blue_jay\n['electric blue', 'white', 'black', 'light blue']\n['electric blue', 'white', 'black', 'light blue']\n```\n:::\n:::\n\n\nI know I just explained that instance attributes are independent between objects, which might seem contradictory here. But remember our discussion about mutable parameters back in @sec-mutable-parameters? Python variables are actually references to objects, not the objects themselves. In the example, both `BlueJay` instances ended up referencing the identical list object. Keep this behavior in mind: it's a common source of subtle bugs.\n\nAs mentioned earlier, you can add more instance attributes to an object after creation:\n\n::: {#85f57ac2 .cell execution_count=20}\n``` {.python .cell-code}\nblue_jay = BlueJay(wingspan=35)\n\nblue_jay.sneakiness = \"very sneaky\"\n\nprint(f\"this blue jay is {blue_jay.sneakiness}!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthis blue jay is very sneaky!\n```\n:::\n:::\n\n\n### Class Attributes\n\nIn our earlier look at the `Robin` class in @sec-class-basics, we used class attributes for data shared across all instances. This approach is ideal for information common to all robins, things like common name, species, and beak shape. Class attributes make sense when the data belongs to the entire group rather than to specific individuals.\n\nClass attributes are defined directly within the class, but outside any methods:\n\n::: {#8839a9e0 .cell execution_count=21}\n``` {.python .cell-code}\nclass BlueJay:\n    common_name = \"Blue Jay\"\n    species = \"Cyanocitta cristata\"\n    beak_shape = \"medium-length, conical\"\n\n\nblue_jay = BlueJay()\n\nprint(blue_jay.species)\nprint(blue_jay.beak_shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCyanocitta cristata\nmedium-length, conical\n```\n:::\n:::\n\n\nYou can also access class attributes directly on the class object itself:\n\n::: {#a9dc1500 .cell execution_count=22}\n``` {.python .cell-code}\nprint(BlueJay.species)\nprint(BlueJay.beak_shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCyanocitta cristata\nmedium-length, conical\n```\n:::\n:::\n\n\nAside: that might seem a bit weird, but in Python, classes themselves are also objects that have properties and methods:\n\n::: {#441fd822 .cell execution_count=23}\n``` {.python .cell-code}\nprint(BlueJay.__class__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'type'>\n```\n:::\n:::\n\n\nWe will talk more about this later in the course.\n\nLet's update the `BlueJay` class to have both class and instance attributes:\n\n::: {#8f866ce5 .cell execution_count=24}\n``` {.python .cell-code}\nclass BlueJay:\n    # Set class attributes\n    common_name = \"Blue Jay\"\n    species = \"Cyanocitta cristata\"\n    beak_shape = \"medium-length, conical\"\n\n    def __init__(self, wingspan=38, color=\"blue\"):\n        # Set instance attributes\n        self.wingspan = wingspan\n        self.color = color\n\n\ntiny_blue_jay = BlueJay(wingspan=28)\nbig_blue_jay = BlueJay(wingspan=40)\n\n# All blue jays will have the same values for the class attributes, but likely\n# have different values for the instance attributes.\nprint(tiny_blue_jay.wingspan, tiny_blue_jay.species)\nprint(big_blue_jay.wingspan, big_blue_jay.species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n28 Cyanocitta cristata\n40 Cyanocitta cristata\n```\n:::\n:::\n\n\n#### Modifying Class Attributes\n\nClass attributes don't have to be constant, unchanging things. Let's look at an example where we change the value of a class attribute from within an instance method to create sequential IDs for instances of that class. Check it out:\n\n::: {#c83ac509 .cell execution_count=25}\n``` {.python .cell-code}\nclass Amoeba:\n    # This is a class attribute\n    counter = 0\n\n    def __init__(self, name=None):\n        # We increment the value stored in the counter class attribute by 1.\n        Amoeba.counter += 1\n\n        # Then, we set that value to the value of this amoeba instance's `id`\n        # attribute.\n        self.id = Amoeba.counter\n\n        # If the user doesn't specify a name, then we create a default name\n        # that includes the ID.\n        if name is None:\n            self.name = f\"Amoeba_{self.id}\"\n        else:\n            self.name = name\n\n\namoeba_1 = Amoeba()\namoeba_2 = Amoeba(name=\"Bob the Amoeba\")\namoeba_3 = Amoeba()\n\nprint(amoeba_1.name)\nprint(amoeba_2.name)\nprint(amoeba_3.name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAmoeba_1\nBob the Amoeba\nAmoeba_3\n```\n:::\n:::\n\n\nPretty neat! We will go into more fancy details like this in a future tutorial.\n\n#### A Tricky Example\n\nIn our last example, we contained mutations within class methods—a safer approach than external state modification, which often causes bugs. Let's flip this and see what happens when we modify class variables from outside. Warning: it gets a bit confusing!\n\n::: {#8be45ab9 .cell execution_count=26}\n``` {.python .cell-code}\nprint(\"tiny_blue_jay species:\", tiny_blue_jay.species, id(tiny_blue_jay.species))\nprint(\"big_blue_jay species:\", big_blue_jay.species, id(big_blue_jay.species))\nprint()\n\ntiny_blue_jay.species = \"i don't know!\"\n\nprint(\"tiny_blue_jay species:\", tiny_blue_jay.species, id(tiny_blue_jay.species))\nprint(\"big_blue_jay species:\", big_blue_jay.species, id(big_blue_jay.species))\nprint()\n\nBlueJay.species = \"something else\"\n\nprint(\"tiny_blue_jay species:\", tiny_blue_jay.species, id(tiny_blue_jay.species))\nprint(\"big_blue_jay species\", big_blue_jay.species, id(big_blue_jay.species))\nprint()\n\nanother_blue_jay = BlueJay()\nprint(\n    \"another_blue_jay species:\",\n    another_blue_jay.species,\n    id(another_blue_jay.species),\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntiny_blue_jay species: Cyanocitta cristata 4399868208\nbig_blue_jay species: Cyanocitta cristata 4399868208\n\ntiny_blue_jay species: i don't know! 4400285744\nbig_blue_jay species: Cyanocitta cristata 4399868208\n\ntiny_blue_jay species: i don't know! 4400285744\nbig_blue_jay species something else 4400345776\n\nanother_blue_jay species: something else 4400345776\n```\n:::\n:::\n\n\nLet's break this down:\n\n1. Initially, all `BlueJay` instances share the class attribute `species` with value `\"Cyanocitta cristata\"` (note the matching IDs in the first two lines).\n2. When we set `tiny_blue_jay.species = \"i don't know!\"`, we're not changing the class attribute, we're creating a new instance attribute that shadows it. The ID changes for `tiny_blue_jay` but stays the same for `big_blue_jay`.\n3. With `BlueJay.species = \"something else\"`, we modify the actual class attribute. This affects all instances that don't have their own shadowing attribute—big_blue_jay sees the new value, but tiny_blue_jay still shows its instance-specific value.\n4. Any new instance (like `another_blue_jay`) gets the updated class attribute value.\n\nThe apparent complexity stems from Python's attribute lookup sequence:\n\n1. Check the instance namespace first\n2. Then check the class namespace\n3. Finally, check parent classes\n\nThis enables both shared values and individual customization with the same name. This is very flexible, but potentially confusing if you don't understand the lookup mechanism.\n\n## Methods\n\nMethods are functions inside classes that usually work with instances of that class. Class methods exist too (like class attributes), but we'll skip those for now.\n\nOur previous examples were pretty basic. Let's look at something a bit more interesting to showcase why classes and objects are actually useful.\n\n::: {#5a1193b5 .cell execution_count=27}\n``` {.python .cell-code}\nclass Amoeba:\n    \"\"\"\n    Represent an amoeba with position and energy tracking.\n\n    This class models an amoeba that can move around in a 2D space and manage\n    its energy levels. Each amoeba has a unique ID, position coordinates, and\n    energy value.\n\n    Attributes:\n        counter (int): Class variable that keeps track of how many amoeba instances\n            have been created.\n        id (str): Unique identifier for each amoeba instance.\n        position (list): A list of two integers representing [x, y] coordinates.\n        energy (int): Current energy level of the amoeba.\n    \"\"\"\n\n    counter = 0\n\n    def __init__(self, position=None, energy=5):\n        Amoeba.counter += 1\n        self.id = f\"Amoeba #{Amoeba.counter}\"\n\n        if position is None:\n            self.position = [0, 0]\n        else:\n            self.position = position\n\n        self.energy = energy\n\n    # This method controls how Amoebas will be printed\n    def __str__(self):\n        return f\"{self.id} -- Position: {self.position}, Energy: {self.energy}\"\n\n    def move(self, direction):\n        \"\"\"Move the amoeba, consuming energy.\"\"\"\n\n        if self.energy <= 0:\n            print(f\"{self.id} is too weak to move!\")\n            return\n\n        if direction == \"right\":\n            print(f\"{self.id} moves right!\")\n            # Moving to the right means adding one to the x position\n            self.position[0] += 1\n        elif direction == \"left\":\n            print(f\"{self.id} moves left!\")\n            # Moving to the left means subtracting one from the x position\n            self.position[0] -= 1\n        elif direction == \"up\":\n            print(f\"{self.id} moves up!\")\n            # Moving up means adding one to the y position\n            self.position[1] += 1\n        elif direction == \"down\":\n            print(f\"{self.id} moves down!\")\n            # Moving down means subtracting one from the y position\n            self.position[1] -= 1\n        else:\n            raise ValueError(\"direction must one of up, down, left, or right\")\n\n        self.energy -= 1\n\n    def eat(self):\n        \"\"\"The amoeba eats, increasing its energy.\"\"\"\n        print(f\"{self.id} eats\")\n        self.energy += 2\n```\n:::\n\n\nThere are a lot of things to break down about the `Amoeba` class. Let's look at a few key points:\n\n- **Class attributes vs. Instance attributes**:\n  - `counter` is a class attribute shared across all instances\n  - `id`, `position`, and `energy` are instance attributes unique to each object\n- **Constructor Implementation**:\n  - Uses `__init__` to set up each new amoeba with its initial state\n  - Automatically increments the counter to assign unique IDs\n  - Handles default parameters (`position=None, energy=5`)\n  - Sets a default position if none is provided\n- **String Representation**:\n  - Implements `__str__` to provide a human-readable representation\n  - Returns formatted string containing the amoeba's ID, position and energy\n- **`move() Method Implementation**:\n  - `move()` validates input parameters\n  - Checks current state before performing actions (`if self.energy <= 0`)\n  - Demonstrates internal state modification (changing position and reducing energy)\n  - Shows error handling with a descriptive error message (`ValueError`) for bad inputs\n- **2D Movement Representation**:\n  - Uses a list `[x, y]` to represent position in 2D space\n  - Adjusts coordinates based on movement direction\n- **State Management**:\n  - Class methods track and update the amoeba's internal state (position, energy)\n  - Behavior depends on internal state (the amoeba can't move with 0 energy)\n- **Code Organization**:\n  - Uses docstrings for class and method documentation\n  - Follows consistent indentation and naming conventions (methods names are short verbs)\n\nNow, let's try it out!\n\n::: {#af676e46 .cell execution_count=28}\n``` {.python .cell-code}\nimport random\n\n# These are the four directions that an amoeba can move\nfour_directions = [\"up\", \"down\", \"left\", \"right\"]\n\n# Seed the random generator so that we get the same result each time we run the code\nrandom.seed(37424)\n\n# Generate a random \"walk\"\ndirections = random.choices(four_directions, k=10)\n\n# Create a new amoeba instance\namoeba = Amoeba()\n\n# Go through each of the moves one by one\nfor direction in directions:\n    print(amoeba)\n\n    # Each turn, the amoeba has a 1/5 chance in eating some lunch\n    if random.random() < 0.2:\n        amoeba.eat()\n\n    # Then the amoeba tries to move\n    amoeba.move(direction)\n    print()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAmoeba #1 -- Position: [0, 0], Energy: 5\nAmoeba #1 eats\nAmoeba #1 moves down!\n\nAmoeba #1 -- Position: [0, -1], Energy: 6\nAmoeba #1 moves down!\n\nAmoeba #1 -- Position: [0, -2], Energy: 5\nAmoeba #1 moves left!\n\nAmoeba #1 -- Position: [-1, -2], Energy: 4\nAmoeba #1 eats\nAmoeba #1 moves down!\n\nAmoeba #1 -- Position: [-1, -3], Energy: 5\nAmoeba #1 moves up!\n\nAmoeba #1 -- Position: [-1, -2], Energy: 4\nAmoeba #1 moves down!\n\nAmoeba #1 -- Position: [-1, -3], Energy: 3\nAmoeba #1 moves up!\n\nAmoeba #1 -- Position: [-1, -2], Energy: 2\nAmoeba #1 moves left!\n\nAmoeba #1 -- Position: [-2, -2], Energy: 1\nAmoeba #1 moves up!\n\nAmoeba #1 -- Position: [-2, -1], Energy: 0\nAmoeba #1 is too weak to move!\n\n```\n:::\n:::\n\n\n### Aside: Refactoring the Amoeba Class\n\nAfter building our Amoeba class, we can see that some functionality, specifically position tracking and movement, isn't necessarily Amoeba-specific. We're currently using a two-element list for position and updating it within the Amoeba's `move` method. While this works for our small class, let's extract this common behavior into a dedicated `Position` class.\n\n::: {#ec7d4dca .cell execution_count=29}\n``` {.python .cell-code}\nclass Position:\n    \"\"\"\n    Represents a position in 2D space.\n\n    This class handles tracking and updating a position in a 2D grid system,\n    with methods for moving in cardinal directions.\n\n    Attributes:\n        x (int): The x-coordinate\n        y (int): The y-coordinate\n    \"\"\"\n\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return f\"({self.x}, {self.y})\"\n\n    def move_right(self):\n        \"\"\"Move one unit to the right (increase x).\"\"\"\n        self.x += 1\n\n    def move_left(self):\n        \"\"\"Move one unit to the left (decrease x).\"\"\"\n        self.x -= 1\n\n    def move_up(self):\n        \"\"\"Move one unit up (increase y).\"\"\"\n        self.y += 1\n\n    def move_down(self):\n        \"\"\"Move one unit down (decrease y).\"\"\"\n        self.y -= 1\n```\n:::\n\n\nNow that we have the `Position` class, we can use it in the `Amoeba` class instead of the original two-element list. In this way, the `Amoeba` class delegates the behavior of position and movement to the `Position` class rather than manage that itself.\n\n::: {#179f2980 .cell execution_count=30}\n``` {.python .cell-code}\nclass Amoeba:\n    \"\"\"\n    Represent an amoeba with position and energy tracking.\n\n    This class models an amoeba that can move around in a 2D space and manage\n    its energy levels. Each amoeba has a unique ID, position coordinates, and\n    energy value.\n\n    Attributes:\n        counter (int): Class variable that keeps track of how many amoeba instances\n            have been created.\n        id (str): Unique identifier for each amoeba instance.\n        position (Position): A Position object representing the amoeba's location.\n        energy (int): Current energy level of the amoeba.\n    \"\"\"\n\n    counter = 0\n\n    def __init__(self, position=None, energy=5):\n        Amoeba.counter += 1\n        self.id = f\"Amoeba #{Amoeba.counter}\"\n\n        if position is None:\n            self.position = Position()\n        else:\n            self.position = position\n\n        self.energy = energy\n\n    def __str__(self):\n        return f\"{self.id} -- Position: {self.position}, Energy: {self.energy}\"\n\n    def move(self, direction):\n        \"\"\"Move the amoeba, consuming energy.\"\"\"\n\n        if self.energy <= 0:\n            print(f\"{self.id} is too weak to move!\")\n            return\n\n        if direction == \"right\":\n            print(f\"{self.id} moves right!\")\n            self.position.move_right()\n        elif direction == \"left\":\n            print(f\"{self.id} moves left!\")\n            self.position.move_left()\n        elif direction == \"up\":\n            print(f\"{self.id} moves up!\")\n            self.position.move_up()\n        elif direction == \"down\":\n            print(f\"{self.id} moves down!\")\n            self.position.move_down()\n        else:\n            raise ValueError(\"direction must one of up, down, left, or right\")\n\n        self.energy -= 1\n\n    def eat(self):\n        \"\"\"The amoeba eats, increasing its energy.\"\"\"\n        self.energy += 1\n```\n:::\n\n\nThere's a new syntax element to note: `self.position.move_right()`. This expression chains multiple \"dots\" to connect attributes and method calls, something you'll see frequently in Python. You can read it left to right like this:\n\n![A schematic of chained method calls](/images/self_position_move_light.svg \"A schematic of chained method calls\"){fig-alt=\"A schematic of chained method calls: self which represents an amoeba on the left, position, which represents a Position in the middle, and move_right(), which represents a method of the Position class on the right. All are connected by arrows.\"}\n\n[Extracting](https://refactoring.com/catalog/extractClass.html) the `Position` class from the `Amoeba` class brings a couple of nice benefits:\n\n- [Separation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns): Each class now has a single responsibility\n- [Reusability](https://en.wikipedia.org/wiki/Reusability)\n  - The `Position` class could now be used for other entities that need position tracking.\n  - If we need to change how positions work, we only need to change one place rather than in every class that need position tracking.\n- [Encapsulation](<https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)>): Position management details are hidden inside the `Position` class\n\nThis process is called a [refactoring](https://refactoring.com/), and in this case, we have shown how to spot shared functionality and extract it into a separate class. While this is a good skill to have in your toolkit, don't feel that you have to separate everything. Sometimes it's overkill, especially for one-off scripts or when code reuse is unlikely. Use your judgment!\n\n### Special Methods\n\nSpecial methods (like `__init__` and `__str__`) let your custom classes work with Python's built-in operations. These \"magic methods\" act as interfaces between your code and core Python functionality. Though they have a cool name, these methods aren't mysterious, rather, they're like standardized hooks that let your classes interact more easily with Python's built-in functions.\n\nFor example, when Python performs certain operations, it looks for certain methods:\n\n- When using the `+` operator, Python looks for the `__add__` method\n- When using the `len()` function, Python looks for the `__len__` method\n- When initializing an object, Python looks for the `__init__` method\n- When printing an object, Python looks for the `__str__` method\n\nBy implementing these methods, your custom objects can behave like Python's native types. For example, a DNA sequence class with `__add__` could allow sequence concatenation using the simple `+` operator, just like with strings.\n\nIn the `Amoeba` and `Position` classes, we implemented `__str__`. The `__str__` method is called whenever Python needs a human-readable string representation of your object, such as when you use the `print()` function.\n\nThe `__str__` method should return a concise, informative string that gives the user meaningful information about the object. If you don't define a `__str__` method for your class, Python will use a default representation. Compare the output when printing an `Amoeba` instance versus when printing a `BlueJay` instance:\n\n::: {#6d246816 .cell execution_count=31}\n``` {.python .cell-code}\nprint(Amoeba())\nprint(BlueJay())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAmoeba #1 -- Position: (0, 0), Energy: 5\n<__main__.BlueJay object at 0x10a19e650>\n```\n:::\n:::\n\n\nSince we didn't explicitly define a `__str__` method for the `BlueJay` class, Python prints a default representation of the object, rather than a nice, informative message.\n\n## Duck Typing\n\nThe [duck test](https://en.wikipedia.org/wiki/Duck_test) goes something like this:\n\n> If it looks like a duck, swims like a duck, and quacks like a duck, then it probably _is_ a duck!\n\nMany programming languages, including Python, use this idea for something we call [duck typing](https://docs.python.org/3/glossary.html#term-duck-typing). In this context, Python is essentially saying, \"Well, I don't know what class this object is, but if it can `swim` or `fly` or `quack`, then I will treat it like a `Duck`.\" In other words, it only cares whether the object can perform the needed actions. If it can, then Python will happily work with it regardless of what it actually is. This practical approach represents one way Python implements the polymorphism pillar of OOP mentioned earlier.\n\nLet's see an example of this in action:\n\n::: {#bc7d86a9 .cell execution_count=32}\n``` {.python .cell-code}\nclass Duck:\n    def quack(self):\n        print(\"quack, QUACK!!\")\n\n    def fly(self):\n        print(\"the duck is flying!\")\n\n    def swim(self):\n        print(\"the duck is swimming\")\n\n\nclass Gull:\n    def squawk(self):\n        print(\"squawk!!!\")\n\n    def fly(self):\n        print(\"the crow flies!\")\n\n    def swim(self):\n        print(\"the gull swims near the beach\")\n\n\nclass Whale:\n    def swim(self):\n        print(\"the whale is swims underwater\")\n```\n:::\n\n\nAll three of these classes have a method called `swim`. If we have a collection of those objects, we can call the `swim` method on each of them without having to know what type the object is:\n\n::: {#04dd6b00 .cell execution_count=33}\n``` {.python .cell-code}\nanimals = [Duck(), Duck(), Gull(), Whale()]\n\nfor animal in animals:\n    animal.swim()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthe duck is swimming\nthe duck is swimming\nthe gull swims near the beach\nthe whale is swims underwater\n```\n:::\n:::\n\n\nWhile convenient, you might not always know if your objects have the method you need. There are two common ways to deal with this:\n\n1. Simply call the method and catch any exceptions that occur. (the Python docs call this [EAFP style programming](https://docs.python.org/3/glossary.html#term-EAFP) -- \"Easier to ask for forgiveness than permission\")\n2. Check if the object has the method before attempting to call it. (the Python docs call this [LBYL style programming](https://docs.python.org/3/glossary.html#term-LBYL) -- \"look before you leap\")\n\nBoth approaches have their place, depending on your specific situation and coding style preferences. Let's look at examples of both approaches.\n\n### Asking for Forgiveness {#sec-asking-for-forgiveness}\n\nIn this example, we call the method `fly` on each `animal` and catch any exceptions that occur using `try/except`.\n\n::: {#71f5d6ce .cell execution_count=34}\n``` {.python .cell-code}\nanimals = [Duck(), Duck(), Gull(), Whale()]\n\nfor animal in animals:\n    try:\n        animal.fly()\n    except AttributeError as error:\n        print(error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthe duck is flying!\nthe duck is flying!\nthe crow flies!\n'Whale' object has no attribute 'fly'\n```\n:::\n:::\n\n\n### Looking Before You Leap\n\nIn this example, we use `hasattr` (short for \"has attribute\") to check if each `animal` has the `fly` attribute before attempting to call the method.\n\n::: {#3fd65885 .cell execution_count=35}\n``` {.python .cell-code}\nanimals = [Duck(), Duck(), Gull(), Whale()]\n\nfor animal in animals:\n    if hasattr(animal, \"fly\"):\n        animal.fly()\n    else:\n        print(f\"{animal} can't fly!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthe duck is flying!\nthe duck is flying!\nthe crow flies!\n<__main__.Whale object at 0x10646c050> can't fly!\n```\n:::\n:::\n\n\n### Special Methods & Duck Typing\n\nLet's return once more to Python's special \"magic methods\". These are a great example of how duck typing can be useful. If we implement special methods like `__str__` or `__len__` for our custom classes, then Python can treat them like built-ins. Here's an example of a `Gene` class:\n\n::: {#df4db0c2 .cell execution_count=36}\n``` {.python .cell-code}\nclass Gene:\n    def __init__(self, name, sequence):\n        self.name = name\n        self.sequence = sequence\n\n    # Special method for string representation\n    def __str__(self):\n        return f\">{self.name}\\n{self.sequence}\"\n\n    # Special method for length\n    def __len__(self):\n        return len(self.sequence)\n\n\ngene = Gene(\"awesome_gene\", \"ATGATATCCATCGCTACTAGACTACTACGCGCGGCTCT\")\n\nprint(len(gene))\nprint(gene)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n38\n>awesome_gene\nATGATATCCATCGCTACTAGACTACTACGCGCGGCTCT\n```\n:::\n:::\n\n\nIn this example, our `__str__` method formats the gene to match FASTA file conventions, while the length method returns the sequence length. These additions help our `Gene` class behave more like native Python objects, seamlessly integrating with the language's expectations.\n\n## Standard Python Classes\n\nIn @sec-collections, we introduced built-in Python data structures like lists, dictionaries, and sets. Now we can recognize these as classes that follow the principles we've just learned: they combine data and behavior into objects with methods that help us work with them safely and effectively.\n\nLet's look at a few examples of how built-in Python classes provide methods that operate on their internal data:\n\n::: {#542da7ea .cell execution_count=37}\n``` {.python .cell-code}\n# List methods\nmy_list = [1, 2, 3, 4]\n\n# Adds an element to the end\nmy_list.append(5)\n\n# Reverses the list in-place\nmy_list.reverse()\n\nprint(my_list)\n\n# String methods\ntext = \"  hello world  \"\n\n# Strip whitespace\nprint(text.strip())\n\n# Strip whitespace, then uppercase\nprint(text.strip().upper())\n\n# Strip whitespace, then uppercase, then replace capital L with lowercase l\nprint(text.strip().upper().replace(\"L\", \"l\"))\n\n\ngene_info = {\"name\": \"some_gene\", \"chromosome\": 10}\n\n# Print the keys\nprint(gene_info.keys())\n\n# \"Merge\" the dictionaries\ngene_info.update({\"function\": \"tumor suppressor\"})\n\nprint(gene_info)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\nhello world\nHELLO WORLD\nHEllO WORlD\ndict_keys(['name', 'chromosome'])\n{'name': 'some_gene', 'chromosome': 10, 'function': 'tumor suppressor'}\n```\n:::\n:::\n\n\nOther commonly used built-in classes include:\n\n- `set` -- for handling collections of unique items\n- `file` objects -- returned when opening files with the `open()` function\n- `datetime` -- for working with dates and times\n\nEach of these classes encapsulates both data (like the items in a list) and behavior (methods like `append` or `sort`), just like the custom classes we wrote in this tutorial.\n\n## Object-Oriented Thinking\n\nNow that you have seen the mechanics of building and using classes in Python, let's get a little meta. When thinking in an object-oriented way, you see your system in terms interacting entities -- an approach that fits naturally with how we like to think about biological systems. Here's a quick guide to developing an object-oriented mindset:\n\n- Identify key entities\n  - What are your main working pieces?\n  - Physical things like cells, proteins, genes, patients?\n  - Abstract concepts like Files, Queues, Nodes, Graphs?\n- Determine their properties\n  - What characteristics define them?\n  - Example: cells have size, type, metabolic rate\n- Identify their actions\n  - What can they do?\n  - Cells divide, proteins fold, birds fly, files can be read\n- Group related functionality: cell properties and behaviors belong in a Cell class\n- Split classes when they become unwieldy or overly complex\n\nStart with these steps as your foundation. As you gain experience, you'll naturally develop a feel for modeling systems that works best for your specific projects.\n\n### Balancing Approaches\n\nPython's flexibility lets you mix programming approaches within a single project or script.\n\nGood Python code often combines different [paradigms](https://en.wikipedia.org/wiki/Programming_paradigm):\n\n- **Object-oriented** for modeling biological entities where data and behavior are linked\n- **Functional** for data transformations and analysis\n- **Procedural** for simple sequential operations\n\nLet the problem you're tyring to solve guide your programming approach. Sometimes a simple module with functions works better than a class, while other times a well-designed class hierarchy models your domain in the clearest way.\n\nIn general, classes work well when you're working with entities that have both data (attributes) and behaviors (methods) that naturally belong together. Consider using classes when:\n\n- You need multiple similar entities with shared structure and behavior (like 1000 cells in a simulation)\n- You repeatedly apply the same operations to specific data types\n- Your data needs validation (ensuring DNA sequences only contain valid nucleotides)\n- Data and actions are tightly coupled\n- You need to track state across operations\n- Your project needs additional structure\n- Your data has natural hierarchies (DNA and Proteins are both Molecules)\n\n_Note: We didn't get into class hierarchies in this tutorial. That's an advanced topic for a later time._\n\nConsider simpler alternatives when:\n\n- Writing straightforward data processing scripts\n- Dealing with mostly static data\n- Using functions that transform data without maintaining state\n- Working with data where built-in Python structures are sufficient\n- Your project is small and classes would add unnecessary complexity\n\nMany popular data science libraries like pandas and seaborn emphasize data transformations and function chaining rather than object-oriented approaches. When using these libraries, follow their patterns instead of forcing objects where they don't make sense.\n\nThe goal is clear, maintainable code that you and colleagues understand. Start simple, adding complexity only when needed. With experience, you'll develop intuition for when classes are the right tool.\n\n### General Tips and Pitfalls\n\nLet's wrap up with some broad best practices and common pitfalls for working with classes. We'll refine these as you tackle more complex programs throughout the course.\n\nGeneral tips:\n\n- Follow naming conventions\n  - PascalCase for classes (`BacterialCell`), snake_case for methods/attributes (`growth_rate`)\n- Keep classes focused\n  - One clear purpose per class\n  - Avoid mixing responsibilities\n- Design intuitive interfaces\n  - Consider how others will interact with your classes\n  - Make correct usage easy, incorrect usage difficult\n- Document with docstrings\n- Validate inputs in `__init__`\n- Implement magic methods when appropriate\n\nGeneral pitfalls:\n\n- Modeling excessive behavior\n  - Include only what's relevant to your specific application\n  - A bird has many attributes, but you only need what serves your research question\n- Overloaded classes\n  - A `Cell` class shouldn't also process sequencing data and generate plots\n- Underutilized classes\n  - Data-only classes might work better as dictionaries\n  - Method-only classes might work better as function modules\n- Poor naming choices\n  - `class Gene` communicates purpose better than `class X`\n\n## Wrap-Up\n\nPython classes create custom data types that bundle related data and functions together, helping organize code by grouping attributes and methods. In scientific programming, they're great for representing complex entities with intertwined data and behavior. Use classes when they make your code more organized and readable -- with experience, you'll develop instincts for when to use them versus simpler approaches. Keep exploring, stay curious, and experiment with different solutions to your scientific problems!\n\n## Suggested Readings\n\nYou might enjoy checking out some of these resources:\n\n- Python Docs: [Classes](https://docs.python.org/3/tutorial/classes.html)\n- Real Python\n  - [Object-Oriented Programming (OOP) in Python](https://realpython.com/python3-object-oriented-programming)\n  - [Python Class Constructors: Control Your Object Instantiation](https://realpython.com/python-class-constructor)\n  - [Class and Instance Attributes](https://realpython.com/lessons/class-and-instance-attributes/)\n  - [Duck Typing in Python: Writing Flexible and Decoupled Code](https://realpython.com/duck-typing-python/)\n- Wikipedia's [Object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}