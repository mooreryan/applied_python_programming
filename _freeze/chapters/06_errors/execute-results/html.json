{
  "hash": "fc23e580dfb894873a50dbd726d93f90",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nauthor: \"Ryan M. Moore, PhD\"\ndate-modified: last-modified\ndate: \"2025-03-11\"\njupyter: python3\n---\n\n\n\n\n# Errors & Exceptions\n\nErrors and unexpected situations happen in nearly all programs, even simple ones. It's important to understand that errors are a normal part of programming, and there are good techniques to help us write code that can handle common errors effectively.\n\nThis chapter explores errors and exceptions and how to manage them in your Python code. We'll begin with basic errors like syntax mistakes (similar to grammar errors in writing) or mathematical issues like dividing by zero. Then we'll progress to more advanced techniques that help your programs handle unexpected situations gracefully.\n\nThroughout this guide, you'll see practical examples that show how to:\n\n- Identify common errors in your code\n- Use try/except blocks to catch and respond to problems\n- Create your own custom exceptions when needed\n- Handle multiple potential issues in a single piece of code\n\nBy the end, you'll feel more confident writing code that can recover from problems rather than crashing when something unexpected happens. This skill is essential for creating robust and reliable programs.\n\n## Syntax Errors\n\nSyntax errors are problems that happen when you write Python code that breaks the language's grammar rules. These errors are very common when you're first learning Python because you're still getting used to how Python code should be structured. Here is an example of a syntax error:\n\n```python\nfor i in range(10)\n    print(i)\n```\n\nIf you run this Python code, you would get an error message like this:\n\n```\nfor i in range(10)\n                  ^\nSyntaxError: expected ':'\n```\n\nAs you can see, I forgot to put the colon (`:`) at the end of the first line. This is a classic syntax mistake in Python, similar to forgetting a period at the end of a sentence.\n\nRemember in previous tutorials and assignments, like when we discussed removing items from dictionaries (@sec-remove-items-dict), scope (@sec-scope), and the \"ask for forgiveness\" approach (@sec-asking-for-forgiveness), we used `try/except` blocks to \"catch\" errors. However, syntax errors cannot be caught using `try/except`. This is because the Python interpreter checks your code's syntax before running any of it. The syntax error is detected during this checking phase, before your program even starts executing, so the `try/except` block never gets a chance to run.\n\n## Understanding Python Exceptions\n\nErrors can still appear in your code even when the syntax is correct. In Python, these runtime errors are called _exceptions_. If an exception happens and you don't address it in your code, your program will crash and stop running.\n\n### Common Exceptions\n\nThere are many different exceptions in Python. Let's start with two simple ones: [`NameError`](https://docs.python.org/3/library/exceptions.html#NameError) and [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError).\n\n#### Name Errors\n\nA `NameError` occurs when Python can't find a name you're trying to use. This typically happens when you try to use a variable or function that doesn't exist or hasn't been defined yet.\n\n```python\nx = 1 + y\n```\n\nIf you ran this code in the Python interpreter or from a program, you would see an error message like this:\n\n```\nNameError             Traceback (most recent call last)\nFile 06_errors.qmd:1\n----> 1 x = 1 + y\n\nNameError: name 'y' is not defined\n```\n\nThis error message shows the type of error, the file where it happened, and a helpful explanation of the problem. We will go into more detail about reading error messages later in this tutorial.\n\n::: {#tip-06-name-error .callout-tip title=\"Stop & Think\" collapse=\"false\"}\nLook at the following code:\n\n```python\ntry:\n    print(gene)\nexcept NameError as error:\n    print(f\"{error=}\")\n```\n\nWhat do you think will happen and why?\n:::\n\n#### Type Errors\n\nA `TypeError` happens when you try to perform an operation on a data type that doesn't support that operation. (It's sort of like trying to use a lab technique on the wrong type of sample.)\n\n```python\n47 + \"102\"\n```\n\nRunning this code produces the following error:\n\n```\nTypeError              Traceback (most recent call last)\nFile 06_errors.qmd:1\n----> 1 47 + \"102\"\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n```\n\nThis message tells you that Python doesn't allow you to add an integer and a string together.\n\n#### Other Common Exceptions\n\nSome other exceptions you might encounter include:\n\n- `IndexError`: When you try to access a position beyond the end of a list or string (like trying to access the 5th nucleotide in a 3-nucleotide codon)\n- `FileNotFoundError`: When Python can't find the file or directory you're trying to access\n- `KeyError`: When you try to access a key that doesn't exist in a dictionary (similar to looking up a gene ID that isn't in your database)\n- `AttributeError`: When you try to access features or properties that don't exist for a particular object\n- `ValueError`: When you provide the right type of value but with incorrect content, such as:\n  - Trying to use a square root transformation on a sample with a negative value (`math.sqrt(-1)`)\n  - Trying to convert `na` expression values (`float(\"na\")`)\n\nFor a complete list of Python exceptions, see the [Built-in Exceptions](https://docs.python.org/3/library/exceptions.html#built-in-exceptions) section of the Python manual.\n\n::: {#tip-06-file-not-exist .callout-tip title=\"Stop & Think\" collapse=\"false\"}\nIf you were writing a program to read and parse FASTA files, which type of error would occur if the file you were trying to read did not exist?\n:::\n\n### Reading Error Messages\n\nOne challenge many beginners face is understanding error messages, both how to interpret them and how to fix the problems they indicate.\n\nAs a new programmer, you'll likely encounter different types of errors than experienced programmers do. You'll often see syntax errors or errors from misusing Python's language features or misunderstanding how functions and classes work. This can be particularly frustrating because these aren't errors you might anticipate. While you might have expected a user-provided file name might not exist, you probably would not have anticipated using a built-in function incorrectly!\n\nLearning to read error messages is an essential skill for your programming journey. In Python, error messages typically contain:\n\n- **Error type**: The kind of error that occurred (e.g., `RuntimeError`)\n- **Traceback**: The sequence of function calls that led to the error\n- **File location**: Where the error occurred (file name and line number)\n- **Arrow pointer**: Points to the specific part of code causing the error\n- **Error message**: A description of what went wrong\n\nLet's examine a few error messages to better understand their structure and meaning. We will start with a simple example:\n\n```python\ndef wibble():\n    raise RuntimeError(\"oh no!!\")\n\n\ndef wobble():\n    wibble()\n\n\ndef woo():\n    wobble()\n\n\nwoo()\n```\n\nIf you ran this code in a Quarto notebook, you would get an error that looks like this:\n\n```\nRuntimeError              Traceback (most recent call last)\nCell In[2], line 13\n      9 def woo():\n     10     wobble()\n---> 13 woo()\n\nCell In[2], line 10, in woo()\n      9 def woo():\n---> 10     wobble()\n\nCell In[2], line 6, in wobble()\n      5 def wobble():\n----> 6     wibble()\n\nCell In[2], line 2, in wibble()\n      1 def wibble():\n----> 2     raise RuntimeError(\"oh no!!\")\n\nRuntimeError: oh no!!\n```\n\nIn this example, the process went like this:\n\n- First, the program called `woo()`\n- Then, inside `woo()`, it called `wobble()`\n- Next, inside `wobble()`, it called `wibble()`\n- Finally, inside `wibble()`, a `RuntimeError` occurred\n\nYou can read the traceback in two ways:\n\nTop-to-bottom (the order the code executed):\n\n1. On line 13, `woo()` is called\n2. On line 10, in `woo`, `wobble()` is called\n3. On line 6, in `wobble`, `wibble()` is called\n4. On line 2, in `wibble`, `raise RuntimeError` is called, which crashes the program\n\nBottom-to-top (starting with the actual error):\n\n1. On line 2, in `wibble`, `raise RuntimeError` is called, which crashes the program\n2. On line 6, in `wobble`, `wibble()` is called\n3. On line 10, in `woo`, `wobble()` is called\n4. On line 13, `woo()` is called\n\nExamining error tracebacks in both directions will often help you better understand what went wrong in your code.\n\nLet's look another example:\n\n```python\ndef parse_line(line):\n    gene, sample, expression = line.strip().split(\",\")\n\n    return (gene, sample, float(expression))\n\n\ndef read_expression_data(filename):\n    with open(filename) as f:\n        for line in f:\n            gene, sample, expression = parse_line(line)\n            print(f\"{gene}-{sample} => {expression}\")\n\n\nread_expression_data(\"expression_data.csv\")\n```\n\nPretend there is a file called `expression_data.csv` that has the following contents:\n\n```\ngene1,sample1,25\ngene1,sample2,50\ngene2,sample1,na\ngene2,sample2,15\n```\n\nLet's assume that you have saved that code in a script called `example.py`. When you run it you would see output that looks something like this:\n\n```\ngene1-sample1 => 25.0\ngene1-sample2 => 50.0\nTraceback (most recent call last):\n  File \"example.py\", line 14, in <module>\n    read_expression_data(\"expression_data.csv\")\n    ~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"example.py\", line 10, in read_expression_data\n    gene, sample, expression = parse_line(line)\n                               ~~~~~~~~~~^^^^^^\n  File \"example.py\", line 4, in parse_line\n    return (gene, sample, float(expression))\n                          ~~~~~^^^^^^^^^^^^\nValueError: could not convert string to float: 'na'\n```\n\nLet's break it down:\n\nThe script processes gene expression data from a CSV file. It runs smoothly for the first two lines of the file, but crashes when it encounters `\"na\"` in the third line. The error happens because Python's `float()` function cannot convert the text `\"na\"` (which stands for \"not available\" in biological data) into a floating-point number.\n\nThe error message shows us the exact path of execution that led to the problem. It starts at line 14 where we call `read_expression_data()`, then moves to line 10 where we call `parse_line()`, and finally reaches line 4 where the actual error occurs when trying to convert `\"na\"` to a float.\n\nThis is a common issue when working with biological datasets, which often contain missing values represented as \"na\", \"N/A\", or similar placeholders. To fix this problem, we would need to add error handling when running the `float` function, or use some other technique to check for these special values before attempting the conversion.\n\n::: {#tip-06-handle-na .callout-tip title=\"Stop & Think\" collapse=\"false\"}\nIn the above example, can you think of a better way to handle the `na` value rather than letting the program crash?\n:::\n\n## Basic Exception Handling\n\nNow that we've discussed what exceptions are, let's explore how we can recover from them and prevent unexpected errors from crashing our programs.\n\nThe basic format uses `try:` followed by an indented block of code, then `except SomeError:`, followed by another indented block of code:\n\n::: {#5435557d .cell execution_count=1}\n``` {.python .cell-code}\ntry:\n    47 + \"102\"\nexcept TypeError as error:\n    print(f\"an type error occurred: {error=}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nan type error occurred: error=TypeError(\"unsupported operand type(s) for +: 'int' and 'str'\")\n```\n:::\n:::\n\n\nLet's break this down:\n\n- The \"try clause\" contains the code that might cause an error.\n  - It is placed between the [`try`](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement) and [`except`](https://docs.python.org/3/reference/compound_stmts.html#except-clause) keywords.\n  - Here, our try clause has just one expression: `47 + \"102\"`\n- The \"except clause\" contains the code that runs if an error occurs.\n  - It is placed after the `except` keyword and continues until the indentation ends.\n- `except TypeError as error:`\n  - `TypeError` specifies which kind of error we want to catch\n  - If a `TypeError` happens, Python saves the error information in the variable named `error` so we can use it\n- `print(f\"a TypeError occurred: {error}\")` is the code that runs when a `TypeError` occurs in the try clause\n\nThe try/except statement is a bit like a safety net for your code: you're trying something that might fail (the `try` clause), but you've prepared a backup plan (the `except` clause) just in case.\n\nNext, let's see how Python runs through this type of code.\n\n### Try/Except Code Flow\n\nPython follows a specific process when it encounters a try/except block. First, it attempts to run all the code inside the \"try clause.\" If this code runs without any problems, Python simply skips the except clause and continues with the rest of your program.\n\nHowever, if an error occurs while running the try clause, Python immediately stops executing that section. It then checks if the error type matches what you specified after the `except` keyword. For instance, if you wrote `except TypeError:`, Python looks specifically for `TypeErrors`.\n\nIf the error matches what you specified, Python runs the code in the except clause and then continues with the rest of your program.\n\nIf the error doesn't match what you specified, Python considers it an \"unhandled exception\". In this case, your program will stop running and display an error message.\n\nThis might sound a bit abstract, so let's go through some examples to see how it works step by step.\n\n#### No Exception in the Try Clause\n\nIn this example, no exception occurs in the try clause.\n\n::: {#18cd2868 .cell execution_count=2}\n``` {.python .cell-code}\ntry:\n    print(\"hi\")\nexcept TypeError as error:\n    print(f\"an error occurred: {error=}\")\n\nprint(\"yo!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhi\nyo!\n```\n:::\n:::\n\n\n1. Python runs the contents of the try clause: `print(\"hi\")`\n2. `print(\"hi\")` runs without error and displays \"hi\" on the screen\n3. Since no error occurred, Python skips the `except` clause completely\n4. Python continues to the next line and runs `print(\"yo!\")`\n\n#### Exception in the Try Clause\n\nIn this example, an error occurs that matches the one in our `except` clause:\n\n::: {#de0135c8 .cell execution_count=3}\n``` {.python .cell-code}\ntry:\n    print(greeting)\nexcept NameError as error:\n    print(f\"an error occurred: {error=}\")\n\nprint(\"yo!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nan error occurred: error=NameError(\"name 'greeting' is not defined\")\nyo!\n```\n:::\n:::\n\n\n1. Python runs the contents of the try clause: `print(greeting)`\n2. `print(greeting)` causes a `NameError` because `greeting` hasn't been defined (you must define variables before using them)\n3. Since a `NameError` occurred and we specifically included `NameError` in our except statement, Python executes the except block: `print(f\"an error occurred: {error=}\")`\n4. After completing the try/except block, Python continues to the next line and runs `print(\"yo!\")`\n\n#### Non-Matching Exception in the Try Clause\n\nThis example shows what happens when the error that occurs is different from the one we're trying to catch:\n\n```python\ntry:\n    47 + \"102\"\nexcept NameError as error:\n    print(f\"an error occurred: {error=}\")\n\nprint(\"yo!\")\n```\n\n1. Python runs the contents of the try clause: `47 + \"102\"`\n2. `47 + \"102\"` causes a `TypeError` because Python can't add a number to text\n3. Python checks if `TypeError` matches what we're catching in our except statement, but we're only catching `NameError`\n4. Since the error types don't match and there are no other try statements, the error remains uncaught\n5. The program crashes with an error message and stops running\n6. `print(\"yo!\")` never runs because the program already crashed\n\n### Catching Multiple Exceptions\n\nYou can catch different types of exceptions within a single `try/except` block by adding multiple except clauses. When an error occurs in the try block, Python looks for a matching except block to handle that specific error type. Once it finds a match, it runs that code and then continues with the rest of your program. If no match is found, then the program crashes.\n\nFor example, if your code causes a `NameError` (like using a variable that doesn't exist), only the except clause that handles `NameError` will run. The other except clauses, like one for `TypeError`, will be skipped:\n\n::: {#e4d7392a .cell execution_count=4}\n``` {.python .cell-code}\ntry:\n    print(greeting)\nexcept NameError as name_error:\n    print(f\"a NameError occurred: {name_error=}\")\nexcept TypeError as type_error:\n    print(f\"a TypeError occurred: {type_error=}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na NameError occurred: name_error=NameError(\"name 'greeting' is not defined\")\n```\n:::\n:::\n\n\nIn this case, it is the opposite -- the code in the try clause causes a `TypeError`, causing only the expect clause handling type errors to run:\n\n::: {#420eb89e .cell execution_count=5}\n``` {.python .cell-code}\ntry:\n    47 + \"102\"\nexcept NameError as name_error:\n    print(f\"a NameError occurred: {name_error}\")\nexcept TypeError as type_error:\n    print(f\"a TypeError occurred: {type_error}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na TypeError occurred: unsupported operand type(s) for +: 'int' and 'str'\n```\n:::\n:::\n\n\nSometimes you might want to handle different errors in the same way. In these cases, you can group multiple exceptions in a single `except` clause:\n\n::: {#ffcb6904 .cell execution_count=6}\n``` {.python .cell-code}\ntry:\n    print(greeting)\nexcept (NameError, TypeError) as error:\n    print(f\"an error occurred: {error=}\")\n\ntry:\n    47 + \"102\"\nexcept (NameError, TypeError) as error:\n    print(f\"an error occurred: {error=}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nan error occurred: error=NameError(\"name 'greeting' is not defined\")\nan error occurred: error=TypeError(\"unsupported operand type(s) for +: 'int' and 'str'\")\n```\n:::\n:::\n\n\n### Clauses Can Contain Multiple Statements\n\nEach section (clause) in a try/except block can include multiple lines of code:\n\n::: {#99bdb75e .cell execution_count=7}\n``` {.python .cell-code}\ntry:\n    # This line will run successfully\n    print(1 + 2)\n\n    # This line will cause a TypeError (mixing number and text)\n    print(10 + \"20\")\n\n    # This line will never execute because the error above stops the try block\n    print(100 + 200)\nexcept TypeError as error:\n    # This line runs because we caught a TypeError from above\n    print(f\"an error occurred: {error=}\")\n\n    # This line also runs since all code in the except clause executes\n    # (unless another error happens)\n    print(\"this will also run!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\nan error occurred: error=TypeError(\"unsupported operand type(s) for +: 'int' and 'str'\")\nthis will also run!\n```\n:::\n:::\n\n\n_Note: We'll discuss this more later, but it's generally best practice to keep the code in each clause short and simple, with as few statements as possible._\n\n### Exceptions Can Happen in the Except Block\n\nOne important thing to remember is that exceptions can also occur in your `except` block code:\n\n```python\ntry:\n    # This line will run\n    print(1 + 2)\n\n    # This line will raise the TypeError\n    print(10 + \"20\")\n\n    # This line will not run because the previous line caused a TypeError\n    print(100 + 200)\nexcept TypeError as error:\n    # This line will run because a TypeError occurred in the above clause\n    print(f\"an occurred: {error=}\")\n\n    # This line will raise a NameError since the name `twenty` has not been\n    # defined\n    print(10 + twenty)\n\n    # This line will not run because the above line raises another exception!\n    print(\"this will also run!\")\n```\n\nIf you ran this code, you would see output like this:\n\n```\nTypeError                                 Traceback (most recent call last)\nCell In[1], line 6\n      5 # This line will raise the TypeError\n----> 6 print(10 + \"20\")\n      8 # This line will not run because the previous line caused a TypeError\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\nDuring handling of the above exception, another exception occurred:\n\nNameError                                 Traceback (most recent call last)\nCell In[1], line 16\n     12 print(f\"an occurred: {error=}\")\n     14 # This line will raise a NameError since the name `twenty` has not been\n     15 # defined\n---> 16 print(10 + twenty)\n     18 # This line will not run because the above line raises another exception!\n     19 print(\"this will also run!\")\n\nNameError: name 'twenty' is not defined\n```\n\nNotice the key message: \"During handling of the above exception, another exception occurred\". This tells us what happened. While the program was trying to recover from one error, it encountered a second error. Since there was no error handler set up for this second error, the program crashed.\n\nFor more information about this concept, check out the Python documentation on [exception chaining](https://docs.python.org/3/tutorial/errors.html#exception-chaining).\n\n::: {#tip-06-exception-chaining .callout-tip title=\"Stop & Think\" collapse=\"false\"}\nIf you're developing a program to analyze biological sequencing data, can you think of a reason why allowing exceptions to occur within an `except` block might lead to tricky issues in your code?\n:::\n\n## Advanced Exception Handling\n\nLet's explore some more advanced ways to handle exceptions in Python. While you might not need to use these techniques in your current assignments and miniprojects, it's still valuable to understand them. You'll encounter these patterns when reading other people's code or working with existing Python libraries and tools.\n\n### Exception Hierarchies\n\nPython exceptions form a hierarchy, and are organized a bit like a family tree. Here's a simplified view of this hierarchy:\n\n```\nBaseException\n └── Exception\n      ├── ArithmeticError\n      │    ├── FloatingPointError\n      │    ├── OverflowError\n      │    └── ZeroDivisionError\n      ├── RuntimeError\n      │    ├── NotImplementedError\n      │    ├── PythonFinalizationError\n      │    └── RecursionError\n```\n\nTo understand this relationship:\n\n- A `ZeroDivisionError` is a type of `ArithmeticError`\n- An `ArithmeticError` is a type of `Exception`\n- An `Exception` is a type of `BaseException`\n\nThis is similar to how taxonomic relationships work. Just as a cat is a feline, all felines are mammals, and all mammals are animals, a `ZeroDivisionError` is an `ArithmeticError`, all `ArithmeticErrors` are `Exceptions`, and all `Exceptions` are `BaseExceptions`.\n\nNote that a `ZeroDivisionError` is an `ArithmeticError`, but it is not a `RuntimeError` -- similar to how cats and dogs are both mammals, but a cat is not a canine.\n\nThe complete [exception hierarchy](https://docs.python.org/3/library/exceptions.html#exception-hierarchy) is is available in the Python documentation.\n\nThe benefit of this hierarchy is that we can catch a whole group of related errors without listing each one individually. Here's a simple example with a function that performs basic math operations:\n\n::: {#e088e02e .cell execution_count=8}\n``` {.python .cell-code}\nimport math\n\ndef silly_math(x, y):\n    math.exp(x) / y\n```\n:::\n\n\nThis function can raise several different errors:\n\n- If `y` is `0`, we get a `ZeroDivisionError`\n- If `x` is too large, we get an `OverflowError`\n- If `x` or `y` aren't numbers, we get a `TypeError`\n\nImagine we're reading the values of `x` and `y` from a data file, so we don't know what they'll be until the program runs. We can handle potential errors like this:\n\n::: {#4a83c4af .cell execution_count=9}\n``` {.python .cell-code}\n# ZeroDivisionError\ntry:\n    x = 1\n    y = 0\n    silly_math(x, y)\nexcept (ZeroDivisionError, OverflowError) as error:\n    print(f\"there was an arithmetic error! {error=}\")\nexcept TypeError as error:\n    print(f\"one of the values wasn't numeric! {error=}\")\n\n\n# OverflowError\ntry:\n    x = 1000\n    y = 2\n    silly_math(x, y)\nexcept (ZeroDivisionError, OverflowError) as error:\n    print(f\"there was an arithmetic error! {error=}\")\nexcept TypeError as error:\n    print(f\"one of the values wasn't numeric! {error=}\")\n\n\n# TypeError\ntry:\n    x = 1\n    y = \"2\"\n    silly_math(x, y)\nexcept (ZeroDivisionError, OverflowError) as error:\n    print(f\"there was an arithmetic error! {error=}\")\nexcept TypeError as error:\n    print(f\"one of the values wasn't numeric! {error=}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthere was an arithmetic error! error=ZeroDivisionError('float division by zero')\nthere was an arithmetic error! error=OverflowError('math range error')\none of the values wasn't numeric! error=TypeError(\"unsupported operand type(s) for /: 'float' and 'str'\")\n```\n:::\n:::\n\n\nThis works, but we can simplify by using the parent class `ArithmeticError` instead:\n\n::: {#58d0346a .cell execution_count=10}\n``` {.python .cell-code}\n# ZeroDivisionError\ntry:\n    x = 1\n    y = 0\n    silly_math(x, y)\nexcept ArithmeticError as error:\n    print(f\"there was an arithmetic error! {error=}\")\nexcept TypeError as error:\n    print(f\"one of the values wasn't numeric! {error=}\")\n\n\n# OverflowError\ntry:\n    x = 1000\n    y = 2\n    silly_math(x, y)\nexcept ArithmeticError as error:\n    print(f\"there was an arithmetic error! {error=}\")\nexcept TypeError as error:\n    print(f\"one of the values wasn't numeric! {error=}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthere was an arithmetic error! error=ZeroDivisionError('float division by zero')\nthere was an arithmetic error! error=OverflowError('math range error')\n```\n:::\n:::\n\n\nBoth `ZeroDivisionError` and `OverflowError` are caught by the `ArithmeticError` handler because they are both types of `ArithmeticError`.\n\nHowever, it's important to understand that this doesn't work in reverse. Let's see what happens if we try to catch an `ArithmeticError` with a `ZeroDivisionError` handler:\n\n```python\ntry:\n    # This code cause a specific error, in this case an ArithmeticError,\n    # to happen\n    raise ArithmeticError(\"oops!\")\nexcept ZeroDivisionError:\n    print(\"this won't catch the ArithmeticError\")\n```\n\nHere is the error message:\n\n```\nArithmeticError                  Traceback (most recent call last)\nCell In[1], line 2\n      1 try:\n----> 2     raise ArithmeticError(\"oops!\")\n      3 except ZeroDivisionError:\n      4     print(\"this won't catch the ArithmeticError\")\n\nArithmeticError: oops!\n```\n\nThis is because while every `ZeroDivisionError` is an `ArithmeticError`, every `ArithmeticError` is _not_ a `ZeroDivisionError`.\n\n_Note: check out the [raise](https://docs.python.org/3/reference/simple_stmts.html#raise) statement for more about manually raising exceptions._\n\nYou may have noticed that this connects back to the Object-Oriented Programming concepts we discussed in @sec-four-pillars-oop. This error class hierarchy shows inheritance at work: exception classes inherit from their parent exception classes. When we catch an `ArithmeticError`, we're using this inheritance relationship to handle any type of exception that belongs to that family. This is a practical example of why inheritance is useful in programming.\n\n::: {#tip-06-file-read-errors .callout-tip title=\"Stop & Think\" collapse=\"false\"}\nConsider a function that reads a FASTA file. What exception types might you want to catch, and which parent exception class could catch all of them?\n:::\n\n### Nesting Try/Except Blocks\n\nIt can sometimes be useful to nest try/except blocks. This is like having backup plans for your backup plans!\n\nThe first example shows how Python searches for an appropriate error handler. If an inner error handler doesn't match the exception type, Python will check outer handlers:\n\n::: {#3e7ce831 .cell execution_count=11}\n``` {.python .cell-code}\ntry:\n    try:\n        raise TypeError(\"oh no!\")\n    except NameError:\n        print(\"this won't print because it's trying to catch a NameError\")\nexcept TypeError:\n    print(\"caught a TypeError\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncaught a TypeError\n```\n:::\n:::\n\n\nIn this case, the inner handler is looking for a `NameError`, but we raised a `TypeError`. Since the inner handler can't catch it, Python checks the outer handler, which successfully catches the `TypeError`.\n\nOur second example is different. Here, the inner handler does catch the `TypeError`, but then it raises a new `NameError`:\n\n::: {#44da4c03 .cell execution_count=12}\n``` {.python .cell-code}\ntry:\n    try:\n        raise TypeError(\"oh no!\")\n    except TypeError:\n        print(\"we caught a TypeError\")\n\n        raise NameError(\"here is a name error\")\n\n        print(\"this will not print!\")\nexcept NameError:\n    print(\"caught a NameError\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nwe caught a TypeError\ncaught a NameError\n```\n:::\n:::\n\n\nThe inner handler catches the `TypeError` but then creates a new problem by raising a `NameError`. Fortunately, the outer handler catches this new error, preventing our program from crashing.\n\n### Using `else` and `finally`\n\nWhen working with `try/except` blocks, we can add two special clauses that give us more control over our code: `else` and `finally`.\n\nThe `else` clause lets us run code only if no errors occurred in the `try` block. As in, \"try this code, and if it works without errors, do this extra step.\"\n\nThe `finally` clause runs its code regardless of whether an error happened or not. It's like saying \"no matter what happens, always do this cleanup step.\" This is a good choice for tasks that need to happen even if errors occur like closing files or database connections.\n\nThe `else` clause is useful for several reasons:\n\n- It keeps your error handling code separate from your normal processing code\n- It ensures certain operations only happen when everything works correctly\n- It prevents catching unrelated errors that might occur in your processing code\n\nWhile the `else` clause isn't very common in Python code, it serves specific purposes. One important use is running additional code before any finalization steps without including it in the `try` block itself. Without using `else`, you'd have to put this code in the `try` block, which means unintended errors might get caught and handled incorrectly.\n\nUnlike `finally` (which always runs), the `else` clause only runs when the `try` block succeeds completely. This makes it useful for operations that should only happen when everything works as expected.\n\nHere's a simple example showing how `else` can make your code cleaner:\n\n::: {#a8bae9eb .cell execution_count=13}\n``` {.python .cell-code}\ndef example(): ...\ndef handle_failure(error): ...\ndef handle_success(result): ...\n\ntry:\n    result = example()\n    # Make a boolean flag that says we were successful\n    success = True\nexcept MagicError as error:\n    handle_failure(error)\n\n# We only want to run this on success, so it must be behind a flag\nif success:\n    handle_success(result)\n\n\n# With else -- cleaner approach\ntry:\n    result = example()\nexcept MagicError as error:\n    handle_failure(error)\nelse:\n    handle_success(result)\n```\n:::\n\n\nLet's try an example that uses all of the clauses: `try`, `except`, `else`, and `finally`. This simple example shows how to handle different situations when searching a protein database. The different parts handle specific situations:\n\n::: {#03c8650b .cell execution_count=14}\n``` {.python .cell-code}\ndef find_protein(protein_database, entry):\n    try:\n        # Try to find the protein in the database.\n        info = protein_database[entry]\n    except KeyError:\n        # If it is not found, log an error.\n        print(f\"Entry '{entry}' not found in the database\")\n    else:\n        # If it is found, return the info\n        return info\n    finally:\n        # Regardless of success or failure, log a message saying you checked for the entry.\n        print(f\"Search completed for entry {entry}\")\n\n\n# Example usage\nprotein_database = {\n    \"P00452\": {\n        \"gene\": \"nrdA\",\n        \"protein\": \"Ribonucleoside-diphosphate reductase 1 subunit alpha\",\n    },\n    \"P00582\": {\"gene\": \"polA\", \"protein\": \"DNA polymerase I\"},\n}\n\nentries = [\"P00582\", \"P19822\", \"P00452\"]\nfor entry in entries:\n    # If the entry is found, return the info, if not, it will return None\n    info = find_protein(protein_database, entry)\n\n    # Since this might be none, we have to check that it exists before working\n    # with it.\n    if info:\n        print(info[\"gene\"], info[\"protein\"], sep=\" -> \")\n\n    print()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSearch completed for entry P00582\npolA -> DNA polymerase I\n\nEntry 'P19822' not found in the database\nSearch completed for entry P19822\n\nSearch completed for entry P00452\nnrdA -> Ribonucleoside-diphosphate reductase 1 subunit alpha\n\n```\n:::\n:::\n\n\nHere is a flowchart to help you visualize how the logic flows through the try/except/else/finally code structure.\n\n![try/except/else/finally flowchart](/images/try_except_flowchart_light.svg \"try/except/else/finally flowchart\"){fig-alt=\"try/except/else/finally flowchart\"}\n\n::: {#tip-06-finally-clause .callout-tip title=\"Stop & Think\" collapse=\"false\"}\nCan you think of any scenarios in which the `finally` clause would be useful when working with biological data or analysis?\n:::\n\n### Combining Techniques\n\nLet's take a look at an example that combines a few of the techniques we have talked about so far. Here we're trying to read a file, convert each line to an integer, and store those integers in a list. Our code is structured with a `try` clause followed by several `except` clauses to handle different types of errors:\n\n::: {#aca1b768 .cell execution_count=15}\n``` {.python .cell-code}\ndef read_integers(file_name):\n    \"\"\"Read a file and convert each line to an integer.\"\"\"\n    with open(file_name) as file:\n        return [int(line.strip()) for line in file]\n\n\ntry:\n    read_integers(\"the_best_numbers.txt\")\n# Dealing with files can cause errors in the OSError family\nexcept OSError as error:\n    print(f\"an error reading the file occurred: {error=}\")\n# Trying to a convert a string to an integer can fail too\nexcept ValueError as error:\n    print(f\"could not convert line to an integer: {error=}\")\n# This is a \"catch-all\" clause, since we want to log any unexpected errors\nexcept Exception as error:\n    print(f\"Unexpected error: {error=}\")\n    # Since it's not good practice to handle errors we are not expecting,\n    # we reraise the error and then the caller of this code can handle it\n    # how they want.\n    raise\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nan error reading the file occurred: error=FileNotFoundError(2, 'No such file or directory')\n```\n:::\n:::\n\n\nThe first `except` clause catches any `OSError`. These errors happen when something goes wrong with the file system, like if `\"the_best_numbers.txt\"` doesn't exist. The `OSError` family includes specific errors like `FileNotFoundError` (when the file doesn't exist), `PermissionError` (when you don't have permission to read the file), and other file-related problems.\n\nThe second `except` clause catches `ValueError`. This happens if the `int()` function can't convert a line to an integer. For instance, if a line contains \"ABC\" instead of a number like \"123\", a `ValueError` will occur.\n\nThe last `except` clause catches any other type of `Exception`. This acts as a safety net for unexpected errors. When an unexpected error occurs, we:\n\n1. Print information about the error\n2. Re-raise the error using the `raise` statement\n\nRe-raising an error means that after we handle it partially (in this case, by printing information), we pass the error up to whatever code called our function. This is useful when you want to log an error but still want the calling code to to have to deal with it because there is no way to recover at the location which the error happened (i.e., you might not have enough context to do anything about it right then and there).\n\n## Creating Custom Exceptions\n\nPython packages and libraries often create their own custom error types. For example:\n\n- Biopython defines a [`TreeError`](https://biopython.org/docs/1.75/api/Bio.Nexus.Trees.html#Bio.Nexus.Trees.TreeError) class to alert users when something goes wrong with phylogenetic trees.\n- Pandas defines a [`MergeError`](https://pandas.pydata.org/docs/reference/api/pandas.errors.MergeError.html#pandas-errors-mergeerror) for problems that occur when trying to merge data frames.\n\nThese custom errors make it easier for users to handle problems specific to that library. Users can then distinguish between errors from the library and errors from their own code.\n\nLet's look at an example. First, we'll write code without a custom error, then improve it by adding one.\n\n::: {#1d2a554f .cell execution_count=16}\n``` {.python .cell-code}\ndef parse_dna_string(dna_string):\n    \"\"\"Parse a DNA string, validating the nucleotides.\"\"\"\n    valid_bases = {\"A\", \"C\", \"G\", \"T\", \"N\"}\n\n    for i, base in enumerate(dna_string):\n        if base not in valid_bases:\n            raise ValueError(f\"Invalid DNA base at index {i}: '{base}'\")\n\n    return dna_string\n\n\nprint(parse_dna_string(\"ACTG\"))\n\ntry:\n    print(parse_dna_string(\"ACXG\"))\nexcept ValueError as error:\n    print(f\"{error=}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nACTG\nerror=ValueError(\"Invalid DNA base at index 2: 'X'\")\n```\n:::\n:::\n\n\nThis works fine, but imagine you're writing a library with many classes for different aspects of sequence analysis and file parsing. Error handling could become confusing. Creating custom errors helps users understand and handle problems more clearly.\n\nA common approach is to define a base error class for your package, and then create specific error types that inherit from it. For example, if our package is called `EasyBio`, we might do this:\n\n::: {#e57e9927 .cell execution_count=17}\n``` {.python .cell-code}\nclass EasyBioError(Exception):\n    \"\"\"Base class for all EasyBio package errors.\"\"\"\n    pass\n\nclass InvalidBaseError(EasyBioError):\n    \"\"\"Error raised when a DNA sequence contains invalid characters\"\"\"\n    pass\n\n# We could define more specific errors for other situations too\n\ndef parse_dna_string(dna_string):\n    valid_bases = {\"A\", \"C\", \"G\", \"T\", \"N\"}\n\n    for i, base in enumerate(dna_string):\n        if base not in valid_bases:\n            raise InvalidBaseError(f\"Invalid DNA base at index {i}: '{base}'\")\n\n    return dna_string\n\n\nprint(parse_dna_string(\"ACTG\"))\n\ntry:\n    print(parse_dna_string(\"ACXG\"))\nexcept InvalidBaseError as error:\n    print(f\"{error=}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nACTG\nerror=InvalidBaseError(\"Invalid DNA base at index 2: 'X'\")\n```\n:::\n:::\n\n\nThis code is more descriptive about what went wrong - specifically that we found an invalid nucleotide. The benefits of this approach become clearer in larger packages with many different types of potential errors.\n\nBenefits of using custom exceptions include:\n\n- **Clear hierarchy**: Users can catch just the base exception (`EasyBioError`) to handle any error from your library, or catch specific exceptions for targeted handling.\n- **Improved error messaging**: Custom exceptions can include field-specific information that helps users understand what went wrong in their context.\n- **Documentation**: Custom exceptions serve as self-documenting code, showing users what can go wrong.\n\nUsers of your code will often expect to see custom error types that are specific to your package or library. This approach lets you control which errors users need to handle and gives them clear information about what went wrong.\n\n::: {#tip-06-custom-exceptions .callout-tip title=\"Stop & Think\" collapse=\"false\"}\nIf you were creating a package for RNA-seq analysis, what custom exception types might be useful to define?\n:::\n\n## General Tips\n\nNow that we've explored errors and exceptions, let's go through some general tips about how to deal with them.\n\n### Use Descriptive Error Messages\n\nIt's important to include helpful details when raising errors. This makes your code more robust and provides valuable context to anyone using your functions.\n\nBe specific and descriptive:\n\n```python\n# Too vague\nraise ValueError(\"Invalid input\")\n\n# More descriptive\nraise ValueError(\"Expected DNA sequence but found invalid characters\")\n\n# Shows the specific problems with the sequence\nraise ValueError(f\"Expected DNA sequence but found invalid characters at positions {invalid_positions}\")\n```\n\nInclude relevant values:\n\n```python\nif start >= end:\n    raise ValueError(f\"Start position ({start}) must be less than end position ({end})\")\n```\n\nSuggest solutions when possible:\n\n```python\nif not os.path.exists(filepath):\n    raise FileNotFoundError(f\"File '{filepath}' not found. Check spelling or use absolute path.\")\n\n# Not as good:\nraise ConnectionError(\"connection failed\")\n\n# Better\nraise ConnectionError(\"Database connection failed: check that server is running on port 5432\")\n```\n\nDocument the exceptions your functions can raise:\n\n```python\ndef parse_fasta(filename):\n    \"\"\"\n    Parse a FASTA file and return sequences.\n\n    Args:\n        filename: Path to the FASTA file\n\n    Returns:\n        List of (header, sequence) tuples\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        ValueError: If the file is not in valid FASTA format\n    \"\"\"\n    pass\n```\n\nThese suggestions will make debugging easier for both you and anyone using your code.\n\n### When to Catch Exceptions\n\nLet's talk about you should catch exceptions and when it's better to let them bubble up through your program.\n\nYou should catch exceptions when:\n\n- You can recover meaningfully\n  - You can provide a default value if an error occurs (for example, when calculating fold change and dividing by zero, just return one)\n  - You can safely skip problematic data (for example, when processing multiple sequences from a FASTA file and one is corrupted, just skip that sequence)\n- You need to clean up resources (for example, close a database connection if a query fails)\n- You want to translate an error into a different, more appropriate error type\n\nYou should _not_ catch exceptions when:\n\n- There is no reasonable way to recover from the error\n  - If you have no recovery strategy, let the exception move up to a level that can handle it\n  - For example:\n    - When a user provides a file name that doesn't exist\n    - When a database connection fails\n- There is a cleaner alternative (for example, using `dict.get` to provide a default value instead of catching a KeyError)\n\n![Decision Tree for Catching Exceptions](/images/error_catching_decision_light.svg \"Decision Tree for Catching Exceptions\"){fig-alt=\"Decision Tree for Catching Exceptions\"}\n\n### Other tips\n\n- When you decide to catch an exception, catch it as specifically as possible\n  - Prefer catching specific exceptions like `ValueError` or `FileNotFoundError` rather than broad ones like `Exception`\n  - This prevents accidentally hiding bugs by catching exceptions you weren't expecting\n- Don't silently ignore exceptions\n  - At minimum, you should at least log a message to let users know something went wrong\n\n### Example\n\nHere is a tiny example that breaks pretty much all the suggestions that we have given:\n\n::: {#5fa3624a .cell execution_count=18}\n``` {.python .cell-code}\ndef example(x, y, z):\n    try:\n        return potentially_risky_function(x, y, z)\n    except Exception:\n        pass\n```\n:::\n\n\nThis is better though!\n\n```python\ndef example(x, y, z):\n    try:\n        return potentially_risky_function(x, y, z)\n    except ValueError as e:\n        print(f\"WARNING -- Invalid value encountered: {e}\")\n        return default_value\n    except IOError as e:\n        print(f\"ERROR -- IO error: {e}\")\n        # Re-raise errors we can't handle\n        raise\n```\n\n## Summary\n\nIn this tutorial, we covered Python exceptions and how to handle them.\n\n- **Syntax errors** happen when your code breaks Python's grammar rules. These must be fixed before your code can run.\n- **Exceptions** occur during program execution when something unexpected happens, like trying to divide by zero.\n- **try/except blocks** let you catch exceptions and handle them smoothly, similar to how you might have contingency plans in an experiment.\n- The **exception hierarchy** allows you to catch specific error types (like `FileNotFoundError`) or broader categories of errors (like `OSError`).\n- **else** and **finally** clauses give you extra control in error handling, letting you run code when no errors occur or ensure cleanup happens regardless.\n- **Custom exceptions** help you write more readable and maintainable code by creating error types specific to your program.\n\nError handling is a crucial skill for building robust programs that can recover gracefully when things go wrong. Practice identifying where your code might fail (like when reading files or processing data) and implement appropriate exception handling to build more reliable applications for your research.\n\n## Suggested Readings\n\nYou might enjoy checking out some of these resources:\n\n- Python docs tutorial about [errors and exceptions](https://docs.python.org/3/tutorial/errors.html)\n- Real Python's [introduction to exceptions](Python Exceptions: An Introduction)\n- Real Python's discussion of [built-in exceptions](https://realpython.com/python-built-in-exceptions/)\n- StackOverflow post about the [`else` block](https://stackoverflow.com/a/16138864)\n- StackOverflow post about [raising exceptions](https://stackoverflow.com/a/24065533)\n\n\n## Practice Problems\n\n### 6.1 {#sec-problem-6.1}\n\nWrite a `try/except` block that attempts to convert a string to a float, but catches the `ValueError` if the string isn't a valid number. When an error occurs, it should print \"Not a valid number\".\n\n### 6.2 {#sec-problem-6.2}\n\nModify this code to catch the potential error:\n\n```python\ncounts = {\"A\": 1, \"C\": 2, \"G\": 0, \"T\": 4}\ntotal = sum(counts.values())\nn_ratio = counts[\"N\"] / total \n```\n\n### 6.3 {#sec-problem-6.3}\n\nHere is a tiny, misbehaving Python function:\n\n```python\nimport random\n\ndef silly_divide(x, y):\n    if random.random() < 0.25:\n        raise Exception(\"oops!\")\n\n    return x / y\n```\n\nAbout 75% of the time, it divides two numbers. However, the other 25% of the time, it raises an `Exception`.\n\nWrite code that runs this function inside a `try/except` block.  It should have two `except` clauses, one to catch the `ZeroDivisionError` and one to catch the potential `Exception`.  You should give the user info about the error that was caught.\n\n### 6.4 {#sec-problem-6.4}\n\nWrite a function called `fold_change` that takes two expression values and calculates their fold change.  Make sure to handle any potential errors that could occur.  If there is an error, the function should return `None`.\n\n### 6.5 {#sec-problem-6.5}\n\nCreate a custom exception called `SequenceLengthError` that inherits from `Exception`.  Then use it in a function called `validate_sequence_length` that raises a `SequenceLengthError` if the given sequence length is not between 50 and 150 bases.\n\n### 6.6 {#sec-problem-6.6}\n\nConsider the following code:\n\n```python\ndef run_simulation(max_turns):\n    if max_turns < 1:\n        raise ValueError(\"bad input\")\n    \n    if max_turns > 1000:\n        raise ValueError(\"bad input\")\n    \n    # Simulation code would follow\n    pass\n```\n\nRewrite this function so that it provides the uses with better error messages.\n\n",
    "supporting": [
      "06_errors_files"
    ],
    "filters": [],
    "includes": {}
  }
}