{
  "hash": "fafe1cb6488b2633be3247fa4acab314",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nauthor: \"Ryan M. Moore, PhD\"\ndate-modified: last-modified\ndate: \"2025-02-18\"\njupyter: python3\n---\n\n\n\n\n# Algorithmic Thinking\n\n## Overview\n\nAn algorithm is a step-by-step procedure for solving a problem or accomplishing a task. It as a detailed set of instructions that takes some input, follows a clear sequence of steps, and produces a desired output.\n\nAlgorithms can vary greatly in their level of complexity, from simple operations like finding the larger of two numbers to complex tasks such as generating a phylogenetic tree from a sequence alignment. It's worth noting that the same problem might have multiple algorithmic solutions, each with its own advantages and trade-offs in terms of simplicity and efficiency.\n\n### Key Characteristics of Algorithms\n\n_(Adapted from The Art of Computer Programming by Donald E. Knuth)_\n\nAll algorithms share some important properties:\n\n- Defined inputs & outputs\n  - Algorithms must have clearly defined inputs and outputs.\n  - Example: PCR protocol\n    - Input: Template DNA, primers, nucleotides, polymerase\n    - Output: Amplified DNA fragments\n- Definiteness\n  - Steps must be clear and unambiguous\n  - Each step must be understood exactly the same way by anyone following it\n  - Examples:\n    - Good example: \"Heat the sample at 95°C for 5 minutes\"\n    - Bad example: \"Heat the sample for a while\"\n- Finiteness\n  - The algorithm must terminate after a finite number of steps\n  - I.e., it cannot run indefinitely\n  - Examples:\n    - Good example: A PCR reaction has a specific number of cycles\n    - Bad example: \"Keep checking gel until bands appear\" (no clear end point)\n- Effectiveness\n  - Each step must be basic enough to be executed\n  - Must be doable with available resources (ideally by a person using a pen and paper, but not always practical)\n  - Examples:\n    - Good example: \"Pipette 100 µL\"\n    - Bad example: \"Separate molecules instantly\"\n\nThere are a few more important properties of algorithms. Generally an algorithm should produce the same output given the same input. For example, if your algorithm is supposed to triple a number, an input of `5` should always produce an output of `15`. Additionally, an algorithm should ideally be general enough to solve similar problems in a category. Your tripling algorithm would be more useful (and general) if a user could supply both the number to be multiplied (multiplicand) and the multiplier. This way, the same algorithm could be used for doubling, tripling, quadrupling, etc.\n\n## Algorithmic Thinking Process\n\nBeing able to think algorithmically is essential for success in programming. Algorithmic thinking is the ability to break down problems into clear, logical steps that a computer can follow -- like writing a very detailed recipe where nothing can be assumed or left to interpretation. This skill helps you break down complex problems and translate them into effective code solutions.\n\nLet's go through the various aspects of algorithms.\n\n### Basic Components\n\nEvery algorithm consists of three fundamental parts:\n\n- Input\n  - The data or information that your algorithm needs to work with.\n  - This could be numbers, text, DNA sequences, or any other form of data.\n- Processing\n  - The step-by-step instructions that transform your input into the desired result.\n  - This is essentially your recipe or procedure.\n- Output\n  - The final result or solution that your algorithm produces.\n  - This should match what you need to solve your problem.\n\nBefore you can write an algorithm, you need to understand what problem you're trying to solve:\n\n- Defining the problem scope\n  - Clearly state what your algorithm should and shouldn't do.\n  - For example, \"Find all prime numbers under 100\" is clearer than \"Find prime numbers.\"\n- Understanding requirements\n  - List everything your solution needs to handle.\n  - What kinds of input should it work with?\n  - What should it do with invalid input?\n\nYou can think of these as \"behind-the-scenes\" components. They are critical to algorithmic thinking and construction, but not always explicitly part of the algorithm itself.\n\n### Breaking Problems Into Steps\n\nOnce you have these components in mind, you can break large problems into smaller pieces, which are much more manageable:\n\n- One big problem -> Mutliple sub-problems\n  - Break your main problem into smaller, manageable tasks.\n  - Instead of \"Analyze DNA sequence,\" think about\n    - Read sequence\n    - Check validity\n    - Find patterns\n  - These steps can get as granular as necessary for you to solve the problem at hand.\n- Determine the essential operations needed for each sub-problem.\n- Create a logical sequence of operations\n  - Arrange your sub-problems in a logical order.\n  - What needs to happen first?\n  - Which steps depend on other steps?\n\n### Pseudocode Development\n\nDepending on the complexity of your problem, it can be helpful to sketch out your solution in plain language or pseudocode:\n\n- Writing abstract steps\n  - Write out your algorithm in everyday language.\n  - Use simple statements like \"For each number in the list\" or \"If sequence is valid then...\"\n- Planning program flow\n  - Map out how your program will move from start to finish.\n  - What decisions need to be made?\n  - What steps might need to repeat?\n- Outlining solution structure\n  - Organize your steps into a clear structure, showing where loops and decisions occur.\n\nPlanning your code's structure and components before diving into actual programming makes the whole process much smoother. When you tackle problems this way, you can focus on one aspect at a time, first mapping out the logic and flow, then implementing the code itself. This approach prevents you from getting overwhelmed by trying to solve multiple challenges simultaneously.\n\nWhile thorough planning is essential when you're learning, you'll likely develop a more streamlined approach as you gain experience. For simpler problems, you may find yourself able to start coding directly, having internalized the planning process. However, for complex projects, taking time to sketch out your approach first remains valuable regardless of your skill level.\n\n### Implementation\n\nNow that you have a solid plan, it's time to translate it into working code.\n\n- Convert each step from your pseudocode into actual Python code, one piece at a time\n- Build your code following the structure you mapped out earlier\n- Keep your code clean and maintainable by:\n  - Using descriptive variable names that make sense\n  - Adding helpful comments to explain what your code does\n  - Following consistent formatting and organization\n\nThis stage is a bit like assembling the pieces of a puzzle where you already know what the final picture should look like. Take your time with each component -- rushing through implementation often leads to mistakes that can be challenging to fix later.\n\n### Testing and Validation\n\nAfter your implementation is complete, be sure to test that your algorithm works correctly:\n\n- Testing with simple examples\n  - Start with basic test cases where you know the correct answer.\n  - Check that your algorithm produces correct results for all expected inputs.\n- Iterative refinement\n  - Improve your solution based on test results.\n  - Fix errors and handle edge cases.\n\nWe will discuss more testing strategies in a later tutorial.\n\n## Real-World Algorithm Example -- Making Coffee\n\nLet's take an everyday activity, making coffee, and practice turning it into clear instructions that could work as an algorithm. We will start with some pretty bad instructions, identify problems with them, and then refine them.\n\n(Apologies to all the tea lovers reading this!)\n\n### Take 1\n\nHere is a silly set of instructions for making coffee:\n\n> You'll want to put some liquid in there first, then put the paper thing in. Get the coffee ready -- not too much, not too little. Make sure everything is closed tight before you get things going. Now, just give it a tap and wait a while. If all goes well, you should end up with something drinkable!\n\nIf you have ever made coffee before, you could probably figure out how to follow these instructions. However, it doesn't really work as an algorithm:\n\n- \"liquid\": should I add water or milk?\n- \"in there\": in where?\n- \"paper thing\" instead of filter\n- \"coffee\": should I add coffee beans, ground coffee, instant coffee?\n- \"give it a tap\" instead of pressing the start button\n- \"not too much, not too little\": no specific measurements or timing\n- Uses subjective phrases like \"nice and tight\" and \"you know how it goes\"\n- Uncertain outcome (\"if all goes well\")\n\nLet's address some of these issues and try again.\n\n### Take 2\n\n> Pour fresh water into the top part until it looks full enough. Insert a clean paper filter (any size should work) into the basket area. Measure some coffee grounds -- about a few spoonfuls should do it, depending on how strong you like it. Make sure to close the top properly until you hear a click or something. Find the power button (it might be on the front or side) and push it down. After a few minutes when you stop hearing the machine make noise, your coffee should be done!\n\nThough this version is definitely better than the last one, it still has a few issues:\n\n- Imprecise measurements (\"looks full enough\", \"a few spoonfuls\")\n- Ambiguous specifications (\"any size should work\")\n- Subjective criteria (\"how strong you like it\")\n- Uncertain timing (\"a few minutes\")\n- Vague sensory cues (\"hear a click or something\", \"stop hearing the machine\")\n- Optional or unclear elements (\"or something\", \"might be on the front\")\n\nAgain, if you have ever used a coffee machine, you could probably understand the instructions and adapt them to your taste to make a good cup of coffee. But to be a good algorithm, it still needs more precision, less ambiguity, and it shouldn't leave so much up to your own taste.\n\nLet's address some more of those ambiguities.\n\n### Take 3\n\n> Pour 8 cups of fresh water into the top reservoir, filling to the marked water line. Insert a #4 cone paper filter into the filter basket. Measure 2 level tablespoons of ground coffee per cup of water (16 tablespoons total for a full pot). Press down firmly on the lid until you hear a distinct click indicating it's fully closed. Locate the power switch on the front panel and press it to the \"ON\" position. The brewing process will take approximately 5-7 minutes, and is complete when the gurgling sound stops and the brewing indicator light turns off. Your coffee is now ready to serve.\n\nHere are some specific improvements as compared to the last version:\n\n- Using specific measurements (8 cups, #4 filter, 2 tablespoons per cup)\n- Providing clear indicators (marked water line, distinct click)\n- Giving a defined time range (5-7 minutes)\n- Including concrete completion signals (gurgling stops, indicator light)\n- Specifying exact locations (front panel)\n\n### Beyond the Basic Steps\n\nThough we could keep refining these instructions, it's not a bad description of making coffee now!\n\nIf this were a \"real algorithm\" that we needed to program in Python, there are some more things we should think about. When writing instructions for a computer (or a coffee maker!), it's easy to focus on the happy path -- the sequence of actions that work perfectly. However, robust algorithms must consider various other factors to effectively handle real-world situations where things can go wrong.\n\nHere are some things to think about that are \"beyond the basic steps\".\n\n#### Setup and Requirements\n\nBefore starting any process, we need to ensure everything is in place. This includes checking equipment, materials, and the system's readiness. (You might see the term \"preconditions\" if you are reading about algorithms online.)\n\n- General Questions:\n  - Have we verified all equipment is functional?\n  - Are all necessary materials available?\n  - Is the system in a ready state?\n- Coffee Maker Example:\n  - Is the coffee maker plugged in and working?\n  - Is it clean/ready to use?\n  - Do you have all needed supplies on hand?\n\n#### Handling Problems\n\nThings can go wrong. A good algorithm anticipates potential problems and provides solutions.\n\n- General Questions:\n  - How do we handle insufficient resources?\n  - What happens if components fail?\n  - How do we respond to interruptions?\n  - What backup procedures are needed?\n- Coffee Maker Example:\n  - What if there's not enough water?\n  - What if the filter is inserted incorrectly?\n  - What if the machine doesn't turn on?\n  - What if the brewing stops midway?\n\nWhile you can't generally anticipate everything that may go wrong, it's a good idea to put some thought into it, and try to handle any likely errors.\n\n#### Sequential Dependencies\n\nGenerally, certain steps will rely on others. We need to define the correct order of operations.\n\n- General Questions:\n  - Which steps must happen in a specific order?\n  - What are the critical timing requirements?\n  - Which steps block others from proceeding?\n- Coffee Maker Example:\n  - The filter must be inserted before adding coffee grounds\n  - Water must be added before turning on the machine\n  - The lid must be closed before powering on\n\n#### Conditional Pathways\n\nAlgorithms often need to handle different scenarios based on input or conditions.\n\n- General Questions:\n  - How do varying inputs affect the process?\n  - What alternative routes exist?\n  - How do we handle different scenarios?\n- Coffee Maker Example:\n  - If making less than a full pot, adjust measurements accordingly\n  - If using different grind sizes, adjust portions\n\n#### Validation\n\nValidation and verification of any post-conditions is essential to ensure each step is completed successfully and the final result is correct.\n\n- General Questions:\n  - How do we verify each step succeeded?\n  - What indicates proper operation?\n  - How do we confirm the final result?\n- Coffee Maker Example:\n  - How to check if the filter is seated properly\n  - How to verify the water is actually flowing/brewing\n  - How to confirm the coffee is properly brewed\n\n#### Summary\n\nWhile we don't need this level of detail for every example, it's valuable to understand how simple procedures evolve into robust algorithms through careful consideration of edge cases, error handling, and validation steps.\n\nThis methodology applies broadly to software development: start simple, then systematically address complexities and potential problems.\n\n## Building Blocks for Solving Programming Problems\n\nWhen you're learning to program, it helps to recognize that many solutions are built from common, reusable patterns. These patterns are basic building blocks that you can combine and adapt to solve more complex problems.\n\nWhile there are often many ways to solve a programming challenge, we'll focus on straightforward approaches that are easy to understand and implement. These might not always be the most efficient solutions, but they're good learning tools that will help you:\n\n- Break big problems into manageable pieces\n- Learn reliable approaches to common challenges\n- Develop your problem-solving skills\n\nAs you gain experience, you'll learn more sophisticated methods, or ways that are built-in to the language itself, but mastering these fundamental patterns first will give you a solid foundation. Let's look at some practical examples that demonstrate these basic patterns in action.\n\nIn this tutorial, we will mostly focus on strategies that involve looking at one element at a time from a sequence. Often, this sequential processing will also involve tracking or accumulating values.\n\n### Character Processing\n\nTutorial 2 showed many examples of using for loops to process characters of a string one-by-one. We will repeat some of them here so that you can get more practice seeing the common patterns.\n\n#### Printing Each Character\n\nPrinting each letter of a string:\n\n::: {#a3969a2c .cell execution_count=1}\n``` {.python .cell-code}\nword = \"HELLO\"\nfor character in word:\n    # Do something interesting with each character...\n    print(character)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nH\nE\nL\nL\nO\n```\n:::\n:::\n\n\n#### Iterating with an Index\n\nAccessing the index of the character during iteration:\n\n::: {#839324ac .cell execution_count=2}\n``` {.python .cell-code}\n# Print with position\nword = \"hello\"\nfor index, letter in enumerate(word):\n    print(f\"Position {index}: {letter}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPosition 0: h\nPosition 1: e\nPosition 2: l\nPosition 3: l\nPosition 4: o\n```\n:::\n:::\n\n\n#### Iterating in Reverse\n\nProcessing a string in reverse order:\n\n::: {#dedf8df1 .cell execution_count=3}\n``` {.python .cell-code}\n# Process in reverse\nfor letter in reversed(word):\n    print(letter)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\no\nl\nl\ne\nh\n```\n:::\n:::\n\n\n#### Frequencies\n\nCounting the frequency of individual letters:\n\n::: {#aa8af335 .cell execution_count=4}\n``` {.python .cell-code}\nletter_counts = {}\n\nfor letter in word:\n    current_count = letter_counts.get(letter, 0)\n    letter_counts[letter] = current_count + 1\n\nprint(letter_counts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'h': 1, 'e': 1, 'l': 2, 'o': 1}\n```\n:::\n:::\n\n\n_Note: This is a good example of what I mentioned above regarding these solutions not always being the best way to do something. In Tutorial 2, we discussed a better way to approach this particular counting problem. Can you remember it?_\n\n### Number Processing\n\n#### Running Sum\n\nTracking a running sum:\n\n::: {#8cc6a9cf .cell execution_count=5}\n``` {.python .cell-code}\nnumbers = [2, 5, 3, 1]\ntotal = 0\n\nfor number in numbers:\n    total += number\n\nprint(f\"Total: {total}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTotal: 11\n```\n:::\n:::\n\n\nWhile Python provides built-in functions like `sum()` for this specific case, understanding the basic pattern helps with more complex variations.\n\n#### Summing Positive Numbers\n\nSum of positive numbers:\n\n::: {#ab4c1419 .cell execution_count=6}\n``` {.python .cell-code}\nnumbers = [-1, 2, -5, 3, -8, 1]\n\npositive_sum = sum(num for num in numbers if num > 0)\n\nprint(f\"Sum of positive numbers: {positive_sum}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSum of positive numbers: 6\n```\n:::\n:::\n\n\n#### Averages\n\nCalculating the average of a list of numbers:\n\n::: {#133f928e .cell execution_count=7}\n``` {.python .cell-code}\n# Calculate average\nnumbers = [2, 5, 3, 8, 1]\naverage = sum(numbers) / len(numbers)\nprint(f\"Average: {average}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAverage: 3.8\n```\n:::\n:::\n\n\n### Finding Maximum/Minimum\n\nFinding the largest number in a list without using Python's built-in `max` function:\n\n::: {#af16c524 .cell execution_count=8}\n``` {.python .cell-code}\nnumbers = [5, 3, 0, -1, 8]\nlargest_number = numbers[0]\n\nfor number in numbers[1:]:\n    if number > largest_number:\n        largest_number = number\n\nprint(largest_number)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n8\n```\n:::\n:::\n\n\nFinding the shortest string in a list:\n\n::: {#0a514d57 .cell execution_count=9}\n``` {.python .cell-code}\nwords = [\"i\", \"like\", \"apple\", \"pie\"]\nshortest_word = words[0]\n\nfor word in words[1:]:\n    if len(word) < len(shortest_word):\n        shortest_word = word\n\nprint(shortest_word)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ni\n```\n:::\n:::\n\n\n### Simple Search/Validation\n\nAnother common task is finding an item in a collection or validating some condition of a collection.\n\n#### Finding a Number in a List\n\nFinding a specific number in a list:\n\n::: {#b3796d56 .cell execution_count=10}\n``` {.python .cell-code}\ntarget = 5\nnumbers = list(range(10))\nis_found = False\n\nfor number in numbers:\n    if number == target:\n        is_found = True\n        print(\"we found the number!\")\n\nif not is_found:\n    print(\"we didn't find the number!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nwe found the number!\n```\n:::\n:::\n\n\n#### Is a List Sorted?\n\nChecking if a list is sorted. (Before reading the code, try and think of how the solution might look.)\n\n::: {#8de629a6 .cell execution_count=11}\n``` {.python .cell-code}\nnumbers = [1, 2, 4, 3, 5]\nprevious_number = numbers[0]\n\nis_sorted = True\n\nfor current_number in numbers[1:]:\n    if current_number < previous_number:\n        is_sorted = False\n        break\n    previous_number = current_number\n\nif is_sorted:\n    print(\"the list is sorted!\")\nelse:\n    print(\"the list is not sorted!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthe list is not sorted!\n```\n:::\n:::\n\n\nThis example has a couple of interesting things to focus on:\n\n- We start the iteration at index 1 in the array\n- As soon as we see a number that is not sorted, we `break` since that is enough to say the array as a whole is unsorted.\n\n### Nested Loops\n\nProblems often require nested loops, such as cases where for every item in one list, you need to process every item in another list. Note that these nested loop problems can often be solved in clever ways that help you avoid a having to look at every combination. There's a good chance you will see some of these clever solutions as you are exposed to more code in the future.\n\n#### Distance Between Points\n\nCalculating distances between points. Here we are using 1-dimensional points. The distance between two points in 1D (on a line) is the absolute value of their difference. E.g., if you have two points `x₁` and `x₂`, the distance between them is `|x₁ - x₂|`.\n\n::: {#17e0c8b0 .cell execution_count=12}\n``` {.python .cell-code}\npoints = [8, 3, 4]\ndistances = []\n\nfor x in points:\n    for y in points:\n        distance = abs(x - y)\n        distances.append((x, y, distance))\n\nfor x, y, distance in distances:\n    print(f\"({x}, {y}) => {distance}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(8, 8) => 0\n(8, 3) => 5\n(8, 4) => 4\n(3, 8) => 5\n(3, 3) => 0\n(3, 4) => 1\n(4, 8) => 4\n(4, 3) => 1\n(4, 4) => 0\n```\n:::\n:::\n\n\nYou could imagine instead of distances of 1D points, this pattern could work for calculating all-vs-all homology scores from BLAST output, or comparing some aspect of each sample vs. every other sample.\n\n#### Distance Between Samples\n\nHere's a slightly different example. In this case, say we have ecological distances between all sampling locations stored in a dictionary. Here is one way that you might loop through them:\n\n::: {#1171ae9a .cell execution_count=13}\n``` {.python .cell-code}\nsample_distances = {\n    \"S1\": {\"S1\": 0, \"S2\": 3, \"S3\": 5},\n    \"S2\": {\"S1\": 2, \"S2\": 0, \"S3\": 1},\n    \"S3\": {\"S1\": 6, \"S2\": 2, \"S3\": 0},\n}\n\nfor sample_a, other_samples in sample_distances.items():\n    for sample_b, distance in other_samples.items():\n        print(f\"{sample_a} -> {sample_b} => {distance}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nS1 -> S1 => 0\nS1 -> S2 => 3\nS1 -> S3 => 5\nS2 -> S1 => 2\nS2 -> S2 => 0\nS2 -> S3 => 1\nS3 -> S1 => 6\nS3 -> S2 => 2\nS3 -> S3 => 0\n```\n:::\n:::\n\n\nWhile there are often clever ways to avoid these type of all-vs-all comparisons, they still come up pretty frequently, so it's a good idea to get familiar with them!\n\n## Introduction to Algorithm Analysis\n\nWhen we write code to solve a problem, there's usually more than one way to do it. It's a bit like how you may have different routes to get to work -- some are faster, some are more efficient, and some are just easier to remember. The same applies to our code solutions.\n\nWhen evaluating different approaches to solving a problem, we typically look at three main things:\n\n1. Does it actually solve the problem correctly?\n2. How efficiently does it run (in terms of time and computer memory)?\n3. Is it clear and maintainable?\n\n### Time Complexity\n\nLet's focus on efficiency in terms of time for a moment. Imagine you have a list of genes to search through. You could check each gene one by one (we call this linear time), or you might have a clever way to eliminate half the possibilities with each step (logarithmic time). As your gene list grows from hundreds to millions of entries, these different approaches can mean the difference between waiting seconds versus hours for your results.\n\nComputer scientists use something called \"Big O notation\" to describe how an algorithm's performance changes as the input gets larger. Here are some common patterns you'll encounter.\n\n- Constant time (`O(1)`): The operation always takes the same amount of time\n- Linear time (`O(n)`): The time increases directly with the size of the input\n- Quadratic time (`O(n²)`): The time increases with the square of the input size\n\nThe key takeaway is that some solutions scale better than others when working with larger datasets. As you write code, keeping these basic patterns in mind will help you make better choices about how to approach problems.\n\nHere are some simple examples to illustrate these three time complexities.\n\n#### Constant Time -- O(1)\n\nConstant time operations like dictionary lookups:\n\n::: {#52654f0b .cell execution_count=14}\n``` {.python .cell-code}\ngene_info = {\"nrdA\": \"ribonucleotide reductase\"}\nresult = gene_info[\"nrdA\"]\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nribonucleotide reductase\n```\n:::\n:::\n\n\n#### Linear Time -- O(n)\n\nLinear time operations like checking each item in a list once:\n\n::: {#53ebb971 .cell execution_count=15}\n``` {.python .cell-code}\n# Counting mutations\ndna_sequence = \"ACTACTGTACTACTGTCACACTAGAGTAT\"\nt_count = 0\n\nfor base in dna_sequence:\n    if base == \"T\":\n        t_count += 1\n\nprint(t_count)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n9\n```\n:::\n:::\n\n\n#### Quadratic Time -- O(n²)\n\nQuadratic time operations like comparing every item with every other item:\n\n::: {#79f1bf90 .cell execution_count=16}\n``` {.python .cell-code}\n# Finding equivalent sequences\nsequences = [\"ACTG\", \"ATGAC\", \"ACTGGT\", \"ACTG\"]\nsequence_count = len(sequences)\n\nfor i in range(sequence_count):\n    for j in range(sequence_count):\n        if i != j and sequences[i] == sequences[j]:\n            print(f\"Match found: {sequences[i]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMatch found: ACTG\nMatch found: ACTG\n```\n:::\n:::\n\n\n### Space Complexity\n\nIn addition to thinking about how long our code takes to run, sometimes we also need to consider how much memory it uses. Space complexity describes how memory usage grows with input size. The two most common patterns you'll encounter are:\n\n- O(1) space: Uses a fixed amount of extra memory regardless of input size\n- O(n) space: Uses extra memory that grows with the input size\n\nHere are some examples.\n\n#### Constant Space -- O(1)\n\nIn a constant space solution, the same few variables are used regardless of the input size:\n\n::: {#2e0f5a38 .cell execution_count=17}\n``` {.python .cell-code}\ng_count = 0\n\nfor base in dna_sequence:\n    if base == \"G\":\n        g_count += 1\n\nprint(g_count)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n```\n:::\n:::\n\n\nIn this example, we're just counting, so we only need one variable no matter how long the DNA sequence is.\n\n#### Linear Space -- O(n)\n\nIn a linear space solution, the space needed to calculate the result grows linearly with the size of the input.\n\n::: {#baf023b5 .cell execution_count=18}\n``` {.python .cell-code}\ng_positions = []\n\nfor i in range(len(dna_sequence)):\n    if dna_sequence[i] == \"G\":\n        g_positions.append(i)\n\nprint(g_positions)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[6, 14, 23, 25]\n```\n:::\n:::\n\n\nIn this example, we're storing positions, so we need more space for longer sequences.\n\n## Algorithmic Puzzles\n\nLet's finish off this tutorial by looking at a common, beginner-level algorithmic puzzle: checking if a string is a palindrome.\n\n> A word is a **palindrome** if it reads the same forward and backward.\n\n_Note: This problem description is adapted from LeetCode problem [125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/description/)._\n\n### Starting with the Problem\n\nFirst, let's understand what we're trying to do in plain English:\n\n- We need to check if a word reads the same forwards and backwards\n- Examples\n  - \"racecar\" → Yes!\n  - \"hello\" → No!\n\n(For this version of the problem, we can assume that the strings we need to check are all a single word with all lowercase letters.)\n\n### Solution 1: The Obvious Way\n\nLet's start with the most obvious solution that uses Python string slicing to check the definition of a palindrome.\n\n::: {#aedde400 .cell execution_count=19}\n``` {.python .cell-code}\nstring = \"racecar\"\nis_palindrome = string == string[::-1]\nprint(string, is_palindrome)\n\nstring = \"apple\"\nis_palindrome = string == string[::-1]\nprint(string, is_palindrome)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nracecar True\napple False\n```\n:::\n:::\n\n\nThis is probably how most people would first think about it: \"Just reverse it and compare!\"\n\n- It's perfectly valid\n- It's easy to understand\n- It uses built-in Python functions\n- _But_...It requires creating a whole new reversed string in memory\n\nOften, the \"but\" doesn't really matter in whatever work you are doing. Many times \"clear and maintainable\" are much more important that optimal efficiency. However, in the world of algorithmic puzzles, the \"but\" is definitely something you want to address!\n\n### Solution 2: Manual Comparison with a Loop\n\nFor this solution, we think, \"Wait, do we really need to reverse the string? What a waste of time and space!\"\n\nInstead, we will look at \"pairs\" of letters. First, let's try a word that is a palindrome:\n\n::: {#b52aef33 .cell execution_count=20}\n``` {.python .cell-code}\nstring = \"racecar\"\nprint(\"Checking {string}\")\nis_palindrome = True\n\nfor i in range(len(string)):\n    j = len(string) - i - 1\n\n    print(i, j, string[i], string[j])\n\n    if string[i] != string[j]:\n        is_palindrome = False\n        break\n\nprint(string, is_palindrome)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nChecking {string}\n0 6 r r\n1 5 a a\n2 4 c c\n3 3 e e\n4 2 c c\n5 1 a a\n6 0 r r\nracecar True\n```\n:::\n:::\n\n\nNext, try a word that is not a palindrome, just to see the difference:\n\n::: {#62386303 .cell execution_count=21}\n``` {.python .cell-code}\nstring = \"racethecar\"\nprint(\"\\n\\nChecking {string}\")\nis_palindrome = True\n\nfor i in range(len(string)):\n    j = len(string) - i - 1\n\n    print(i, j, string[i], string[j])\n\n    if string[i] != string[j]:\n        is_palindrome = False\n        break\n\nprint(string, is_palindrome)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\nChecking {string}\n0 9 r r\n1 8 a a\n2 7 c c\n3 6 e e\n4 5 t h\nracethecar False\n```\n:::\n:::\n\n\nDo you see how the non-palindrome stops before checking all the values?\n\nHere is a breakdown of the above solution:\n\n- We compare the first letter with last letter\n- Then, the second letter with second-to-last letter\n- And so on...\n- _But_...We're doing each comparison twice!\n\nJust so it is clear, let's explain that `j` index line. This diagram shows why we use that formula to calculate `j`:\n\n```\nlen(\"racecar\") == 7\n\n┌───┬───┬───┬───┬───┬───┬───┐\n│ r │ a │ c │ e │ c │ a │ r │\n└───┴───┴───┴───┴───┴───┴───┘\n  0   1   2   3   4   5   6\n  ↑   ↑   ↑   ↑   ↑   ↑   ↑\n  i=0 │   │   │   │   │   j = 7 - 0 - 1 = 6\n      │   │   │   │   │\n      i=1 │   │   │   j = 7 - 1 - 1 = 5\n          │   │   │\n          i=2 │   j = 7 - 2 - 1 = 4\n              │\n              i=3, j = 7 - 3 - 1 = 3\n\nand so on...\n```\n\n### Solution 3: The Optimized Version\n\nThere was another \"but\" in Solution 2: Wouldn't it be better if we didn't have to do those duplicated checks? Let's give it a shot.\n\n::: {#c7a11f25 .cell execution_count=22}\n``` {.python .cell-code}\nstring = \"racecar\"\nis_palindrome = True\n\ni = 0\nj = len(string) - 1\n\nwhile i < j:\n    print(i, j, string[i], string[j])\n\n    if string[i] != string[j]:\n        is_palindrome = False\n        break\n\n    i += 1\n    j -= 1\n\nprint(string, is_palindrome)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0 6 r r\n1 5 a a\n2 4 c c\nracecar True\n```\n:::\n:::\n\n\nAnd here again with a string that is not a palindrome:\n\n::: {#5a8f84e1 .cell execution_count=23}\n``` {.python .cell-code}\nstring = \"racethecar\"\nis_palindrome = True\n\ni = 0\nj = len(string) - 1\n\nwhile i < j:\n    print(i, j, string[i], string[j])\n\n    if string[i] != string[j]:\n        is_palindrome = False\n        break\n\n    i += 1\n    j -= 1\n\nprint(string, is_palindrome)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0 9 r r\n1 8 a a\n2 7 c c\n3 6 e e\n4 5 t h\nracethecar False\n```\n:::\n:::\n\n\nAnd the breakdown:\n\n- We use two \"pointers\" moving toward each other\n- We only check each pair once\n- We stop at the middle\n\nThis is both time and space efficient, and doesn't do any more checks than we need to do. Cool, right?\n\n### General Approach\n\nThe above process of refinement suggests a general approach to these kinds of algorithmic puzzles.\n\n- Start simple\n  - Implement the first solution that comes to mind\n  - Don't worry if it's not perfect\n  - Make sure it works!\n- Question your approach\n  - Do I need all these steps?\n  - Am I repeating work?\n  - Is there a more direct way?\n- Look for patterns\n  - Notice we're comparing pairs of letters\n  - Notice we're moving inward from both ends\n  - These observations lead to better solutions\n- Consider resource usage\n  - Time: How many steps are we taking?\n  - Space: How much extra memory do we need?\n  - Can we reduce either?\n\nFocus on making a basic version work before aiming for perfection. Begin with a simple solution, ensure it functions correctly, and then gradually improve it. This mirrors the process of algorithmic thinking described above of breaking down complex problems into manageable steps and refining your solution as needs evolve. This is similar to how programming works in real-world scenarios!\n\n## Summary & Connection to Bioinformatics\n\nIn this tutorial, we introduced the concept of algorithmic thinking and simple algorithms. We went over some common patterns for simple problems that can form the building blocks of more complex solutions. Then we covered the basics of algorithmic complexity analysis, and finally, went through the process of solving a common algorithmic puzzle.\n\nYou might be wondering how these basic programming concepts connect to the bioinformatics tools you'll use in your research. While we rely on sophisticated software for tasks like homology search and genome assembly, these powerful tools are built on the same fundamental programming principles we're learning now.\n\nAlgorithmic thinking, or understanding how to break down problems and translate them into logical steps, is a foundational skill for all coding work. Though we won't be building complex bioinformatics tools from scratch in this course, mastering the basics will give you a solid foundation for writing your own analysis scripts and understanding how the bioinformatics tools you use actually work.\n\n## Bibliography\n\nKnuth, Donald E. 1997. The Art of Computer Programming: Volume 1: Fundamental Algorithms. 3rd ed. Boston, MA: Addison Wesley.\n\n",
    "supporting": [
      "03_algorithms_files"
    ],
    "filters": [],
    "includes": {}
  }
}