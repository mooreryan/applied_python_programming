{
  "hash": "ec66894fb2a3714b83c6184d05b94204",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nauthor: \"Ryan M. Moore, PhD\"\ndate-modified: last-modified\ndate: \"2025-02-04\"\njupyter: python3\n---\n\n\n\n\n\n\n# Basics\n\nWelcome to your first Python tutorial! In this lesson, we'll explore the fundamental building blocks of Python programming, including:\n\n- Variables and how to use them\n- Basic data types (numbers, text, and true/false values)\n- Common operators for calculations and comparisons\n- Essential built-in functions\n- How to control program flow with conditional statements\n\nThis is a comprehensive tutorial that covers a lot of ground. Don't feel pressured to master everything at once -- we'll be practicing these concepts throughout the course. Think of this as your first exposure to these ideas, and we'll build on them step by step in the coming weeks.\n\n## Introduction to Python\n\n### What is Python?\n\nPython is a high-level, interpreted programming language known for its simplicity and readability. Created by Guido van Rossum in 1991, it has become one of the most popular languages in scientific computing and bioinformatics.\n\n#### High level\n\nPython is a high-level programming language, meaning it handles many complex computational details automatically. For example, rather than managing computer memory directly, Python does this for you. This allows biologists and researchers to focus on solving scientific problems rather than dealing with technical computing details.\n\n#### Interpreted\n\nPython is an interpreted language, which means you can write code and run it immediately without an extra compilation step. This makes it ideal for bioinformatics work where you often need to:\n\n- Test different approaches to data analysis\n- Quickly prototype analysis pipelines\n- Interactively explore datasets\n\n#### Readable syntax\n\nPython's code is designed to be readable and clear, often reading almost like English. For example:\n\n```python\nif dna_sequence.startswith(start_codon) and dna_sequence.endswith(stop_codon):\n    potential_genes.append(dna_sequence)\n```\n\nEven if you're new to programming, you can probably guess that this code is looking for potential genes by checking a DNA sequence for a start and a stop codon, and if found, adding the sequence to a list of potential genes.\n\nThis readability is particularly valuable in research settings where code needs to be shared and reviewed by collaborators.\n\n### Use cases\n\nPython is a versatile language that can be used for a wide range of applications, including:\n\n- Artificial intelligence and machine learning (e.g., TensorFlow, PyTorch)\n- Web development (Django, Flask)\n- Desktop applications (PyQt, Tkinter)\n- Game development (Pygame)\n- Automation and scripting\n\nAnd of course, bioinformatics and scientific computing:\n\n- Sequence analysis and processing (Biopython, pysam)\n- Phylogenetics (ETE Toolkit)\n- Data visualization (matplotlib, seaborn)\n- Pipeline automation (snakemake for reproducible workflows)\n- Microbial ecology and microbiome analysis (QIIME)\n\n### Why Python for bioinformatics?\n\nPython has become a widely used tool in bioinformatics for several key reasons:\n\n- **Rich ecosystem**: Extensive libraries specifically for biological data analysis\n- **Active scientific community**: Regular updates and support for bioinformatics tools\n- **Integration capabilities**: Easily connects with other bioinformatics tools and databases\n- **Data science support**: Strong support for data manipulation and statistical analysis\n- **Reproducibility**: Excellent tools for creating reproducible research workflows\n\nWhether you're analyzing sequencing data, building analysis pipelines, or developing new computational methods, Python provides the tools and community support needed for modern biological research.\n\n## Variables\n\nThink of variables as labeled containers for storing data in your program. Just as you might label test tubes in a lab to keep track of different samples, variables let you give meaningful names to your data -- whether they're numbers, text, true/false values, or more complex information.\n\nFor example, instead of working with raw values like this:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nif 47 > 40:\n    print(\"Temperature too high!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTemperature too high!\n```\n:::\n:::\n\n\nYou can use descriptive variables to make your code clearer:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ntemperature = 42.3\ntemperature_threshold = 40.0\n\nif temperature > temperature_threshold:\n    print(\"Temperature too high!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTemperature too high!\n```\n:::\n:::\n\n\nIn this section, we'll cover:\n\n- Creating and using variables\n- Understanding basic data types (numbers, text, true/false values)\n- Following Python's naming conventions\n- Converting between different data types\n- Best practices for using variables in scientific code\n\nBy the end, you'll be able to use variables effectively to write clear, maintainable research code.\n\n### Creating variables\n\nIn Python, you create a variable by giving a name to a value using the `=` operator. Here's a basic example:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nsequence_length = 1000\nspecies_name = \"Escherichia coli\"\n```\n:::\n\n\nYou can then use these variables anywhere in your code by referring to their names. Variables can be combined to create new variables:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Combining text (string) variables\ngenus = \"Escherichia\"\nspecies = \"coli\"\nfull_name = genus + \" \" + species\nprint(full_name)  # Prints: Escherichia coli\n\n# Calculations with numeric variables\nreads_forward = 1000000\nreads_reverse = 950000\ntotal_reads = reads_forward + reads_reverse\nprint(total_reads)  # Prints: 1950000\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEscherichia coli\n1950000\n```\n:::\n:::\n\n\nNotice how the `+` operator works differently depending on what type of data we're using:\n\n- With text (strings), it joins them together\n- With numbers, it performs addition\n\nYou can also use variables in more complex calculations:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ngc_count = 2200\ntotal_bases = 5000\ngc_content = gc_count / total_bases\nprint(gc_content)  # Prints: 0.44\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.44\n```\n:::\n:::\n\n\nThe ability to give meaningful names to values makes your code easier to understand and modify. Instead of trying to remember what the number 5000 represents, you can use a clear variable name like `total_bases`.\n\n### Reassigning variables\n\nPython allows you to change what's stored in a variable after you create it. Let's see how this works:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nread_depth = 100\nprint(f\"Initial read depth: {read_depth}\")\n\nread_depth = 47\nprint(f\"Updated read depth: {read_depth}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInitial read depth: 100\nUpdated read depth: 47\n```\n:::\n:::\n\n\nThis flexibility extends even further -- Python lets you change not just the value, but also the type of data a variable holds:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nquality_score = 30\nquality_score = \"High quality\"\nprint(quality_score)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHigh quality\n```\n:::\n:::\n\n\nWhile this flexibility can be useful, it can also lead to unexpected behavior if you're not careful. Here's an example that could cause problems in a sequence analysis pipeline:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# Correctly calculates and prints the total number of sequences.\nsequences_per_sample = 1000\nsample_count = 5\ntotal_sequences = sequences_per_sample * sample_count\nprint(f\"total sequences: {total_sequences}\")\n\n# This one produces an unexpected result!\nsequences_per_sample = \"1000 sequences \"\nsample_count = 5\ntotal_sequences = sequences_per_sample * sample_count\nprint(f\"total sequences: {total_sequences}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntotal sequences: 5000\ntotal sequences: 1000 sequences 1000 sequences 1000 sequences 1000 sequences 1000 sequences \n```\n:::\n:::\n\n\nIn the second case, instead of performing multiplication, Python repeats the string `\"1000 sequences \"` 5 times! This is probably not what you wanted in your genomics pipeline!\n\nThis kind of type changing can be a common source of bugs, especially when:\n\n- Processing input from files or users\n- Handling missing or invalid data\n- Converting between different data formats\n\nBest practice is to be consistent with your variable types throughout your code, and explicitly convert between types when necessary.\n\n#### Augmented assignments\n\nLet's look at a common pattern when working with variables. Here's one way to increment a counter:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nread_count = 100\nread_count = read_count + 50\nprint(f\"Total reads: {read_count}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTotal reads: 150\n```\n:::\n:::\n\n\nPython provides a shorter way to write this using augmented assignment operators:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nread_count = 100\nread_count += 50\nprint(f\"Total reads: {read_count}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTotal reads: 150\n```\n:::\n:::\n\n\nThese augmented operators combine arithmetic with assignment. Common ones include:\n\n- `+=`: augmented addition (increment)\n- `-=`: augmented subtraction (decrement)\n- `*=`: augmented multiplication\n- `/=`: augmented division\n\nThese operators are particularly handy when updating running totals or counters, like when tracking how many sequences pass quality filters. We'll explore more uses in the next tutorial.\n\n### Named constants\n\nSometimes you'll want to define values that shouldn't change throughout your program.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nGENETIC_CODE_SIZE = 64\nprint(f\"There are {GENETIC_CODE_SIZE} codons in the standard genetic code\")\n\nDNA_BASES = ['A', 'T', 'C', 'G']\nprint(f\"The DNA bases are: {DNA_BASES}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThere are 64 codons in the standard genetic code\nThe DNA bases are: ['A', 'T', 'C', 'G']\n```\n:::\n:::\n\n\nIn Python, we use ALL_CAPS names as a convention to indicate these values shouldn't change. However, it's important to understand that Python doesn't actually prevent these values from being changed. For example:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nMIN_QUALITY_SCORE = 30\nprint(f\"Filtering sequences with quality scores below {MIN_QUALITY_SCORE}\")\n\nMIN_QUALITY_SCORE = 20  # We can change it, even though we shouldn't!\nprint(f\"Filtering sequences with quality scores below {MIN_QUALITY_SCORE}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFiltering sequences with quality scores below 30\nFiltering sequences with quality scores below 20\n```\n:::\n:::\n\n\nThink of Python variables like labels on laboratory samples: you can always move a label from one test tube to another. When you write:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nDNA_BASES = ['A', 'T', 'C', 'G']\nDNA_BASES = ['A', 'U', 'C', 'G']  # Oops, switched to RNA bases!\nprint(f\"These are now RNA bases: {DNA_BASES}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThese are now RNA bases: ['A', 'U', 'C', 'G']\n```\n:::\n:::\n\n\nYou're not modifying the original list of DNA bases -- instead, you're creating a new list and moving the `DNA_BASES` label to point to it. The original list isn't \"protected\" in any way. So, it's more of a convention that ALL_CAPS variables be treated as constants in your code, even though Python won't enforce this rule.\n\n### Dangerous assignments\n\nHere's a common pitfall when naming variables in Python -- accidentally overwriting built-in functions.\n\nPython has several built-in functions that are always available, including one called `str` that converts values to strings. For example:\n\n```\nsequence = str()  # Creates an empty string\nsequence\n```\n\n_Note: if you convert this static code block to one that is runnable, and then actually run it, it would cause errors in the rest of the notebook in any place that uses the `str` function. If you do this, you will need to restart the notebook kernel._\n\nHowever, Python will let you use these built-in names as variable names (though you shouldn't!):\n\n```\nstr = \"ATCGGCTAA\"  # Don't do this!\n```\n\nNow if you try to use the `str` function later in your code:\n\n```\nquality_score = 35\nsequence_info = str(quality_score)  # This will fail!\n```\n\nYou'll get an error:\n\n```\nTypeError: 'str' object is not callable\n```\n\nThis error occurs because we've \"shadowed\" the built-in `str` function with our own variable. Python now thinks we're trying to use the string \"ATCGGCTAA\" as a function, which doesn't work!\n\nWe'll discuss errors in more detail in a future lesson. For now, remember to avoid using Python's built-in names (like `str`, `list`, `dict`, `set`, `len`) as variable names. You can find a complete list of built-ins in the [Python documentation](https://docs.python.org/3/library/functions.html#built-in-functions).\n\n### Naming variables\n\nClear, descriptive variable names are crucial for writing maintainable code. When you revisit your analysis scripts months later, good variable names will help you remember what each part of your code does.\n\n#### Valid names\n\nPython variable names can include:\n\n- Letters (A-Z, a-z)\n- Numbers (0-9, but not as the first character)\n- Underscores (\\_)\n\nWhile Python allows Unicode characters (like Greek letters), it's usually better to stick with standard characters:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nπ = 3.14  # Possible, but not recommended\npi = 3.14  # Better!\n```\n:::\n\n\n#### Case Sensitivity\n\nPython treats uppercase and lowercase letters as different characters:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nsequence = \"ATCG\"\nSequence = \"GCTA\"\nprint(f\"{sequence} != {Sequence}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nATCG != GCTA\n```\n:::\n:::\n\n\nTo avoid confusion, stick with lowercase for most variable names.\n\n#### Naming Conventions\n\nFor multi-word variable names, Python programmers typically use snake_case (lowercase words separated by underscores):\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# Good -- snake case\nread_length = 150\nsequence_count = 1000\nis_high_quality = True\n\n# Avoid - camelCase or PascalCase\nreadLength = 150\nSequenceCount = 1000\n```\n:::\n\n\n#### Guidelines for Good Names\n\nHere are some best practices for naming variables in your code:\n\nUse descriptive names that explain the variable's purpose:\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# Clear and descriptive\nsequence_length = 1000\nquality_threshold = 30\n\n# Too vague\nx = 1000\nthreshold = 30\n```\n:::\n\n\nUse nouns for variables that hold values:\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nread_count = 500\ndna_sequence = \"ATCG\"\n```\n:::\n\n\nBoolean variables often start with `is_`, `has_`, or similar:\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nis_paired_end = True\nhas_adapter = False\n```\n:::\n\n\nCollections (which we'll cover later) often use plural names:\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nsequences = [\"ATCG\", \"GCTA\"]\nquality_scores = [30, 35, 40]\n```\n:::\n\n\nCommon exceptions where short names are okay:\n\n- `i`, `j`, `k` for loop indices\n- `x`, `y`, `z` for coordinates\n- Standard abbreviations like `msg` for message, `num` for number\n\nKeep names reasonably short while still being clear:\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# Too long\nnumber_of_sequences_passing_quality_filter = 100\n# Better\npassing_sequences = 100\n```\n:::\n\n\nRemember: your code will be read more often than it's written, both by others and by your future self. Clear variable names make your code easier to understand and maintain.\n\nFor more detailed naming guidelines, check Python's [PEP 8 Style Guide](https://peps.python.org/pep-0008/#naming-conventions).\n\n## Data Types\n\nPython has many different types of data it can work with. Each data type has its own special properties and uses.\n\nIn this section, we'll cover the basic data types you'll use frequently in your code:\n\n- Numbers\n  - Integers (whole numbers, like sequence lengths or read counts)\n  - Floating-point numbers (decimal numbers, like expression levels or ratios)\n- Strings (text, like DNA sequences or gene names)\n- Boolean values (True/False, like whether a sequence passed quality control)\n\nWe'll learn how to:\n\n- Identify what type of data you're working with\n- Convert between different types when needed\n\nUnderstanding these fundamental data types is crucial for handling data correctly in your programs.\n\n### Checking the type of a value\n\nPython is a dynamically typed language, meaning a variable's type can change during your program. While this flexibility is useful, it's important to keep track of your data types to avoid errors in your analysis.\n\nYou can check a variable's type using Python's built-in `type()` function. Here's how:\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nsequence_length = 150\nprint(type(sequence_length))  # <class 'int'>\n\nsequence = \"ATCGGCTAA\"\nprint(type(sequence))  # <class 'str'>\n\nis_valid = True\nprint(type(is_valid))  # <class 'bool'>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'int'>\n<class 'str'>\n<class 'bool'>\n```\n:::\n:::\n\n\nAs shown above, `type()` tells us exactly what kind of data we're working with. This can be particularly helpful when debugging calculations that aren't working as expected, or verifying data is in the correct format.\n\nDon't worry too much about the `class` keyword in the output -- we'll cover classes in detail later. For now, focus on recognizing the basic types: `int` for integers, `str` for strings (text), and `bool` for True/False values.\n\n### Numeric types (int, float)\n\nPython has two main types for handling numbers:\n\n- `int`: Integers (whole numbers) for counting things like:\n  - Number of sequences\n  - Read lengths\n  - Gene counts\n- `float`: Floating-point numbers (decimals) for measurements like:\n  - Expression levels\n  - P-values\n  - GC content percentages\n\nFor readability with large numbers, you can use underscores: `1_000_000` reads is clearer than `1000000` reads.\n\n#### Numeric operations\n\nThe operators `+`, `-`, `*`, `/` are used to perform the basic arithmetic operations.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nforward_reads = 1000\nreverse_reads = 800\nprint(forward_reads + reverse_reads)\nprint(forward_reads - reverse_reads)\nprint(forward_reads * 2)\nprint((forward_reads + reverse_reads) / 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1800\n200\n2000\n18.0\n```\n:::\n:::\n\n\nFloat division (`/`) always returns a float, whereas integer division (`//`) returns an int by performing [floor division](https://docs.python.org/3/glossary.html#term-floor-division).\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\ntotal_bases = 17\nreads = 5\nprint(total_bases / reads)\nprint(total_bases // reads)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3.4\n3\n```\n:::\n:::\n\n\nThe operator `**` is used for exponentiation.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nprint(2 ** 8)\nprint(8 ** 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n256\n64\n```\n:::\n:::\n\n\nParentheses `()` can be used to group expressions and control the order of operations.\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# Order of operations\nprint(2 + 3 * 4)     # multiplication before addition\nprint( (2 + 3) * 4 ) # parentheses first\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n14\n20\n```\n:::\n:::\n\n\nModulo (`%`) gives remainder of division\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nposition = 17\ncodon_position = position % 3  # Which position in codon (0, 1, or 2)\nprint(codon_position)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n```\n:::\n:::\n\n\nBe careful about combining negative numbers with floor division or modulo. Here are some interesting examples showing how negative numbers behave with floor division and modulo in Python:\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# Floor division with negative numbers\nprint(\"Floor division with negative numbers:\")\n# Rounds down to nearest integer\nprint(17 // 5)\n# Rounds down, not toward zero\nprint(-17 // 5)\nprint(17 // -5)\nprint(-17 // -5)\n\n# Modulo with negative numbers\nprint(\"\\nModulo with negative numbers:\")\nprint(17 % 5)\n# Result is positive with positive divisor\nprint(-17 % 5)\n# Result has same sign as divisor\nprint(17 % -5)\nprint(-17 % -5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFloor division with negative numbers:\n3\n-4\n-4\n3\n\nModulo with negative numbers:\n2\n3\n-3\n-2\n```\n:::\n:::\n\n\nDon't worry too much about the details of how negative numbers work with division and modulo operations. Just be aware that they can behave unexpectedly, and look up the specific rules if you need them.\n\n#### Scientific notation\n\nScientific notation is essential when working with very large or small numbers:\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# 3.2 billion bases\ngenome_size = 3.2e9\n\n# 0.00000001 mutations per base\nmutation_rate = 1e-8\n```\n:::\n\n\n#### Precision Considerations\n\n##### Integers\n\nPython can handle arbitrarily large integers, limited only by memory:\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nbig_number = 125670495610435017239401723907559279347192756\nprint(big_number)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n125670495610435017239401723907559279347192756\n```\n:::\n:::\n\n\n##### Floats\n\nFloating-point numbers have limited precision (about 15-17 decimal digits). This can affect calculations:\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nx = 0.1\ny = 0.2\n\n# Might not be exactly 0.3\nprint(x + y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.30000000000000004\n```\n:::\n:::\n\n\nWhile these precision errors are usually small, they can accumulate in large-scale calculations.\n\n### Strings\n\nStrings are how Python handles text data, like sequences or gene names.\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\n# Strings can use single or double quotes\nsequence = 'ATCG'\ngene_name = \"nrdA\"\nprint(sequence)\nprint(gene_name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nATCG\nnrdA\n```\n:::\n:::\n\n\nStrings are immutable -- once created, they cannot be modified. For example, you can't change individual bases in a sequence directly:\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\ndna = \"ATCG\"\n# This would raise an error:\n# dna[0] = \"G\"\n```\n:::\n\n\nTry uncommenting that line and see what happens!\n\nYou can combine strings using the `+` operator:\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# String concatenation\nsequence_1 = \"ATCG\"\nsequence_2 = \"GCTA\"\nfull_sequence = sequence_1 + sequence_2\nprint(\"the sequence is: \" + full_sequence)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthe sequence is: ATCGGCTA\n```\n:::\n:::\n\n\nSpecial characters can be included using escape sequences:\n\n- `\\n` for new line\n- `\\t` for tab\n- `\\\\` for backslash\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n# Formatting sequence output\nprint(\"Sequence 1:\\tATCG\\nSequence 2:\\tGCTA\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSequence 1:\tATCG\nSequence 2:\tGCTA\n```\n:::\n:::\n\n\nF-strings (format strings) are particularly useful for creating formatted output. They allow you to embed variables and expressions in strings using `{expression}`:\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\ngene_id = \"nrdJ\"\nposition = 37_531\n\nprint(f\"Gene {gene_id} is located at position {position}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGene nrdJ is located at position 37531\n```\n:::\n:::\n\n\nF-strings can also format numbers, which is useful for scientific notation and precision control:\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\n# Two decimal places\ngc_content = 0.42857142857\nprint(f\"GC content: {gc_content:.2f}\")\n\n# Scientific notation\np_value = 0.000000342\nprint(f\"P-value: {p_value:.2e}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGC content: 0.43\nP-value: 3.42e-07\n```\n:::\n:::\n\n\nStrings can contain Unicode characters:\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n# Unicode characters\nprint(\"你好\")\nprint(\"こんにちは\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n你好\nこんにちは\n```\n:::\n:::\n\n\nWhile Python supports Unicode characters in variable names, it's better to use standard ASCII characters for code:\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\n# Possible, but not recommended\nα = 0.05\nβ = 0.20\n\n# Better\nalpha = 0.05\nbeta = 0.20\n```\n:::\n\n\n#### Common string operations\n\nString operations are fundamental for processing and manipulating textual data, formatting output, and cleaning up input in your applications and analysis pipelines.\n\n##### String concatenation with `+`\n\nThe `+` operator joins strings together:\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\n# Joining DNA sequences\nsequence1 = \"ATCG\"\nsequence2 = \"GCTA\"\ncombined_sequence = sequence1 + sequence2\nprint(combined_sequence)\n\n# Adding labels to sequences\ngene_id = \"nrdA\"\nlabeled_sequence = gene_id + \": \" + combined_sequence\nprint(labeled_sequence)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nATCGGCTA\nnrdA: ATCGGCTA\n```\n:::\n:::\n\n\n##### String repetition with `*`\n\nThe `*` operator repeats a string a specified number of times:\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\n# Repeating DNA motifs\nmotif = \"AT\"\nrepeat = motif * 3\nprint(repeat)\n\n# Creating alignment gap markers\ngap = \"-\" * 6\nprint(gap)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nATATAT\n------\n```\n:::\n:::\n\n\n##### String indexing\n\nPython uses zero-based indexing to access individual characters in a string. You can also use negative indices to count from the end:\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\n# Indexing\ns = \"Hello, world!\"\nprint(s[0])\nprint(s[7])\nprint(s[-1])\nprint(s[-8])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nH\nw\n!\n,\n```\n:::\n:::\n\n\n##### String slicing\n\nSlicing lets you extract parts of a string using the format `[start:end]`. The `end` index is exclusive:\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\n# Slicing\ns = \"Hello, World!\"\nprint(s[0:5])\nprint(s[7:])\nprint(s[:5])\nprint(s[-6:])\nprint(s[-12:-8])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello\nWorld!\nHello\nWorld!\nello\n```\n:::\n:::\n\n\n##### String methods\n\nPython strings have built-in methods for common operations. Here are a few common ones:\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\n# Clean up sequence data with leading/trailing white space\nraw_sequence = \"  ATCG GCTA  \"\nclean_sequence = raw_sequence.strip()\nprint(\"|\" + raw_sequence + \"|\")\nprint(\"|\" + clean_sequence + \"|\")\n\n# Convert between upper and lower case\nmixed_sequence = \"AtCg\"\nprint(mixed_sequence.upper())\nprint(mixed_sequence.lower())\n\n# Chaining methods\nmessy_sequence = \"  AtCg  \"\nclean_upper = messy_sequence.strip().upper()\nprint(\"|\" + clean_upper + \"|\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n|  ATCG GCTA  |\n|ATCG GCTA|\nATCG\natcg\n|ATCG|\n```\n:::\n:::\n\n\n### Boolean values\n\nBoolean values represent binary states (True/False) and are used to make decisions in code:\n\n- `True` represents a condition being met\n- `False` represents a condition not being met\n\n(Note: These are capitalized keywords in Python!)\n\nBoolean variables often use prefixes like `is_`, `has_`, or `contains_` to clearly indicate their purpose:\n\n```python\nis_paired_end = True\nhas_adapter = False\ncontains_start_codon = True\n```\n\nBoolean values are used in control flow -- they drive decision-making in your code:\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\nis_high_quality = True\nif is_high_quality:\n    print(\"Sequence passes quality check!\")\n\nhas_ambiguous_bases = False\nif has_ambiguous_bases:\n    # This won't execute because condition is False\n    print(\"Warning: Sequence contains N's\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSequence passes quality check!\n```\n:::\n:::\n\n\nBoolean values are created through comparisons, for example:\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\n# Quality score checking\nquality_score = 35\nprint(quality_score > 30)\nprint(quality_score < 20)\nprint(quality_score == 40)\nprint(quality_score != 35)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\nFalse\nFalse\n```\n:::\n:::\n\n\nLogical operators (`and`, `or`, `not`) combine boolean values:\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\n# Logical operations\nprint(True and False)\nprint(True or False)\nprint(not True)\nprint(not False)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\nTrue\nFalse\nTrue\n```\n:::\n:::\n\n\nFor example, you could use logical operators to combine multiple logical statements:\n\n```\nis_long_enough and is_high_quality\n\nis_exempt or exceeds_threshold\n```\n\n#### Comparison operators In Depth\n\nComparison operators are used to compare \"compare\" values. They return a boolean value (`True` or `False`) and are often used in conditional statements and loops to control program flow.\n\nThe basic comparison operators are:\n\n- `==`: equal to\n- `!=`: not equal to\n- `<`: strictly less than\n- `<=`: less than or equal to\n- `>`: strictly greater than\n- `>=`: greater than or equal to\n\nAdditional operators we'll cover later:\n\n- `is`, `is not`: object identity\n- `in`, `not in`: sequence membership\n\nHere are a couple examples:\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\n# Basic boolean values\nis_sunny = True\nis_raining = False\n\nprint(f\"Is it sunny? {is_sunny}\")\nprint(f\"Is it raining? {is_raining}\")\n\n# Comparison operations produce boolean results\ntemperature = 25\nis_hot = temperature > 30\nprint(f\"Is it hot? {is_hot}\")\n\n# Logical operations\nis_good_weather = is_sunny and not is_raining\nprint(f\"Is it good weather? {is_good_weather}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIs it sunny? True\nIs it raining? False\nIs it hot? False\nIs it good weather? True\n```\n:::\n:::\n\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\n# Comparison operations\nprint(5 == 5)\nprint(5 != 5)\nprint(5 < 3)\nprint(5 <= 3)\nprint(5 <= 5)\nprint(5 > 3)\nprint(5 >= 3)\nprint(5 >= 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\nFalse\nFalse\nTrue\nTrue\nTrue\nTrue\n```\n:::\n:::\n\n\n##### Chained Comparisons\n\nComparisons can be chained together, e.g. `1 < 2 < 3` is equivalent to `1 < 2 and 2 < 3`.\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\n# Chained comparisons\nprint(1 < 2 < 3)\nprint(1 < 2 < 2)\nprint(1 < 2 <= 2)\n\n# This one is a bit weird, but it's valid Python!\nprint(1 < 2 > 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\nTrue\nFalse\n```\n:::\n:::\n\n\nThe comparisons operators can also be used to compare the values of variables.\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\n# Check if value is in valid range\ncoverage = 30\nprint(10 < coverage < 50)\n\nquality_score = 35\nprint(20 < quality_score <= 40)\n\n# Multiple range checks\ntemperature = 37.2\nprint(37.0 <= temperature <= 37.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nTrue\nTrue\n```\n:::\n:::\n\n\n##### Comparing Strings & Other Values\n\nPython's comparison operators work beyond just numbers, allowing comparisons between various types of data. Be careful though -- while some comparisons make intuitive sense, others might require careful consideration or custom implementation.\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\n# Comparison of different types\nprint(\"Hello\" == \"Hello\")\nprint(\"Hello\" == \"World\")\nprint(\"Hello\" == 5)\nprint(\"Hello\" == True)\n\n# Some non-numeric types also have a natural ordering.\nprint(\"a\" < \"b\")\nprint(\"a\" < \"A\")\n\n# This is a bit weird, but it's valid Python!\nprint([1, 2, 3] <= [10, 20, 30])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\nFalse\nFalse\nTrue\nFalse\nTrue\n```\n:::\n:::\n\n\n#### Logical Operators In Depth\n\nThink of logical operators as ways to combine or modify simple yes/no conditions in your code, much like how you might combine criteria when filtering data in Excel or selecting samples for an experiment.\n\nFor example, you can use logical operators to express conditions like:\n\n- \"If a DNA sequence is **both** longer than 250 bases **AND** has no ambiguous bases, include it in the analysis\"\n- \"If a gene is **either** highly expressed **OR** shows significant differential expression, flag it for further study\"\n- \"If a sample is **NOT** properly labeled, skip it and log a warning\"\n\nThese operators (`and`, `or`, `not`) work similarly to the way we combine conditions in everyday language. Just as you might say \"I'll go for a run if it's not raining AND the temperature is above 60°F,\" you can write code that makes decisions based on multiple criteria.\n\nHere are a couple of examples:\n\n```python\n# In a sequence quality filtering pipeline\n#\n# Both conditions must be true\nif sequence_length >= 250 and quality_score >= 30:\n    keep(sequence)\n\n# In a variant calling pipeline\n#\n# Either condition being true is sufficient\nif mutation_frequency > 0.01 or supporting_reads >= 100:\n    report(variant)\n\n# In a data validation step\n#\n# Triggers if the condition is false\nif not sample_id.startswith('PROJ_'):\n    warn_user(sample_id)\n```\n\nThink of these operators as the digital equivalent of the decision-making process you use in the lab: checking multiple criteria before proceeding with an experiment, or having alternative procedures based on different conditions.\n\n##### Behavior of logical operators\n\nLet's explore how Python's logical operators (`and`, `or`, `not`) work, using examples relevant to biological data analysis.\n\nThink of these operators as ways to check multiple conditions, similar to how you might design experimental criteria:\n\n- `and`: Like requiring ALL criteria to be met (e.g., both proper staining AND correct cell count)\n- `or`: Like accepting ANY of several criteria (e.g., either elevated temperature OR positive test result)\n- `not`: Like reversing a condition (e.g., NOT contaminated)\n\nHere's a truth table showing all possible combinations.\n\n| **A** | **B** | **A and B** | **A or B** | **not A** |\n| ----- | ----- | ----------- | ---------- | --------- |\n| True  | True  | True        | True       | False     |\n| True  | False | False       | True       | False     |\n| False | True  | False       | True       | True      |\n| False | False | False       | False      | True      |\n\nHere are the rules:\n\n- `and` only gives True if both conditions are True (like requiring all quality checks to pass)\n- `or` gives True if at least one condition is True (like having multiple acceptable criteria)\n- `not` flips True to False and vice versa (like converting \"passed QC\" to \"failed QC\")\n\nInterestingly, Python can also evaluate non-boolean values (values that aren't strictly True or False) using these operators. We call values that Python treats as True \"truthy\" and values it treats as False \"falsy\". This becomes important when working with different types of data in your programs and analysis pipelines.\n\n##### Understanding \"Truthy\" and \"Falsy\" Values\n\nIn Python, every value can be interpreted as either \"true-like\" (truthy) or \"false-like\" (falsy) when used in logical operations. This is similar to how in biology, we might categorize results as \"positive\" or \"negative\" even when the underlying data is more complex than a simple yes/no.\n\nThink of \"falsy\" values as representing empty, zero, or null states -- essentially, the absence of meaningful data. Python considers the following values as \"falsy\":\n\n- `False`: The boolean False value\n- `None`: Python's way of representing \"nothing\" or \"no value\" (like a blank entry in a spreadsheet)\n- Any form of zero (like `0`, `0.0`)\n- Empty containers:\n  - Empty string (`\"\"`)\n  - Empty list (`[]`)\n  - Empty set (`set()`)\n  - Empty dictionary (`{}`)\n\nEverything else is considered \"truthy\" - meaning it represents the presence of some meaningful value or data.\n\nLet's look at some practical examples. We can use Python's `bool()` function to explicitly check whether Python considers a value truthy or falsy:\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\n# Examples from sample processing:\nsample_count = 0\n# False (no samples)\nprint(bool(sample_count))\n\nsample_ids = []\n# False (empty list of IDs)\nprint(bool(sample_ids))\n\npatient_data = {}\n # False (empty data table)\nprint(bool(patient_data))\n\n# Compare with:\nsample_count = 5\n# True (we have samples)\nprint(bool(sample_count))\n\nsample_ids = [\"A1\", \"B2\"]\n# True (we have some IDs)\nprint(bool(sample_ids))\n\npatient_data = {\"age\": 45}\n# True (we have some data)\nprint(bool(patient_data))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\nFalse\nFalse\nTrue\nTrue\nTrue\n```\n:::\n:::\n\n\nUnderstanding truthy and falsy values becomes particularly useful when writing conditions in your code, like checking whether you have data before proceeding with analysis:\n\n```python\n# Sort of like saying: if there are some samples IDs,\n# then do something with them.\nif sample_ids:\n    process_samples(sample_ids)\nelse:\n    print(\"No samples to process\")\n```\n\nWe'll see more examples of how this concept is useful in practice as we work through more advanced topics.\n\n##### Even More Details About `and` and `or`\n\n_Note: This section is a bit low-level, so don't worry too much about it. It's just here for your reference._\n\nOne kind of neat thing about the logical operators is that you can directly use them as a type of control flow.\n\n###### `and`\n\nGiven an expression `a and b`, the following steps are taken:\n\n1. First, evaluate `a`.\n2. If `a` is \"falsy\", then return the value of `a`.\n3. Otherwise, evaluate `b` and return its value.\n\nCheck it out:\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\na = \"apple\"\nb = \"banana\"\nresult = a and b\nprint(result)\n\nname = \"Maya\"\nage = 45\nresult = age >= 18 and f\"{name} is an adult\"\nprint(result)\n\nname = \"Amira\"\nage = 15\nresult = age >= 18 and f\"{name} is an adult\"\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbanana\nMaya is an adult\nFalse\n```\n:::\n:::\n\n\nWere the values assigned to `result` what you expected?\n\n###### `or`\n\nGiven an expression `a or b`, the following steps are taken:\n\n1. First, evaluate `a`.\n2. If `a` is \"truthy\", then return the value of `a`.\n3. Otherwise, evaluate `b` and return its value.\n\nLet's return to the previous example, but this time we will use `or` instead of `and`.\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\na = \"apple\"\nb = \"banana\"\nresult = a or b\nprint(result)\n\nname = \"Maya\"\nage = 45\n# Observe that this code isn't really doing what we want it to do.\n# `result` will be True, rather than \"Maya is an adult\".\n# That's because it should be using `and`\n#   ...again, it's just for illustration.\nresult = age >= 18 or f\"{name} is an adult\"\nprint(result)\n\nname = \"Amira\"\nage = 15\n# This code is a bit obscure, and you probably wouldn't\n# write it like this in practice.  But it illustrates the\n# point.\nresult = age >= 18 or f\"{name} is not an adult\"\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\napple\nTrue\nAmira is not an adult\n```\n:::\n:::\n\n\nWere the values assigned to `result` what you expected?\n\n## Control Flow\n\nThink of control flow as the decision-making logic in your code - like following a lab protocol, but for data analysis. Just as you make decisions in the lab (\"if the pH is too high, add buffer\"), your code needs to make decisions about how to handle different situations.\n\nControl flow statements are the programming equivalent of those decision points in your protocols. They let your program take different paths depending on the conditions it encounters, much like how you might follow different steps in an experiment based on your observations.\n\nIn this section, we'll cover several ways to build these decision points into your code:\n\n- Simple `if` statements (like \"if the sequence quality is low, skip it\")\n- `if-else` statements (like \"if the gene is expressed, mark it as active; otherwise, mark it as inactive\")\n- `if-elif-else` chains (for handling multiple possibilities, like different ranges of p-values)\n- Nested conditions (for more complex decisions, like filtering sequences based on multiple quality metrics)\n\nControl flow is essential for writing programs that can:\n\n- Make decisions based on data\n- Handle different scenarios\n- Respond to user input\n- Conditionally process data\n\nJust as following the right branch points in a protocol is crucial for experimental success, proper control flow is key to writing programs that correctly handle your data.\n\nLet's explore the main types of control flow in Python:\n\n### `if` Statements\n\nThink of these as your basic yes/no checkpoints, like checking if a sample meets quality control:\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\nquality_score = 35\nif quality_score > 30:\n    print(\"Sample passes QC\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSample passes QC\n```\n:::\n:::\n\n\n### `if-else` Statements\n\nThese handle two alternative outcomes, like categorizing genes as expressed or not expressed:\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\nexpression_level = 1.5\nif expression_level > 1.0:\n    print(\"Gene is upregulated\")\nelse:\n    print(\"Gene is not upregulated\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGene is upregulated\n```\n:::\n:::\n\n\n### `if-elif-else` Chains\n\nPerfect for handling multiple possibilities, like categorizing p-values or expression levels:\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\np_value = 0.03\nif p_value < 0.01:\n    print(\"Highly significant\")\nelif p_value < 0.05:\n    print(\"Significant\")\nelse:\n    print(\"Not significant\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSignificant\n```\n:::\n:::\n\n\n### Multiple Conditions\n\nSometimes you need to check multiple criteria, like filtering sequencing data:\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\nread_length = 100\ngc_content = 0.45\nquality_score = 35\n\nif read_length >= 100 and quality_score > 30 and 0.4 <= gc_content <= 0.6:\n    print(\"Read passes all quality filters\")\nelse:\n    print(\"Read filtered out\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRead passes all quality filters\n```\n:::\n:::\n\n\n### Key Points to Remember\n\n- Conditions are checked in order from top to bottom\n- Only the first matching condition's code block will execute\n- Keep your conditions clear and logical, like a well-designed experimental workflow\n- Try to avoid deeply nested conditions as they can become confusing\n\nThink of control flow as building decision points into your data analysis pipeline. Just as you wouldn't proceed with a PCR if your DNA quality was poor, your code can automatically make similar decisions about data processing.\n\n### Nested Conditional Statements\n\nConditional statements can also be nested. Here is some code that is checking if someone can go to the beach. If they are not at work, and the weather is sunny, then they can go to the beach.\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\nat_work = False\nweather = \"sunny\"\n\nif weather == \"sunny\" and not at_work:\n    print(\"It's sunny and you are not at work, let's go to the beach!\")\nelse:\n    print(\"We can't go to the beach today for some reason.\")\n\n# Let's move the check for at_work nested inside the if statement that checks\n# the weather.\n#\n# Note that this code isn't equivalent to the previous code, just an example\n# of nesting.\n\nif weather == \"sunny\":\n    if at_work:\n        print(\"You are at work and can't go to the beach.\")\n    else:\n        print(\"It's sunny and you are not at work, let's go to the beach!\")\nelse:\n    print(\"It's not sunny, so we can't go to the beach regardless.\")\n\n# Just to be clear, let's \"unnest\" that conditional.\nif weather == \"sunny\" and at_work:\n    print(\"You are at work and can't go to the beach.\")\nelif weather == \"sunny\":\n    print(\"It's sunny and you are not at work, let's go to the beach!\")\nelse:\n    print(\"It's not sunny, so we can't go to the beach regardless.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIt's sunny and you are not at work, let's go to the beach!\nIt's sunny and you are not at work, let's go to the beach!\nIt's sunny and you are not at work, let's go to the beach!\n```\n:::\n:::\n\n\n### A Note on Keeping Things Simple\n\nJust as you want to keep your experimental protocols clear and straightforward, the same principle applies to writing conditional statements in your code. Think of deeply nested if-statements like trying to follow a complicated diagnostic flowchart - the more branches and decision points you add, the easier it is to lose track of where you are.\n\nFor example, imagine designing a PCR troubleshooting guide where each problem leads to three more questions, each with their own set of follow-up questions. While technically complete, it would be challenging for anyone to follow correctly. The same goes for code -- when we stack too many decisions inside other decisions, we're setting ourselves up for confusion.\n\nHere's why keeping conditions simple matters:\n\n- Each decision point is an opportunity for something to go wrong (like each step in a protocol)\n- Complex nested conditions are harder to debug (like trying to figure out where a multi-step experiment went wrong)\n- Simple, clear code is easier for colleagues to review and understand\n\nWhen you find yourself writing deeply nested conditions, it's often a sign to step back and consider whether there's a clearer way to structure your code.\n\n## Basic Built-in Functions\n\nThink of Python's built-in functions as your basic laboratory toolkit - they're always there when you need them, no special setup required. These functions will become your go-to tools for handling biological data, from DNA sequences to experimental measurements.\n\nHere are some of the most useful built-in functions you'll use regularly:\n\n- `print()`: Displays your data or results\n- `len()`: Counts the length of something\n- `abs()`: Gives you the absolute value\n- `round()`: Tidies up decimal numbers\n- `min()` and `max()`: Find the lowest and highest values\n- `sum()`: Adds up a collection of numbers\n- `type()`: Tells you what kind of data you're working with (helpful for debugging)\n\nLet's look at some examples:\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\n# Printing experimental results\nprint(\"Gene expression analysis complete!\")\n\n# Checking sequence length\ndna_sequence = \"ATCGATCGTAGCTAGCTAG\"\nlength = len(dna_sequence)\nprint(f\"This DNA sequence is {length} base pairs long.\")\n\n# Working with expression fold changes\nfold_change = -2.5\nabsolute_change = abs(fold_change)\nprint(f\"The absolute fold change is {absolute_change}x.\")\n\n# Cleaning up p-values\np_value = 0.0000234567\nrounded_p = round(p_value, 6)\nprint(f\"p-value = {rounded_p}\")\n\n# Analyzing multiple expression values\nexpression_levels = [10.2, 5.7, 8.9, 12.3, 6.8]\nlowest = min(expression_levels)\nhighest = max(expression_levels)\nprint(f\"Expression range: {lowest} to {highest}\")\n\n# Calculating average coverage\ncoverage_values = [15, 22, 18, 20, 17]\naverage_coverage = sum(coverage_values) / len(coverage_values)\nprint(f\"Average sequencing coverage: {average_coverage}x\")\n\n# Checking data types\ngene_name = \"nrdA\"\ndata_type = type(gene_name)\nprint(f\"The variable gene_name is of type: {data_type}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGene expression analysis complete!\nThis DNA sequence is 19 base pairs long.\nThe absolute fold change is 2.5x.\np-value = 2.3e-05\nExpression range: 5.7 to 12.3\nAverage sequencing coverage: 18.4x\nThe variable gene_name is of type: <class 'str'>\n```\n:::\n:::\n\n\nTo use these functions, just type the function name followed by parentheses containing your data (the \"arguments\"). Some functions, like `min()` and `max()`, can handle multiple inputs, which is handy when comparing several values at once.\n\n## Wrap-Up\n\nIn this tutorial, we covered the fundamental building blocks of Python programming that you'll use throughout your bioinformatics work:\n\n- **Variables** help you store and manage data with meaningful names\n- **Data types** like numbers, strings, and booleans let you work with different kinds of biological data\n- **Control flow** statements help your programs make decisions based on data\n- **Built-in functions** provide essential tools for common programming tasks\n\nRemember:\n\n- Choose clear, descriptive variable names\n- Be mindful of data types when performing operations\n- Keep conditional logic as simple as possible\n- Make use of Python's built-in functions for common tasks\n\nThese basics form the foundation for more advanced programming concepts we'll explore in future tutorials. Practice working with these fundamentals -- they're the tools you'll use to build more complex bioinformatics applications.\n\nDon't worry if everything hasn't clicked yet. Programming is a skill that develops with practice. Focus on understanding one concept at a time, and remember that you can always refer back to this tutorial as a reference.\n\nNext up, we'll build on these basics to work with more complex data structures and write functions of our own!\n\n",
    "supporting": [
      "01_basics_files/figure-pdf"
    ],
    "filters": []
  }
}