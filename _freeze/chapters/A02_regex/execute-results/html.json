{
  "hash": "fc1dd5e52a598aae1d241d057bb1c180",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nauthor: \"Ryan M. Moore, PhD\"\ndate-modified: last-modified\ndate: \"2025-04-01\"\njupyter: python3\n---\n\n# Appendix 2: Regular Expressions {.unnumbered}\n\nRegular expressions (regex) are powerful tools for working with text data, and are commonly used in bioinformatics applications. They are essentially a specialized mini-language for pattern matching in strings.\n\nRegular expressions allow you to:\n\n- Search for specific patterns in text\n- Validate that strings follow expected patterns\n- Extract information from strings with consistent formats\n- Replace or modify parts of strings that match patterns\n\nLet's take a whirlwind tour of the basics of regular expressions in Python. This will not be comprehensive, but should provide you with just enough of the basics to get some real work done, and be able to understand more [comprehensive documentation](https://www.regular-expressions.info/).\n\n## Importing the Regular Expression module\n\nTo use regular expressions, you first need to import the `re` module.\n\n::: {#d8365d5b .cell execution_count=1}\n``` {.python .cell-code}\nimport re\n```\n:::\n\n\n## Basic Pattern Matching\n\nThe simplest use of regex is searching for an exact substring within a larger string:\n\n::: {#83f8e556 .cell execution_count=2}\n``` {.python .cell-code}\n# This checks if \"banana\" appears anywhere in the string\nif re.search(r\"banana\", \"apple and banana\"):\n    print(\"found banana!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfound banana!\n```\n:::\n:::\n\n\nThe `r` before the pattern string creates a \"raw string\". This is a good practice with regex to avoid problems with backslashes.\n\n## Special Symbols and Character Classes\n\nRegex provides special symbols to match categories of characters or to control the matching in some other way. Here are some of the more common ones.\n\n- `.`: Matches any character except newline\n- `^`: Matches at the start of the string\n- `$` Matches at the end of the string\n- `+`: Matches one or more of the preceding regex\n- `*`: Matches zero or more of the preceding regex\n- `?`: Matches zero or one repetitions of the preceding regex\n- `{m}`: Matches exactly `m` copies of the preceding regex\n- `{m,n}`: Matches from `m` to `n` copies of the preceding regex\n- `\\d`: Matches any digit (0-9)\n- `\\w`: Matches any \"word character\" (alphanumeric + underscore)\n- `\\s`: Matches any whitespace\n- `[]`: Used to indicate a set of characters\n- `()`: Used to indicate a capture group\n\nThere are [many more](https://docs.python.org/3/library/re.html#regular-expression-syntax) available in Python, but this set will get you pretty far.\n\n## Anchoring Patterns\n\nSometimes you want to check if a pattern appears at a specific position in a string. The `^` symbol anchors the match to the beginning of the string:\n\n::: {#5307c852 .cell execution_count=3}\n``` {.python .cell-code}\n# Check if \"apple\" appears at the beginning of the string\n# The ^ character is an anchor that means \"match at the start of the string\"\nif re.search(r\"^apple\", \"banana and apple\"):\n    # This won't execute because \"banana and apple\" doesn't start with \"apple\"\n    print(\"apple found at the beginning\")\nelse:\n    # This will execute because the pattern doesn't match\n    print(\"apple not found at the beginning\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\napple not found at the beginning\n```\n:::\n:::\n\n\nThe `$` symbol anchors the match to the end of the string:\n\n::: {#d1469d3e .cell execution_count=4}\n``` {.python .cell-code}\n# Check if \"banana\" appears at the end of the string\n# The $ character is an anchor that means \"match at the end of the string\"\nif re.search(r\"banana$\", \"banana and apple\"):\n    # This won't execute because \"banana and apple\" doesn't end with \"banana\"\n    print(\"banana found at the end\")\nelse:\n    # This will execute because the pattern doesn't match\n    print(\"banana not found at the end\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbanana not found at the end\n```\n:::\n:::\n\n\nYou can use both anchors to require a full-string exact match:\n\n::: {#ef83ad95 .cell execution_count=5}\n``` {.python .cell-code}\n# Check if the entire string is exactly \"abcd\"\n# Using both ^ and $ together checks if the pattern matches the entire string\n# ^ = start anchor, $ = end anchor\nif re.search(r\"^abcd$\", \"abcdef\"):\n    # This won't execute because \"abcdef\" is not exactly \"abcd\"\n    print(\"full match\")\nelse:\n    # This will execute because the pattern doesn't completely match\n    # The string \"abcdef\" has extra characters beyond \"abcd\"\n    print(\"not a full match\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nnot a full match\n```\n:::\n:::\n\n\n## Character Classes\n\nYou can filter based on groups of characters.\n\n::: {#054758e7 .cell execution_count=6}\n``` {.python .cell-code}\n# Loop through a list of sample names\nfor sample in [\"Treatment 1\", \"Treatment 2\", \"Control 1\", \"Control 2\"]:\n    # Search for the pattern \"Treatment\" followed by space and one or more digits\n    # - \\d is a character class that matches any digit\n    # - \\d+ means \"one or more digits\"\n    if re.search(r\"Treatment \\d+\", sample):\n        # This will only print for strings that match our pattern\n        # In this case, \"Treatment 1\" and \"Treatment 2\" will match\n        print(\"found a treatment sample\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfound a treatment sample\nfound a treatment sample\n```\n:::\n:::\n\n\n## Capture Groups\n\nYou can pull out specific pieces of info using capture groups.\n\nIn this example, we have some strings that represent users. The basic format is `name=X;age=Y`. Our goal is to first check if the given string matches this format, and if it does, pull out the name and age values from the string. Here is the regex that we can use to do it:\n\n::: {#ee339928 .cell execution_count=7}\n``` {.python .cell-code}\nuser_info = re.compile(r\"name=(\\w+);age=(\\d+)\")\n```\n:::\n\n\nHere is the break down:\n\n- `\\w+`: at least one word character\n- `(\\w+)`: \"capture\" the group of at least one word character (this represents the name)\n- `name=(\\w+)`: match patterns like `name=Bob`, and extract the name value (`Bob`)\n- `\\d+`: at least one digit character\n- `(\\d+)`: \"capture\" the group of at least one digit (this represents the age)\n- `age=(\\d+)`: match patterns like `age=47`, and extract the age value (`47`)\n- `name=(\\w+);age=(\\d+)`: combines the above name and age pattern and requires that they are separated with a semicolon\n- `re.compile`: compiles the regex so we can use it for matching later\n\nNow, let's use that regex.\n\n::: {#1a18ed3b .cell execution_count=8}\n``` {.python .cell-code}\n# List of user data strings in different formats\nusers = [\"name=Rafael;age=34\", \"NAME=Dev,age:25\", \"name=Page;age=46\"]\n\n# Loop through each user string in the list\nfor user in users:\n    # Apply our regex pattern to search for matches in the current string\n    # re.search() returns a match object if found, None otherwise\n    result = re.search(user_info, user)\n\n    # Check if a match was found\n    if result is not None:\n        # Extract the first capture group (the name)\n        # - This is what matched (\\w+) after \"name=\"\n        # - result[0] would be the entire match,\n        # - result[1] is the first capture group\n        user_name = result[1]\n\n        # Extract the second capture group (the age)\n        # - This is what matched (\\d+) after \"age=\"\n        # - result[2] is the second capture group\n        user_age = result[2]\n\n        # Display the extracted information\n        print(f\"name: {user_name}; age: {user_age}\")\n    else:\n        # If no match was found, show which string failed to match our pattern\n        # This happens with \"NAME=Dev,age:25\" since it uses uppercase and\n        # different format\n        print(f\"no match for {user}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nname: Rafael; age: 34\nno match for NAME=Dev,age:25\nname: Page; age: 46\n```\n:::\n:::\n\n\nWhen we run this code, only the first and third strings match our pattern. The second string uses uppercase \"NAME\" and has a different format (comma and colon instead of semicolon), so it doesn't match our regex pattern.\n\n## Wrap-Up\n\nIn this section, we covered the basics of using regular expressions in Python including, exact matching, anchored matching, character classes, and capture groups. Examples include searching for patterns, validating string formats, and extracting structured data. This should give you just enough info for you to get started using regular expressions in your own work.\n\n",
    "supporting": [
      "A02_regex_files"
    ],
    "filters": [],
    "includes": {}
  }
}