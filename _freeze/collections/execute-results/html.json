{
  "hash": "2a1647d91483291807af784b7de21508",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nauthor: \"Ryan M. Moore, PhD\"\ndate-modified: last-modified\ndate: \"2025-02-11\"\njupyter: python3\n---\n\n# Collections {#sec-collections}\n\nIn this tutorial, we'll explore Python's fundamental data structures and collections -- the building blocks that help organize and analyze biological data effectively. From strings for handling DNA sequences to dictionaries for mapping genes to functions, you'll learn how to use these tools through practical examples. We'll cover when and why to use each type, giving you the foundation needed to tackle real bioinformatics problems.\n\n## Introduction to Python Collections\n\n### What are collections?\n\nCollections in Python are containers that can hold multiple items, and provide convenient ways to store, access, and manipulate groups of related values.\n\nThink of collections like different types of containers:\n\n- A list is like a row of boxes where you can store items in order\n- A tuple is similar but locked/sealed (immutable)\n- A dictionary is like a filing cabinet with labeled folders (keys) containing items (values)\n- A range represents a sequence of numbers stored in an efficient way\n\nCollections let us:\n\n- Group related data together\n- Process multiple items efficiently\n- Organize information in meaningful ways\n- Access data using consistent patterns\n\n### Why we need different data structures\n\nPython provides different collection types because different tasks require different tools. For example:\n\n- If you need to store multiple DNA sequences in order and have fast access to them, use a List\n- If you need to group various pieces of data together and ensure they don't change, use a Tuple\n- If you need to look up protein functions by their names, use a Dictionary\n- If you need to generate sample numbers efficiently, use a Range\n\nUsing the right data structure for the job optimizes both speed and code clarity. As we progress through this tutorial, you'll learn which data structures work best in different situations.\n\n### Common Python Data Structures at a Glance\n\nWe will break down the specifics of each type soon, but let's look first at a quick example of each type:\n\nA list is a mutable, ordered collection of items:\n\n::: {#53adbb11 .cell execution_count=1}\n``` {.python .cell-code}\nnucleotides = [\"A\", \"T\", \"C\", \"G\"]\nprint(nucleotides)\n\n# This is a for loop. We will talk more about them below.\nfor nucleotide in nucleotides:\n    print(nucleotide)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['A', 'T', 'C', 'G']\nA\nT\nC\nG\n```\n:::\n:::\n\n\nA tuple is an immutable, ordered collection of items:\n\n::: {#e0c6e103 .cell execution_count=2}\n``` {.python .cell-code}\n# (name, code, molecular_weight)\nalanine = (\"Alanine\", \"Ala\", 89.1)\nprint(alanine)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n('Alanine', 'Ala', 89.1)\n```\n:::\n:::\n\n\nA dictionary is a mapping from keys to values:\n\n::: {#da7b12b7 .cell execution_count=3}\n``` {.python .cell-code}\n# Dictionary -- key-value pairs (gene id -> function)\ngene_functions = {\n    \"TP53\": \"tumor suppression\",\n    \"BRCA1\": \"DNA repair\",\n    \"INS\": \"insulin production\"\n}\nprint(gene_functions)\n\nfor gene, function in gene_functions.items():\n    print(f\"{gene} => {function}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'TP53': 'tumor suppression', 'BRCA1': 'DNA repair', 'INS': 'insulin production'}\nTP53 => tumor suppression\nBRCA1 => DNA repair\nINS => insulin production\n```\n:::\n:::\n\n\nA range is a representation of a sequence of numbers:\n\n::: {#4ca1f144 .cell execution_count=4}\n``` {.python .cell-code}\n# 96 well plate positions\nsample_ids = range(1, 96)\nprint(sample_ids)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nrange(1, 96)\n```\n:::\n:::\n\n\nNotice that each collection has a dedicated syntax for creating it. This makes it easy to create collections and gives you a visual cue for which collection you're working with.\n\n- Lists are formed using square brackets (`[]`)\n- Tuples are created with parentheses (`()`)\n- Dictionaries use curly brackets (`{}`) and colons (`:`)\n- Ranges are generated by the `range()` function\n\nBeing able to recognize these collection types and know when to use each is critical to both writing and reading code. Let's explore them further.\n\n_Note: Python contains other useful data structures, including [sets](https://docs.python.org/3/tutorial/datastructures.html#sets), but we won't cover them in this tutorial._\n\n## Strings\n\nIn Python, strings are ordered collections of characters, meaning they are sequences that can be indexed, sliced, and iterated over just like other sequence types (such as lists and tuples), with each character being an individual element in the collection.\n\nThough we covered strings in Tutorial 1, let's go over some basics again so that you have it here for easy reference.\n\n### String Literals\n\nIn Python, text data is handled with [str objects](https://docs.python.org/3/library/stdtypes.html#str), or strings. You can build strings with string literals:\n\n::: {#2b8d2cc4 .cell execution_count=5}\n``` {.python .cell-code}\n# With single quotes\n'a string'\n\n# With double quotes\n\"another string\"\n\n# Triple quoted\n\"\"\"Here is a string.\"\"\"\n'''And here is another.'''\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n'And here is another.'\n```\n:::\n:::\n\n\nIf you need to embed quote marks within a string literal, you can do something like this:\n\n::: {#7399cf03 .cell execution_count=6}\n``` {.python .cell-code}\n# Double quote in single quoted string\n'This course is \"fun\", right?'\n\n# Single quote in double quoted string\n\"Of course! It's my favorite class!\"\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n\"Of course! It's my favorite class!\"\n```\n:::\n:::\n\n\nThere are also [escape sequences](https://docs.python.org/3/reference/lexical_analysis.html#escape-sequences) for including different kinds of text inside a string literal. Tabs and newlines are some of the more common escape sequences:\n\n::: {#beda6818 .cell execution_count=7}\n``` {.python .cell-code}\n# Tabs\nprint(\"name\\tage\")\n\n# Newlines\nprint(\"gene 1\\ngene 2\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nname\tage\ngene 1\ngene 2\n```\n:::\n:::\n\n\n### String Methods\n\nIn addition to [common operations](https://docs.python.org/3/library/stdtypes.html#typesseq-common) like indexing, slicing, and concatenation, strings have a rich set of functionality provided by [string methods](https://docs.python.org/3/library/stdtypes.html#string-methods).\n\nA string method is essentially a function that is \"attached\" to a string. Some common string methods are:\n\n- `upper`, `lower` -- Case conversion\n- `strip`, `lstrip`, `rstrip` -- Remove whitespace\n- `split` -- Convert string to list based on delimiter\n- `join` -- Combine list elements into string\n- `replace` -- Replace substring\n- `find`, `index` -- Find substring position\n- `startswith`, `endswith` -- Check string prefixes/suffixes\n- `count` -- Count substring occurrences\n\nLet's go through them now.\n\n#### Case Conversion\n\nThe `upper` and `lower` methods convert strings to uppercase or lowercase. This is useful for standardizing text or making case-insensitive comparisons.\n\n::: {#f4ca31c5 .cell execution_count=8}\n``` {.python .cell-code}\ndna = \"ATCGatcg\"\n\nprint(dna.upper())\nprint(dna.lower())\n\nfragment_1 = \"ACTG\"\nfragment_2 = \"actg\"\n\n# You can convert both sequences to lower case before\n# comparing them for a case-insensitive comparison.\nprint(fragment_1.lower() == fragment_2.lower())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nATCGATCG\natcgatcg\nTrue\n```\n:::\n:::\n\n\n#### Remove Whitespace\n\nThe `strip` method remove whitespace characters (spaces, tabs, newlines). `strip` removes from both ends, while `lstrip` and `rstrip` remove from left or right only. This is particularly useful when cleaning up input data.\n\n::: {#fb50d070 .cell execution_count=9}\n``` {.python .cell-code}\ndna_sequence = \"  ATCG\\n\"\nprint(dna_sequence.strip())\n\ngene_name = \"nrdA    \"\nprint(gene_name.rstrip())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nATCG\nnrdA\n```\n:::\n:::\n\n\n#### Convert String To List\n\nThe `split` method divides a string into a list of substrings based on a delimiter. By default, it splits on whitespace. This is useful for parsing formatted data.\n\n::: {#bb5dd222 .cell execution_count=10}\n``` {.python .cell-code}\nfasta_header = \">sp|P00452|RIR1_ECOLI Ribonucleoside-diphosphate reductase 1\"\nfields = fasta_header.split(\"|\")\nprint(fields)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['>sp', 'P00452', 'RIR1_ECOLI Ribonucleoside-diphosphate reductase 1']\n```\n:::\n:::\n\n\nCheck out this neat trick where Python will let us put the different fields directly into named variables.\n\n::: {#1d3a505b .cell execution_count=11}\n``` {.python .cell-code}\n_, uniprot_id, protein_info = fasta_header.split(\"|\")\n\nprint(f\"{uniprot_id} => {protein_info}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nP00452 => RIR1_ECOLI Ribonucleoside-diphosphate reductase 1\n```\n:::\n:::\n\n\nPretty useful! (We will see more about this in the section on tuples.)\n\n#### Combine List Into String\n\nThe `join` method combines a list of strings into one, using the string it's called on as a delimiter. This is useful for creating formatted output.\n\n::: {#98916b7a .cell execution_count=12}\n``` {.python .cell-code}\namino_acids = [\"Met\", \"Gly\", \"Val\"]\nprotein = \"-\".join(amino_acids)\nprint(protein)\n\nfields = [\"GeneName\", \"Length\", \"Count\"]\ntsv_line = \"\\t\".join(fields)\nprint(tsv_line)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMet-Gly-Val\nGeneName\tLength\tCount\n```\n:::\n:::\n\n\n#### Replace Substring\n\nThe `replace` method substitutes all occurrences of a substring with another. This is helpful for sequence modifications or text cleanup, like turning a DNA string into an RNA string.\n\n::: {#1646dc04 .cell execution_count=13}\n``` {.python .cell-code}\ndna = \"ATCGTTA\"\nrna = dna.replace(\"T\", \"U\")\nprint(rna)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAUCGUUA\n```\n:::\n:::\n\n\n#### Find Substring Position\n\nThe `find` and `index` methods locate the position of a substring. `find` returns `-1` if not found, while `index` raises an error. These are useful for sequence analysis.\n\n::: {#b7ec9d8e .cell execution_count=14}\n``` {.python .cell-code}\nsequence = \"ATCGCTAGCT\"\nposition = sequence.find(\"GCT\")\nprint(position)\n\ntry:\n    position = sequence.index(\"NNN\")\n    print(position)\nexcept ValueError:\n    print(\"not found!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\nnot found!\n```\n:::\n:::\n\n\nDon't worry too much now about this try/except construction for now -- we will cover it in a later tutorial! Basically, it is a way to tell Python that we think an error may occur here, and if it does, what we should do to recover.\n\n#### Check String Prefix/Suffix\n\nThe `startswith` and `endswith` methods check if a string begins or ends with a given substring. These are helpful for parsing user input, or validating sequence patterns and file names.\n\n::: {#8c200392 .cell execution_count=15}\n``` {.python .cell-code}\ngene = \"ATGCCGTAA\"\nprint(gene.startswith(\"ATG\"))\nprint(gene.endswith(\"TAA\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nTrue\n```\n:::\n:::\n\n\n#### Count Substring Occurrences\n\nThe `count` method counts how many times a substring appears in a string. This is useful for sequence analysis and pattern counting.\n\n::: {#01e48e1f .cell execution_count=16}\n``` {.python .cell-code}\ndna = \"ATAGATAGATAG\"\ntag_count = dna.count(\"TAG\")\nprint(tag_count)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n```\n:::\n:::\n\n\n### String Summary\n\nIn Python, strings are immutable sequences of characters (including letters, numbers, symbols, and spaces) that are used to store and manipulate text data. They can be created using single quotes (`''`), double quotes (`\"\"`), or triple quotes (`''' '''` or `\"\"\" \"\"\"`) and support various built-in methods for operations like searching, replacing, splitting, and formatting text.\n\n(For more info about string indexing, slicing, etc., see Tutorial 1.)\n\n## Lists\n\nLists are going to be one of your best friends in Python -- they're flexible, easy to modify, and good for handling biological sequences and experimental data.\n\n### Creating Lists\n\nYou can create lists using square brackets `[]` and assign them to variables. As always, keep in mind best practices for naming variables!\n\n::: {#b6a3cb4a .cell execution_count=17}\n``` {.python .cell-code}\n# A DNA sequence\ndna_sequence = [\"A\", \"T\", \"G\", \"C\", \"T\", \"A\", \"G\"]\n\n# Gene names in a pathway\npathway_genes = [\"TP53\", \"MDM2\", \"CDKN1A\", \"BAX\"]\n\n# Expression values\nexpression_levels = [0.0, 1.2, 3.4, 2.1, 0.8]\n\n# Mixed data types (though it may be best to avoid mixing types like this)\nsample_info = [\"SAMPLE001\", 37.5, \"positive\", True]\n\n# Empty list to fill later\nresults = []\n```\n:::\n\n\nCreating an empty list might seem a bit weird, but is actually common practice in Python -- create an empty list and then use a loop to store multiple things in it. We will see examples of this later in the tutorial.\n\n### List Indexing and Slicing\n\nRemember that a list is like a row of boxes, each with something inside. The boxes are in a particular order and each has a number that you can use to access the data inside (the index).\n\nYou could imagine a list looking something like this:\n\n```\n┌─────┬─────┬─────┬─────┬─────┐\n│ \"A\" │ \"T\" │ \"G\" │ \"A\" │ \"C\" │  (values in the list)\n└─────┴─────┴─────┴─────┴─────┘\n   0     1     2     3     4     (indices of the values)\n```\n\nWhich corresponds to the following Python code:\n\n::: {#70d44385 .cell execution_count=18}\n``` {.python .cell-code}\nnucleotides = [\"A\", \"T\", \"G\", \"A\", \"C\"]\n# index         0    1    2    3    4\n```\n:::\n\n\nDon't forget that Python starts counting with 0 rather than with 1.\n\n_Note: For now, don't worry too much right now about **how** Python stores items in a list. Later in the tutorial, we will adjust our mental model for collections._\n\n#### Indexing\n\nSimilar to strings, you can get specific things out of a list with `list_name[]` syntax, which is sometimes called \"indexing\" the list. The most basic option is to grab items one at time:\n\n::: {#f0fe5c72 .cell execution_count=19}\n``` {.python .cell-code}\n# Get single elements\ndna = \"ATGC\"\nfirst_base = dna[0]\nthird_base = dna[2]\n```\n:::\n\n\nJust like with strings, you can also start indexing from the end of a list. Try to predict the outcome before uncommenting the `print()` statement.\n\n::: {#aab4e770 .cell execution_count=20}\n``` {.python .cell-code}\nmystery_base = dna[-1]\n# print(mystery_base)\n```\n:::\n\n\n#### Slicing\n\nIf you want to get chunks of a list, you can use \"slicing\":\n\n::: {#b4a988ff .cell execution_count=21}\n``` {.python .cell-code}\ndna = \"ACTGactgACTG\"\nfirst_four = dna[0:4]\nmiddle_section = dna[4:8]\n\nprint(first_four)\nprint(middle_section)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nACTG\nactg\n```\n:::\n:::\n\n\nYou can leave off the beginning or the end of a slice as well:\n\n::: {#4fe3a463 .cell execution_count=22}\n``` {.python .cell-code}\ndna = \"ACTGactgGGGG\"\n\n# From index 4 to the end\nprint(dna[4:])\n\n# From the beginning up to index 4, but *excluding* 4.\nprint(dna[:4])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nactgGGGG\nACTG\n```\n:::\n:::\n\n\nSlices can get pretty fancy. Check this out:\n\n::: {#904e7040 .cell execution_count=23}\n``` {.python .cell-code}\ndna = \"AaTtCcGg\"\n\n# Get every other base, starting from the beginning.\nevery_second = dna[::2]\nprint(every_second)\n\n# Get every other base starting from index 1\nevery_other_second = dna[1::2]\nprint(every_other_second)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nATCG\natcg\n```\n:::\n:::\n\n\nThere are quite a few [rules](https://docs.python.org/3/library/stdtypes.html#common-sequence-operations) about slicing, which can get a bit complicated. For this reason, it's generally best to keep your slicing operations as simple as possible.\n\n### List Methods\n\nSimilar to strings, lists come with some methods that let you modify them or get information about them. Some of the most common are:\n\n- `append`\n- `insert`\n- `pop`\n- `sort`\n- `count`\n\nLet's take a look.\n\n#### Adding Items to Lists\n\n::: {#3883ac14 .cell execution_count=24}\n``` {.python .cell-code}\ngenes = [\"TP53\"]\n\n# Adds to the end\ngenes.append(\"BRCA1\")\n\n# Adds at specific position\ngenes.insert(0, \"MDM2\")\n\n# Adds multiple items\ngenes.extend([\"ATM\", \"PTEN\"])\n```\n:::\n\n\nBased on the information in the comments, what does our list look like now? Try to figure that out before running the next code block.\n\n::: {#01f690c2 .cell execution_count=25}\n``` {.python .cell-code}\nprint(genes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['MDM2', 'TP53', 'BRCA1', 'ATM', 'PTEN']\n```\n:::\n:::\n\n\n#### Removing Items from Lists\n\nWe know how to add items now, but what about removing them? There are several ways to do that as well:\n\n::: {#f2613425 .cell execution_count=26}\n``` {.python .cell-code}\ngenes = [\"MDM2\", \"TP53\", \"BRCA1\", \"ATM\", \"PTEN\"]\n\n# Removes by value\ngenes.remove(\"BRCA1\")\nprint(f\"remaining genes: {genes}\")\n\n# Removes and returns last item\nlast_gene = genes.pop()\nprint(f\"last_gene: {last_gene}, remaining genes: {genes}\")\n\n# Removes and returns item at index\nspecific_gene = genes.pop(0)\nprint(f\"specific_gene: {specific_gene}, remaining genes: {genes}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nremaining genes: ['MDM2', 'TP53', 'ATM', 'PTEN']\nlast_gene: PTEN, remaining genes: ['MDM2', 'TP53', 'ATM']\nspecific_gene: MDM2, remaining genes: ['TP53', 'ATM']\n```\n:::\n:::\n\n\nPay attention to `pop` in particular. While `remove` just takes a value out of our list, `pop` removes the item _and_ returns it, which is what allows us to save it to a variable.\n\n#### Other Useful List Methods\n\nThere are many other cool list methods. Here are a few more. Try to guess what the output will be before running the code block.\n\n::: {#40895745 .cell execution_count=27}\n``` {.python .cell-code}\ngenes = [\"MDM2\", \"TP53\", \"BRCA1\", \"ATM\", \"PTEN\", \"TP53\"]\n\ngenes.sort()\nprint(genes)\n\ngenes.reverse()\nprint(genes)\n\nprint(genes.count(\"TP53\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['ATM', 'BRCA1', 'MDM2', 'PTEN', 'TP53', 'TP53']\n['TP53', 'TP53', 'PTEN', 'MDM2', 'BRCA1', 'ATM']\n2\n```\n:::\n:::\n\n\n### List Operations\n\nWe talked about operators in Tutorial 1. These operators can also be applied to lists in various ways. Let's check it out.\n\nSimilar to strings, you can concatenate lists into a single list using `+`:\n\n::: {#10be7832 .cell execution_count=28}\n``` {.python .cell-code}\nforward_primers = [\"ATCG\", \"GCTA\"]\nreverse_primers = [\"TAGC\", \"CGAT\"]\nall_primers = forward_primers + reverse_primers\nprint(all_primers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['ATCG', 'GCTA', 'TAGC', 'CGAT']\n```\n:::\n:::\n\n\nTake a small list a \"multiply\" its components to make a bigger list using `*`:\n\n::: {#408ebb86 .cell execution_count=29}\n``` {.python .cell-code}\n# Creates a poly-A sequence\npoly_a = [\"A\"] * 20\nprint(poly_a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A']\n```\n:::\n:::\n\n\nCheck if something is in a list using `in`:\n\n::: {#12e30af4 .cell execution_count=30}\n``` {.python .cell-code}\ngenes = [\"MDM2\", \"TP53\", \"BRCA1\", \"ATM\", \"PTEN\", \"TP53\"]\n\n# Checking membership\nif \"TP53\" in genes:\n    print(\"TP53 present in our pathway\")\n\nif \"POLA\" in genes:\n    print(\"POLA is not found!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTP53 present in our pathway\n```\n:::\n:::\n\n\nAnd get the length of a list using `len`:\n\n::: {#e240cf3d .cell execution_count=31}\n``` {.python .cell-code}\nsamples = [\"Treatment_1\", \"Control_1\", \"Treatment_2\", \"Control_2\"]\ntotal_samples = len(samples)\nprint(total_samples)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n```\n:::\n:::\n\n\n### Nested Lists\n\nLists can contain other lists, useful for representing things like matrices, graph connections, and simple hierarchical data.\n\n::: {#27c75099 .cell execution_count=32}\n``` {.python .cell-code}\n# Matrix\nsequences = [\n    [\"A\", \"T\", \"G\", \"C\"],\n    [\"G\", \"C\", \"T\", \"A\"],\n    [\"T\", \"A\", \"G\", \"C\"]\n]\nprint(sequences)\n\n# Coordinates\ncoordinates =[\n    [1, 2],\n    [3, 4],\n    [5, 6]\n]\nprint(coordinates)\n\n# Simple hierarchical data: Experimental data with replicates\nexpression_data = [\n    [\"Gene1\", [1.1, 1.2, 1.0]],  # Gene name and replicate values\n    [\"Gene2\", [2.1, 2.3, 1.9]],\n    [\"Gene3\", [0.5, 0.4, 0.6]]\n]\nprint(expression_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[['A', 'T', 'G', 'C'], ['G', 'C', 'T', 'A'], ['T', 'A', 'G', 'C']]\n[[1, 2], [3, 4], [5, 6]]\n[['Gene1', [1.1, 1.2, 1.0]], ['Gene2', [2.1, 2.3, 1.9]], ['Gene3', [0.5, 0.4, 0.6]]]\n```\n:::\n:::\n\n\nMany times, there will be a better solution to your problem than nesting lists in this way, but it's something that you should be aware of should the need arise.\n\nNested lists can be accessed just like regular lists, but there will be more \"layers\" to get through depending on what you want out of them.\n\n::: {#5395429d .cell execution_count=33}\n``` {.python .cell-code}\n# Accessing nested data\n\nfirst_sequence = sequences[0]\nprint(first_sequence)\n\ngene2_rep2 = expression_data[1][1][1]\nprint(gene2_rep2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['A', 'T', 'G', 'C']\n2.3\n```\n:::\n:::\n\n\nLists are very flexible in Python, and so can be complicated. However, it will be good for you to get comfortable with Lists as they are one of the most commonly used data structures!\n\n#### What Does Python Actually Store in the List?\n\nWhen working with lists and other collections in Python, there's a crucial detail about how Python manages data that might seem counterintuitive at first. Let's explore this through a simple example using 2D points.\n\nFirst, let's create some points and store them in a list:\n\n::: {#5f965f99 .cell execution_count=34}\n``` {.python .cell-code}\n# Represent points as [x, y] coordinates\npoint_a = [0, 3]\npoint_b = [1, 2]\n\n# Store points in a list\npoints = [point_a, point_b]\nprint(points)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0, 3], [1, 2]]\n```\n:::\n:::\n\n\nWe can access individual coordinates using nested indexing:\n\n::: {#4135f0c6 .cell execution_count=35}\n``` {.python .cell-code}\n# Get the y-coordinate of the first point\nprint(points[0][1])\n# Get the x-coordinate of the second point\nprint(points[1][0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n1\n```\n:::\n:::\n\n\nNow here's where things get interesting. Let's modify some values:\n\n::: {#c9343bd3 .cell execution_count=36}\n``` {.python .cell-code}\n# Double the y-coordinate of the first point\npoints[0][1] *= 2\nprint(points)\n\n# Now modify the original point_b\npoint_b[0] *= 10\nprint(point_b)\n\n# What do you think our points list looks like now?\nprint(points)\n\n# Also, we modified the first point via the list.\n# What do you think `point_a` variable now contains?\nprint(point_a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0, 6], [1, 2]]\n[10, 2]\n[[0, 6], [10, 2]]\n[0, 6]\n```\n:::\n:::\n\n\nDid the last result surprise you? When we modified `point_b`, the change was reflected in our `points` list too! This happens because Python doesn't actually store the values directly in the list – instead, it stores references (think of them as pointers) to the data. It's like having a directory of addresses rather than copies of the actual data.\n\nUnderstanding this behavior is important because it means changes to your data in one place can unexpectedly affect the same data being used elsewhere in your code.\n\nWith this in mind, we can now update our mental model and make it a bit more accurate. This time, the items in the lists are references that \"point\" to the actual items we care about.\n\n```\n  \"A\"   \"T\"   \"G\"   \"A\"   \"C\"    (items \"in\" the list are objects)\n   ↑     ↑     ↑     ↑     ↑\n┌──┴──┬──┴──┬──┴──┬──┴──┬──┴──┐\n│  ✦  │  ✦  │  ✦  │  ✦  │  ✦  │  (values in the list are references)\n└─────┴─────┴─────┴─────┴─────┘\n   0     1     2     3     4     (indices of the references)\n```\n\nThe diagram for the points example might look something like this:\n\n```\n    0     3       1     2      (items \"in\" the list are numbers)\n    ↑     ↑       ↑     ↑\n ┌──┴──┬──┴──┐ ┌──┴──┬──┴──┐\n │  ✦  │  ✦  │ │  ✦  │  ✦  │   (each element in `points` is also a list)\n └──┬──┴──┬──┘ └──┬──┴──┬──┘\n    ↑     ↑       ↑     ↑\n    └──┬──┘       └──┬──┘\n┌──────┴──────┬──────┴──────┐\n│      ✦      │      ✦      │  (the first level is the `points` list)\n└─────────────┴─────────────┘\n```\n\nFor now, don't get _too_ hung up on the lower-level details -- just be aware of the practical implications mentioned above.\n\n## Loops\n\nSo far, we've worked with two types of collections: lists and strings. But what if you want to work with each element in these collections one at a time? That's where loops come in!\n\nLoops give you a way to automate repetitive tasks. Instead of copying and pasting the same code multiple times to process each item in a list (which would be both tedious and error-prone), loops let you write the instructions once and apply them to every item automatically.\n\nFor example, if you had a list of gene sequences and wanted to check each one for a particular pattern, you wouldn't want to write separate code for each sequence. A loop would let you perform this check systematically across your entire dataset.\n\nPython offers several different types of loops, each suited for particular situations. In this section we will focus on for loops and while loops.\n\n### For Loops\n\nA for loop processes each item in a sequence, one at a time. Think of it like going through a list and looking at each item one at a time:\n\n::: {#581616da .cell execution_count=37}\n``` {.python .cell-code}\nfor letter in [\"D\", \"N\", \"A\"]:\n    print(letter)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nD\nN\nA\n```\n:::\n:::\n\n\nLet's break that down:\n\n1. `for` -- tells Python we want to start a loop\n2. `letter` -- a variable that will hold each item\n3. `in [\"D\", \"N\", \"A\"]` -- tells Python to loop through the list `[\"D\", \"N\", \"A\"]`\n4. `:` -- marks the beginning of the code block to be executed\n5. The indented code (`print(letter)`) runs once for each item\n\nNote that `for` and `in` are specifically required in for loop syntax. `letter` and `[\"D\", \"N\", \"A\"]` will change depending on the context.\n\nFor example, this loop has the same behavior as the previous loop:\n\n::: {#c27a0636 .cell execution_count=38}\n``` {.python .cell-code}\nletters = [\"D\", \"N\", \"A\"]\nfor the_letter in letters:\n    print(the_letter)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nD\nN\nA\n```\n:::\n:::\n\n\nThis time, we used a different variable name to store the items of the collection, and rather than putting the collection directly in the `for ... in ... :` part, we referred to the collection using a variable.\n\nIn addition to lists, for loops also work on strings:\n\n::: {#4298d2dc .cell execution_count=39}\n``` {.python .cell-code}\nnucleotides = \"ATCG\"\nfor nucleotide in nucleotides:\n    print(f\"The nucleotide was '{nucleotide}'\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe nucleotide was 'A'\nThe nucleotide was 'T'\nThe nucleotide was 'C'\nThe nucleotide was 'G'\n```\n:::\n:::\n\n\nYou can actually use for loops on lots of different Python data structures: as long as it is [iterable](https://docs.python.org/3/glossary.html#term-iterable), then you can use a for loop with it.\n\nOften you will want to take some action multiple times. For this, we can use `range`:\n\n::: {#a5164854 .cell execution_count=40}\n``` {.python .cell-code}\nfor number in range(5):\n    print(number)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n3\n4\n```\n:::\n:::\n\n\nThis should have printed 5 numbers: 0, 1, 2, 3, 4. Here is Python counting from zero again!\n\nYou can also tell range where to start and stop:\n\n::: {#e7a08252 .cell execution_count=41}\n``` {.python .cell-code}\n# Count from 1 to 5\nfor number in range(1, 6):\n    print(number)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n4\n5\n```\n:::\n:::\n\n\nHere is a neat thing you can do with ranges. Before running the code, could you guess what it might do?\n\n::: {#92500953 .cell execution_count=42}\n``` {.python .cell-code}\nfor i in range(2, 10, 2):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n4\n6\n8\n```\n:::\n:::\n\n\nLet's break down what's happening with `range` here. While we've seen `range` create simple sequences of numbers before, it can actually take up to three arguments: `range(start, stop, step)`. The `step` tells Python how many numbers to count by each time.\n\nIt's like counting: normally we count \"1, 2, 3, 4...\" (step of 1), but sometimes we count \"2, 4, 6, 8...\" (step of 2). In this example, we're using a step of 2 to skip every other number.\n\nThe `start` and `step` arguments are optional -- you can just use `range(stop)` if you want to count normally starting from zero. If you're curious about more advanced uses, like counting backwards or working with negative numbers, check out the Python [range docs](https://docs.python.org/3/library/stdtypes.html#range) for more details.\n\nRanges are memory efficient -- they don't store all the numbers in the range in memory. This is important when generating large batches of numbers.\n\n(This code shouldn't be run. It's just here to illustrate the point.)\n\n```python\nbig_range = range(1, 1000000)  # Takes very little memory\nbig_list = list(big_range)     # Takes much more memory!\n```\n\n#### Nested For Loops\n\nOne feature of for loops is that you can put one inside another -- something we call \"nesting\". Think of it like those Russian nesting dolls, where each doll contains a smaller one inside.\n\n::: {#4ad4cdb2 .cell execution_count=43}\n``` {.python .cell-code}\nfor i in range(2):\n    for j in range(3):\n        print(f\"i: {i}; j: {j}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ni: 0; j: 0\ni: 0; j: 1\ni: 0; j: 2\ni: 1; j: 0\ni: 1; j: 1\ni: 1; j: 2\n```\n:::\n:::\n\n\nLet's break down what's happening here. The outer loop (using `i`) runs two times (0, 1), and for _each_ of those times, the inner loop (using `j`) runs three times (0, 1, 2). It's a bit like having a set of drawers where you check each drawer (outer loop), and within each drawer, you look at every item inside (inner loop).\n\nWhen you run the above code, you'll see each combination of `i` and `j` printed out, showing how the loops work together. This pattern of nested loops is incredibly useful when you need to process data that has multiple levels or dimensions, for example, like comparing every gene in one dataset to every gene in another dataset.\n\nHere is a schematic view:\n\n```\n┌──────────────────────────────────────────────┐\n│ i=0                                          │\n│ ┌────────────┐ ┌────────────┐ ┌────────────┐ │\n│ │ j=0        │ │ j=1        │ │ j=2        │ │\n│ │            │ │            │ │            │ │\n│ │ print(...) │ │ print(...) │ │ print(...) │ │\n│ └────────────┘ └────────────┘ └────────────┘ │\n└──────────────────────────────────────────────┘\n\n┌──────────────────────────────────────────────┐\n│ i=1                                          │\n│ ┌────────────┐ ┌────────────┐ ┌────────────┐ │\n│ │ j=0        │ │ j=1        │ │ j=2        │ │\n│ │            │ │            │ │            │ │\n│ │ print(...) │ │ print(...) │ │ print(...) │ │\n│ └────────────┘ └────────────┘ └────────────┘ │\n└──────────────────────────────────────────────┘\n```\n\nYou can have more than two levels of nesting. For example:\n\n::: {#03f0bb8d .cell execution_count=44}\n``` {.python .cell-code}\nfor i in range(2):\n    for j in range(3):\n        for k in range(4):\n            print(f\"i: {i}; j: {j}; k: {k}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ni: 0; j: 0; k: 0\ni: 0; j: 0; k: 1\ni: 0; j: 0; k: 2\ni: 0; j: 0; k: 3\ni: 0; j: 1; k: 0\ni: 0; j: 1; k: 1\ni: 0; j: 1; k: 2\ni: 0; j: 1; k: 3\ni: 0; j: 2; k: 0\ni: 0; j: 2; k: 1\ni: 0; j: 2; k: 2\ni: 0; j: 2; k: 3\ni: 1; j: 0; k: 0\ni: 1; j: 0; k: 1\ni: 1; j: 0; k: 2\ni: 1; j: 0; k: 3\ni: 1; j: 1; k: 0\ni: 1; j: 1; k: 1\ni: 1; j: 1; k: 2\ni: 1; j: 1; k: 3\ni: 1; j: 2; k: 0\ni: 1; j: 2; k: 1\ni: 1; j: 2; k: 2\ni: 1; j: 2; k: 3\n```\n:::\n:::\n\n\nThough I bet you know what's going on with nested loops by now, let's break it down anyway. The innermost loop (`k`) completes all its iterations before the middle loop (`j`) counts up once, and the middle loop completes all its iterations before the outer loop (`i`) counts up once. In this example, for each value of `i`, we'll go through all values of `j`, and for each of those, we'll go through all values of `k`.\n\nRemember that each additional level of nesting multiplies the number of iterations. In our example, we have 2 × 3 × 4 = 24 total iterations. Keep this in mind when working with larger datasets.\n\n#### Enumerated for Loops\n\nSometimes when you're working with a sequence, you need to know not just what each item is, but also where it appears. That's where Python's handy `enumerate` function comes in. It lets you track both the position (index) and the value of each item as you loop through them.\n\nHere's a simple example:\n\n::: {#ae517c6f .cell execution_count=45}\n``` {.python .cell-code}\nfor index, letter in enumerate(\"ABCDE\"):\n    print(f\"index: {index}; letter: {letter}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nindex: 0; letter: A\nindex: 1; letter: B\nindex: 2; letter: C\nindex: 3; letter: D\nindex: 4; letter: E\n```\n:::\n:::\n\n\nThis will show you each letter along with its position in the sequence, starting from 0 (remember, Python always starts counting at 0!).\n\nBy the way, you can also use `enumerate` outside of loops. For instance, if you have a list of nucleotides:\n\n::: {#c0d7a89d .cell execution_count=46}\n``` {.python .cell-code}\nnucleotides = [\"A\", \"C\", \"T\", \"G\"]\nenumerated_nucleotides = enumerate(nucleotides)\nprint(list(enumerated_nucleotides))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[(0, 'A'), (1, 'C'), (2, 'T'), (3, 'G')]\n```\n:::\n:::\n\n\nThis creates pairs of positions and values, which can be useful, say, when you need to track where certain elements appear in your sequence data.\n\n### While Loops\n\nWhile loops keep repeating until the given condition is not true (or truthy). Let's look at a simple example that counts from 1 to 5:\n\n::: {#badfd219 .cell execution_count=47}\n``` {.python .cell-code}\ncount = 1\nwhile count <= 5:\n    print(count)\n    count += 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n4\n5\n```\n:::\n:::\n\n\nTo understand what this loop does, imagine it following a simple set of instructions:\n\n- Create a variable called `count` and set it to 1.\n- Then, keep doing these steps as long as `count` is less than or equal to 5:\n  - Display the current value of `count`\n  - Add 1 to `count`.\n\nThe loop will keep running until `count` becomes 6, at which point the condition `count <= 5` becomes false, and the loop stops.\n\nJust to make it super clear, let's write out the steps:\n\n1. `count = 1`: is count <= 5? Yes! prints 1, then adds 1\n2. `count = 2`: is count <= 5? Yes! prints 2, then adds 1\n3. `count = 3`: is count <= 5? Yes! prints 3, then adds 1\n4. `count = 4`: is count <= 5? Yes! prints 4, then adds 1\n5. `count = 5`: is count <= 5? Yes! prints 5, then adds 1\n6. `count = 6`: is count <= 5? No! stops because 6 is not <= 5\n\n#### Infinite Loops and Other Problems\n\nWhen working with while loops, it's crucial to ensure your loop has a way to end. Think of it like setting up an automated process -- you need a clear stopping point, or the process will run forever!\n\nThere are two common pitfalls to watch out for:\n\n1. If your condition is never true to begin with, the loop won't run at all\n2. If your condition can never become false, the loop will run forever (called an _infinite loop_)\n\nHere's an example of the 2nd problem. Can you figure out why this code would run forever?\n\n```python\n# Infinite loop -- DO NOT RUN!!\ncount = 1\nwhile count >= 0:\n    print(count)\n    count = count + 1\n```\n\nLet's think through what's happening:\n\n- We start with `count = 1`\n- The loop continues as long as `count` is greater than or equal to 0\n- Each time through the loop, we're adding 1 to `count`\n- So `count` keeps getting bigger: 1, 2, 3, 4, 5...\n- But wait! A number that keeps getting bigger will always be greater than 0\n- This means our condition (`count >= 0`) will always be true, and the loop will never end!\n\nWhen writing your own loops, always be sure that your condition will eventually become false -- you need a clear endpoint!\n\n### Modifying a List While Looping\n\nOne tricky aspect of using loops in Python occurs if you try to modify a collection while looping over it.\n\nWith a while loop and the `pop` method, it's not too weird -- you run the while loop until the list is empty:\n\n::: {#45e10ce2 .cell execution_count=48}\n``` {.python .cell-code}\n# Starting with a list of tasks\ntodo_list = [\"task1\", \"task2\", \"task3\"]\n\nwhile todo_list:  # This is true as long as the list has items\n    current_task = todo_list.pop()  # removes and returns last item\n    print(f\"Doing task: {current_task}\")\n\nprint(\"All tasks complete!\")\nprint(todo_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDoing task: task3\nDoing task: task2\nDoing task: task1\nAll tasks complete!\n[]\n```\n:::\n:::\n\n\nHowever, things can get quite weird with for loops:\n\n::: {#89cb0b38 .cell execution_count=49}\n``` {.python .cell-code}\n# This is probably not what you want!\nnumbers = [1, 2, 3, 4, 5]\nfor number in numbers:\n    numbers.remove(number)  # Don't do this!\nprint(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 4]\n```\n:::\n:::\n\n\nUnfortunately, that did not remove all the items from `numbers` like you may have expected.\n\nOne way to address this issue is to use `[:]` to create a copy of `numbers` and iterate over _that_ collection. Meanwhile, you remove items from the original `numbers`.\n\n::: {#b80139f7 .cell execution_count=50}\n``` {.python .cell-code}\nnumbers = [1, 2, 3, 4, 5]\nfor number in numbers[:]:  # The [:] creates a copy\n    numbers.remove(number)\n    print(f\"Removed {number}. List is now: {numbers}\")\nprint(f\"at the end: {numbers}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRemoved 1. List is now: [2, 3, 4, 5]\nRemoved 2. List is now: [3, 4, 5]\nRemoved 3. List is now: [4, 5]\nRemoved 4. List is now: [5]\nRemoved 5. List is now: []\nat the end: []\n```\n:::\n:::\n\n\nReally, this example is pretty artificial -- you wouldn't be trying to delete every item in a list with a for loop anyway. Just be aware that if you modify a collection during a loop, special care must be taken to ensure that you don't mess things up.\n\n_Take note of this for miniproject 1 -- you will \"probably\" have to remove some items from a list to complete it! But don't worry, you will see some more examples in the project description...._\n\n### Comprehensions\n\nWhile we are on the topic of loops, let's discuss one more thing: Comprehensions.\n\nComprehensions let you create new lists (and other collections) from existing lists (and other collections).\n\nLet's say that you want to create a list of RNA bases and you've already made a list of DNA bases. One way to do this would be to take your existing list and convert any Thymines (T) to Uracils (U). We can do this with a traditional for loop:\n\n::: {#35318611 .cell execution_count=51}\n``` {.python .cell-code}\n# Using traditional loop\ndna = [\"A\", \"T\", \"G\", \"C\"]\nrna = []\nfor base in dna:\n    if base != \"T\":\n        rna.append(base)\n    else:\n        rna.append(\"U\")\n\nprint(rna)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['A', 'U', 'G', 'C']\n```\n:::\n:::\n\n\nOr with a comprehension:\n\n::: {#8a4e0165 .cell execution_count=52}\n``` {.python .cell-code}\ndna = \"ATGC\"\nrna = [\"U\" if base == \"T\" else base for base in dna]\nprint(rna)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['A', 'U', 'G', 'C']\n```\n:::\n:::\n\n\nThe comprehension is much more concise! The list comprehension is doing everything that the traditional for loop is doing, but in a single line.\n\nThe basic structure of a comprehension can be broken down into these components:\n\n```python\nnew_list = [expression for item in iterable if condition]\n```\n\nBreaking it down:\n\n- `new_list`: The resulting list\n- `expression`: What you want to do with each item (like transform it)\n- `for item in iterable`: The loop over some iterable object\n- `if condition`: Optional filter (you can leave this out)\n\nNote that in our original example, the `if` condition actually came before the `for` loop part -- that's allowed!\n\nComprehensions are definitely weird at first! Let's look at some more examples.\n\nHere is a basic example using `range` instead of an existing list:\n\n::: {#bc7860ed .cell execution_count=53}\n``` {.python .cell-code}\nsquares = [x**2 for x in range(5)]\nprint(squares)\n\n# Same as:\nsquares = []\nfor x in range(5):\n    squares.append(x**2)\n\nprint(squares)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 1, 4, 9, 16]\n[0, 1, 4, 9, 16]\n```\n:::\n:::\n\n\nThis example takes each number in the list produced by `range(5)`, squares it, and adds it to the new list `squares`. In this case:\n\n- `squares` is the `new_list`\n- `x**2` is the `expression`\n- `x` is the `item` and `range(5)` is the `iterable`\n- There is no `if condition`\n\nNotice that you don't have to initialize an empty list for the comprehension to work -- it makes the list itself, unlike with a for loop.\n\nLet's look at an example with a condition:\n\n::: {#f8342ed6 .cell execution_count=54}\n``` {.python .cell-code}\n# Using comprehension\nexpressions = [1.2, 0.5, 3.4, 0.1, 2.2]\nhigh_expression = [x for x in expressions if x > 2.0]\nprint(high_expression)\n\n# Using a for loop\nexpressions = [1.2, 0.5, 3.4, 0.1, 2.2]\nhigh_expression = []\nfor x in expressions:\n    if x > 2.0:\n        high_expression.append(x)\nprint(high_expression)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[3.4, 2.2]\n[3.4, 2.2]\n```\n:::\n:::\n\n\nIn this example, we take an existing list, `expressions`, and make a new list, `high_expressions`, that contains only the expressions that are 2.0 or greater.\n\nNotice that in this example, there is nothing done to the existing items in the list before adding them to the new one, which is why the comprehension starts with `x for x`.\n\nComprehensions can also be used to create dictionaries. Check this out:\n\n::: {#cba22e62 .cell execution_count=55}\n``` {.python .cell-code}\nsquares = {x: x**2 for x in range(5)}\nprint(squares)\n\neven_squares = {x: x**2 for x in range(5) if x % 2 == 0}\nprint(even_squares)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\n{0: 0, 2: 4, 4: 16}\n```\n:::\n:::\n\n\nThat is pretty neat right?\n\nWhile comprehensions are compact, whether or not you think this conciseness leads to better code is a different story. As you gain more experience, you will get a better feel for such things. Whether you use them a lot or a little, you should be aware of them as they are quite common in Python codebases.\n\n## Tuples\n\nTuples are like lists that can't be changed -- perfect for storing fixed information. We often use tuples when we want to ensure data integrity or represent relationships that shouldn't change.\n\n### Creating Tuples\n\nTuples have a dedicated syntax used for construction:\n\n::: {#665bd616 .cell execution_count=56}\n``` {.python .cell-code}\nletters = (\"a\", \"b\", \"c\")\n\n# Single item tuples still need a comma!\nnumber = (1, )\n```\n:::\n\n\nThe syntax for creating a tuple is not that different from creating a list, but you'll notice differences when trying to alter their components. For example, the following code would raise an error if we didn't put the `try/except` around it:\n\n::: {#f78785a3 .cell execution_count=57}\n``` {.python .cell-code}\nletters = (\"a\", \"b\", \"c\")\n\ntry:\n    letters[0] = \"d\"\nexcept TypeError:\n    print(\"you can't assign to a tuple\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nyou can't assign to a tuple\n```\n:::\n:::\n\n\nIf `letters` was a list, the above code would change the list to start with `d` instead of `b`. Instead, we got an error. This is because tuples are _immutable_.\n\nWhether some data is mutable or immutable determines whether you can modify it or not. Here is a silly metaphor to illustrate what I mean:\n\n- **Mutable** collections (like lists and dictionaries) are like erasable whiteboards -- you can add, remove, or change items whenever you need to\n- **Immutable** collections (like tuples) are more like carved stone tablets -- once created, their contents are \"set in stone\"\n\nWhy does this matter? Here are two practical implications:\n\n- **Data Safety**: Immutable collections help prevent accidental changes to important data\n  - Remember how we could modify individual coordinates in our list earlier? If we had used tuples instead, Python would have prevented any accidental modifications\n- **Technical Requirements**: Some Python features, like using values as dictionary keys (which we'll explore soon), only work with immutable data types\n\nTuples excel at representing fixed relationships between values that logically belong together. Think of them as a way to package related information that you know shouldn't change during your program's execution.\n\nE.g., our coordinates example from above could be better written with a tuple:\n\n::: {#27359c40 .cell execution_count=58}\n``` {.python .cell-code}\n# (x, y)\npoint = (1, 2)\nprint(point)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(1, 2)\n```\n:::\n:::\n\n\nOr, you could represent facts about a codon as a tuple:\n\n::: {#1260b3a5 .cell execution_count=59}\n``` {.python .cell-code}\nmethionine = (\"Methionine\", \"Met\", \"M\", \"ATG\")\nprint(methionine)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n('Methionine', 'Met', 'M', 'ATG')\n```\n:::\n:::\n\n\nOr, you could represent related gene information:\n\n::: {#32446d4f .cell execution_count=60}\n``` {.python .cell-code}\ngene_info = (\"BRCA1\",     # gene name\n             \"chr17\",     # chromosome\n             43044295,    # start position\n             43125364,    # end position\n             \"plus\")      # strand\nprint(gene_info)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n('BRCA1', 'chr17', 43044295, 43125364, 'plus')\n```\n:::\n:::\n\n\n### Tuple Packing and Unpacking\n\nLet's look at two really useful Python features that make working with multiple values easier: tuple packing and unpacking.\n\nTuple packing is pretty straightforward -- Python can automatically bundle multiple values into a tuple for you. Here's an example using a codon and its properties:\n\n::: {#58f99ddb .cell execution_count=61}\n``` {.python .cell-code}\n# Packing values into a tuple\ncodon = \"AUG\", \"Methionine\", \"Start\"\nprint(codon)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n('AUG', 'Methionine', 'Start')\n```\n:::\n:::\n\n\nThe opposite operation, tuple unpacking, lets you smoothly assign tuple elements to separate variables:\n\n::: {#fab385ed .cell execution_count=62}\n``` {.python .cell-code}\n# Unpacking a tuple into individual variables\ncodon = (\"AUG\", \"Methionine\", \"Start\")\nsequence, amino_acid, role = codon\n\nprint(f\"Codon: {sequence}; Amino Acid: {amino_acid}; Role: {role}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCodon: AUG; Amino Acid: Methionine; Role: Start\n```\n:::\n:::\n\n\nOne of the coolest applications of packing and unpacking is swapping values between variables. Check this out:\n\n::: {#680256ed .cell execution_count=63}\n``` {.python .cell-code}\n# Set initial values\nx, y = 1, 2\n\n# Print the original values\nprint(f\"x: {x}; y: {y}\")\n\n# Swap values in one clean line\nx, y = y, x\n\n# Print the swapped values\nprint(f\"x: {x}; y: {y}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx: 1; y: 2\nx: 2; y: 1\n```\n:::\n:::\n\n\nTo appreciate how nice this is, here's how you'd typically swap values in many other programming languages:\n\n::: {#6ffa685a .cell execution_count=64}\n``` {.python .cell-code}\nx = 1\ny = 2\n\n# Print the original values\nprint(f\"x: {x}; y: {y}\")\n\n# The traditional way requires a temporary variable\ntmp = y\ny = x\nx = tmp\n\n# Print the swapped values\nprint(f\"x: {x}; y: {y}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx: 1; y: 2\nx: 2; y: 1\n```\n:::\n:::\n\n\nPython's packing and unpacking syntax makes this common operation more intuitive and readable. Instead of juggling a temporary variable, you can swap values in a single, clear line of code. This is just one example of how Python's design choices can make your code both simpler to write and easier to understand.\n\n### Named Tuples\n\nYou may be thinking that it could get tricky to remember which field of a tuple is which. [Named tuples](https://docs.python.org/3/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields) provide a great way to address this. They're like regular tuples, but with the added benefit of letting you create them and access data using descriptive names instead of index numbers.\n\nLet's see how they work:\n\n::: {#0d30d8ca .cell execution_count=65}\n``` {.python .cell-code}\n# We need to import namedtuple from the collections module\nfrom collections import namedtuple\n\n# Create a Gene type with labeled fields\n# (note the name is Gene and not gene)\nGene = namedtuple(\"Gene\", \"name chromosome start stop\")\n\n# Create a specific gene entry\n#\n# Using named arguments can keep you from mixing up the arguments!\ntp53 = Gene(\n    name=\"TP53\",\n    chromosome=\"chr17\",\n    start=7_571_720,\n    stop=7_590_868,\n)\n\n# Access the data using meaningful names\nprint(tp53.name)\nprint(tp53.chromosome)\n\n# You can still unpack it like a regular tuple if you want\nname, chromosome, start, stop = tp53\nprint(name, chromosome, start, stop)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTP53\nchr17\nTP53 chr17 7571720 7590868\n```\n:::\n:::\n\n\nWhat makes named tuples great?\n\n- They're clear and self-documenting -- the labels tell you exactly what each value means\n- They're less prone to errors -- no more mixing up whether position 2 was start or stop\n- They're efficient and unchangeable (immutable), just like regular tuples\n\nFor example, you can't change values after creation:\n\n::: {#ea73c6fb .cell execution_count=66}\n``` {.python .cell-code}\ntry:\n    tp53.start = 1300  # This will raise an error\nexcept AttributeError:\n    print(\"you can't do this!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nyou can't do this!\n```\n:::\n:::\n\n\nNamed tuples are perfect for representing any kind of structured data. Here's another example using DNA sequences:\n\n::: {#41f107e2 .cell execution_count=67}\n``` {.python .cell-code}\nSequence = namedtuple(\"Sequence\", \"id dna length gc_content\")\n\n# Create some sequence records\nseq1 = Sequence(\"SEQ1\", \"GGCTAA\", length=6, gc_content=0.5)\nseq2 = Sequence(\"SEQ2\", \"GGTTAA\", length=6, gc_content=0.33)\n\n# Named tuples print out nicely too\nprint(seq1)  # Shows all fields with their values\nprint(seq2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSequence(id='SEQ1', dna='GGCTAA', length=6, gc_content=0.5)\nSequence(id='SEQ2', dna='GGTTAA', length=6, gc_content=0.33)\n```\n:::\n:::\n\n\nI have mentioned a few times now that tuples are immutable, and named tuples are as well. There is a way to get an modified copy of a named tuple however:\n\n::: {#35f2ba91 .cell execution_count=68}\n``` {.python .cell-code}\nseq1 = Sequence(\"SEQ1\", \"GGCTAA\", length=6, gc_content=0.5)\n\nseq1_with_new_id = seq1._replace(id=\"sequence 1\")\n\n# The original seq1 is unchanged:\nprint(seq1)\n\n# The new one has the same values as the original other than the id\nprint(seq1_with_new_id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSequence(id='SEQ1', dna='GGCTAA', length=6, gc_content=0.5)\nSequence(id='sequence 1', dna='GGCTAA', length=6, gc_content=0.5)\n```\n:::\n:::\n\n\nThe bottom line: When you need to bundle related data together, named tuples are often a great choice. They're essentially as lightweight as regular tuples, but they make your code much easier to read and maintain. Think of them as regular tuples with the added bonus of built-in documentation!\n\n### When to Use Tuples vs. Lists\n\nIt may still be unclear when to choose tuples rather than lists. While you will get a feel for it over time, here are some guidelines that can help you choose:\n\n**Choose a Tuple When:**\n\n- Your data represents an inherent relationship that won't change (like a DNA sequence's start and end coordinates)\n- You want to make sure your data stays protected from accidental modifications\n- You need to use the data as a dictionary key (we'll explore this more soon)\n- You're returning multiple related values from a function\n\n**Choose a List When:**\n\n- You'll need to add or remove items as your program runs\n- Your data needs to be flexible and modifiable\n- You're accumulating or building up data throughout your program\n\nOne way to think of it is: if you're working with data that should remain constant, reach for a tuple. If you need something more flexible that can grow or change (like collecting results), a list is your better choice.\n\nHere is a nice section of the Python docs if you want to dive deeper: [Why are there separate tuple and list data types?](https://docs.python.org/3/faq/design.html#why-are-there-separate-tuple-and-list-data-types)\n\n## Dictionaries\n\nDictionaries in Python are a bit like address books. Just as you can look up someone's phone number using their name, dictionaries let you pair up pieces of information so you can easily find one when you know the other. The first part (like the person's name) is called the _key_, and it leads you to the second part (like their phone number), which is called the _value_.\n\nLet's say you want to keep track of gene names and their functions. Instead of scanning through a long list every time, a dictionary lets you jump straight to the function just by knowing the gene name. They are a great way to organize and retrieve your data quickly.\n\n### Creating Dictionaries\n\n#### Dictionary Literals (`{}`)\n\nThe most straightforward way to create dictionaries is using curly brackets `{}` with `key: value` pairs:\n\n::: {#2c617806 .cell execution_count=69}\n``` {.python .cell-code}\ncodon_table = {\n    \"AUG\": \"Met\",\n    \"UAA\": \"Stop\",\n    \"UAG\": \"Stop\",\n    \"UGA\": \"Stop\"\n}\n\nprint(codon_table)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'AUG': 'Met', 'UAA': 'Stop', 'UAG': 'Stop', 'UGA': 'Stop'}\n```\n:::\n:::\n\n\n#### `dict` Function\n\nYou can also create dictionaries using the `dict()` function, which is particularly nice when you have simple string keys:\n\n::: {#86632e99 .cell execution_count=70}\n``` {.python .cell-code}\ngene = dict(gene=\"nrdA\", product=\"ribonucleotide reductase\")\nprint(gene)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'gene': 'nrdA', 'product': 'ribonucleotide reductase'}\n```\n:::\n:::\n\n\n#### `dict` + `zip`\n\nHere's a handy trick: if you have two separate lists that you want to pair up into a dictionary, you can use [`zip`](https://docs.python.org/3/library/functions.html#zip) with `dict`:\n\n::: {#29ef0209 .cell execution_count=71}\n``` {.python .cell-code}\ngenes = [\"TP53\", \"BRCA1\", \"KRAS\"]\nfunctions = [\"tumor suppressor\", \"DNA repair\", \"signal transduction\"]\n\ngene_functions = dict(zip(genes, functions))\n\nprint(gene_functions)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'TP53': 'tumor suppressor', 'BRCA1': 'DNA repair', 'KRAS': 'signal transduction'}\n```\n:::\n:::\n\n\nThe order matters when using `zip` -- the first list provides the keys, and the second list provides the values:\n\n::: {#30fc32ea .cell execution_count=72}\n``` {.python .cell-code}\n# Switching the order gives us a different dictionary\nmysterious_dictionary = dict(zip(functions, genes))\nprint(mysterious_dictionary)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'tumor suppressor': 'TP53', 'DNA repair': 'BRCA1', 'signal transduction': 'KRAS'}\n```\n:::\n:::\n\n\n#### One Entry at a Time\n\nYou can also built up dictionaries one value at a time. Here's a common real-world scenario: you're reading data from a file and need to build a dictionary as you go.\n\nFor this example, imagine that `lines` came from parsing a file rather than being hardcoded.\n\n::: {#9c7ae0b6 .cell execution_count=73}\n``` {.python .cell-code}\n# This could be data from a file\nlines = [\n    [\"TP53\", \"tumor suppressor\"],\n    [\"BRCA1\", \"DNA repair\"],\n    [\"KRAS\", \"signal transduction\"],\n]\n\n# Start with an empty dictionary\ngene_functions = {}\n\n# Add each item to the dictionary\nfor gene_name, function in lines:\n    gene_functions[gene_name] = function\n\nprint(gene_functions)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'TP53': 'tumor suppressor', 'BRCA1': 'DNA repair', 'KRAS': 'signal transduction'}\n```\n:::\n:::\n\n\nThis pattern of building a dictionary piece by piece is something you'll use frequently when working with real data. It's especially useful when processing files or API responses where you don't know the contents ahead of time.\n\n#### Duplicate Keys & Values\n\nA few important things to know about dictionaries:\n\n- Values can be repeated (the same value can appear multiple times)\n- Keys must be unique (if you try to use the same key twice, [only the last value will be kept](https://docs.python.org/3/reference/datamodel.html#dictionaries))\n\nHere's an example showing both of these properties:\n\n::: {#966c91b3 .cell execution_count=74}\n``` {.python .cell-code}\n# Values can be repeated\nprint(dict(a=\"apple\", b=\"banana\", c=\"apple\"))\n\n# Only the last value for a repeated key is kept\ncodons = {\n    \"AUG\": \"Met\",\n    \"UAA\": \"Stop\",\n    \"UAG\": \"Stop\",\n    \"UGA\": \"Stop\",\n    \"AUG\": \"Methionine\",  # This will override the first AUG entry\n}\nprint(codons)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'a': 'apple', 'b': 'banana', 'c': 'apple'}\n{'AUG': 'Methionine', 'UAA': 'Stop', 'UAG': 'Stop', 'UGA': 'Stop'}\n```\n:::\n:::\n\n\n### Working with Dictionaries: Getting, Adding, and Removing Items\n\nLet's see the basics of working with dictionaries in Python. We'll continue with our `gene_functions` dictionary from earlier:\n\n::: {#713dca26 .cell execution_count=75}\n``` {.python .cell-code}\ngenes = [\"TP53\", \"BRCA1\", \"KRAS\"]\nfunctions = [\"tumor suppressor\", \"DNA repair\", \"signal transduction\"]\ngene_functions = dict(zip(genes, functions))\nprint(gene_functions)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'TP53': 'tumor suppressor', 'BRCA1': 'DNA repair', 'KRAS': 'signal transduction'}\n```\n:::\n:::\n\n\n#### Getting Items from a Dictionary {#sec-get-items-dict}\n\nThe most basic way to look up information in a dictionary is similar to how you'd look up a word in a real dictionary: you use the key to find the value. In Python, this means using square brackets:\n\n::: {#48584665 .cell execution_count=76}\n``` {.python .cell-code}\n# Looking up a value\np53_function = gene_functions[\"TP53\"]\nprint(p53_function)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntumor suppressor\n```\n:::\n:::\n\n\nTrying to find a key that doesn't exist will cause an error. (Again, we wrap the code that will cause an error in a `try/except` block so that it doesn't break our notebook code.)\n\n::: {#27a2c4ba .cell execution_count=77}\n``` {.python .cell-code}\ntry:\n    gene_functions[\"apple pie\"]\nexcept KeyError:\n    print(\"there is no gene called 'apple pie'\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthere is no gene called 'apple pie'\n```\n:::\n:::\n\n\nThere is an alternative way to get info from a dictionary that will not raise an error if the key you're searching for is not found: `get`.\n\n::: {#16b560c6 .cell execution_count=78}\n``` {.python .cell-code}\n# This will return `None` rather than raise an error\n# if the key is not found\nresult = gene_functions.get(\"BRCA2\")\nprint(result)\n\n# This will return the value \"Unknown\"\n# if the key is not found\nresult = gene_functions.get(\"BRCA2\", \"Unknown\")\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNone\nUnknown\n```\n:::\n:::\n\n\n#### Adding Items to a Dictionary\n\nWe mentioned that dictionaries are mutable. Let's see how to add items to our dictionary. You can either add items one at a time or several at once:\n\n::: {#35bc5174 .cell execution_count=79}\n``` {.python .cell-code}\n# Adding a single new entry\ngene_functions[\"EGFR\"] = \"growth signaling\"\nprint(gene_functions)\n\n# Adding multiple entries at once\ngene_functions.update({\n    \"MDM2\": \"p53 regulation\",\n    \"BCL2\": \"apoptosis regulation\"\n})\nprint(gene_functions)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'TP53': 'tumor suppressor', 'BRCA1': 'DNA repair', 'KRAS': 'signal transduction', 'EGFR': 'growth signaling'}\n{'TP53': 'tumor suppressor', 'BRCA1': 'DNA repair', 'KRAS': 'signal transduction', 'EGFR': 'growth signaling', 'MDM2': 'p53 regulation', 'BCL2': 'apoptosis regulation'}\n```\n:::\n:::\n\n\nYou can get a bit fancy with [updating](https://docs.python.org/3/library/stdtypes.html#dict.update) dictionaries if you want by using operators:\n\n::: {#b0ac316d .cell execution_count=80}\n``` {.python .cell-code}\nletters_and_numbers = dict(a=1, b=2) | dict(a=10, c=30)\nprint(letters_and_numbers)\n\nletters_and_numbers |= dict(d=400, e=500)\nprint(letters_and_numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'a': 10, 'b': 2, 'c': 30}\n{'a': 10, 'b': 2, 'c': 30, 'd': 400, 'e': 500}\n```\n:::\n:::\n\n\nWhen you're learning to code, it's best to stick with straightforward, easy-to-read solutions. While Python offers some fancy shortcuts (like complex operators), you'll usually want to write code that you and others can easily understand later. Simple and longer is often better than shorter and clever!\n\nHere's an interesting feature of Python dictionaries that you might have noticed: when you print out a dictionary, the items appear in the exact order you added them. This wasn't always true in older versions of Python, but now dictionaries automatically keep track of the order of your entries.\n\nOne final thing to mention. You can't use every Python type as a dictionary key, only immutable types. E.g., you couldn't use a list as a key for a dictionary. The specific reason for that is beyond the scope of this tutorial, but you may be interested in reading more about it here: [Why must dictionary keys be immutable?](https://docs.python.org/3/faq/design.html#why-must-dictionary-keys-be-immutable)\n\n#### Removing Items from a Dictionary {#sec-remove-items-dict}\n\nNeed to remove something from your dictionary? Here are two options:\n\n::: {#546311f2 .cell execution_count=81}\n``` {.python .cell-code}\n# Remove an entry with del.\n#\n# del will raise an error if the key is not present\ntry:\n    del gene_functions[\"KRAS\"]\nexcept KeyError:\n    print(\"KRAS was not present in the dictionary\")\nprint(gene_functions)\n\n# Remove and save the value with pop()\n#\n# We add the \"Unknown\" to the call to pop so that our program\n# will still run if the key is not present.\nremoved_gene = gene_functions.pop(\"EGFR\", \"Unknown\")\nprint(f\"Removed function: {removed_gene}\")\nprint(gene_functions)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'TP53': 'tumor suppressor', 'BRCA1': 'DNA repair', 'EGFR': 'growth signaling', 'MDM2': 'p53 regulation', 'BCL2': 'apoptosis regulation'}\nRemoved function: growth signaling\n{'TP53': 'tumor suppressor', 'BRCA1': 'DNA repair', 'MDM2': 'p53 regulation', 'BCL2': 'apoptosis regulation'}\n```\n:::\n:::\n\n\nThe [`del` statement](https://docs.python.org/3/tutorial/datastructures.html#the-del-statement) is probably the more common way to remove an item from a dictionary.\n\nNote that if you run that code block more than one time, you will get different outputs. Can you think of why that would be?\n\nBy the way...before working with a key, it's often wise to first check if it exists:\n\n::: {#74410bc3 .cell execution_count=82}\n``` {.python .cell-code}\nif \"TP53\" in gene_functions:\n    print(\"Found TP53's function!\")\n    function = gene_functions[\"TP53\"]\nelse:\n    print(\"TP53 not found in our dictionary\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFound TP53's function!\n```\n:::\n:::\n\n\nThis same technique is a good idea before using `del` as well, since `del` will give you an error if you try to delete the value of a key that is not present in the dictionary.\n\n::: {#bef3492e .cell execution_count=83}\n``` {.python .cell-code}\nif \"TP53\" in gene_functions:\n    del gene_functions[\"TP53\"]\n    print(gene_functions)\nelse:\n    print(\"TP53 not found in our dictionary\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'BRCA1': 'DNA repair', 'MDM2': 'p53 regulation', 'BCL2': 'apoptosis regulation'}\n```\n:::\n:::\n\n\nNote the use of the `in` operator. It is for [membership testing](https://docs.python.org/3/reference/expressions.html#membership-test-operations) and also works with dictionaries.\n\n#### Example: Creating the Reverse Complement of a DNA Sequence\n\nLet's tackle a common task in DNA sequence analysis: generating a reverse complement. If you've worked with DNA before, you know that A pairs with T, and C pairs with G.\n\nFirst, we'll create a dictionary that maps each nucleotide to its complement:\n\n::: {#7cbdc76d .cell execution_count=84}\n``` {.python .cell-code}\ncomplement = {\"A\": \"T\", \"T\": \"A\", \"G\": \"C\", \"C\": \"G\"}\nprint(complement)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'A': 'T', 'T': 'A', 'G': 'C', 'C': 'G'}\n```\n:::\n:::\n\n\nThen, we'll take a simple DNA sequence to demonstrate:\n\n::: {#0579df00 .cell execution_count=85}\n``` {.python .cell-code}\ndna_sequence = \"AACCTTGG\"\n```\n:::\n\n\nFinally, we'll loop through the sequence backwards (that's what `reversed(...)` does) and look the complement of each nucleotide:\n\n::: {#49795a6b .cell execution_count=86}\n``` {.python .cell-code}\nfor nucleotide in reversed(dna_sequence):\n    print(complement[nucleotide], end=\"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCCAAGGTT\n```\n:::\n:::\n\n\n(The `end=\"\"` parameter tells Python not to add newlines between letters, giving us one continuous sequence.)\n\n### Nested Dictionaries: Organizing Complex Data\n\nWhile simple dictionaries work well for simple mappings like mapping the name of a gene to its function, biological data often has multiple layers of related information.\n\nLet's look at one way we can organize this richer data using nested dictionaries -- dictionaries that themselves contain other dictionaries or lists. (Remember how we could nest lists in other lists? This is similar!)\n\nHere's an example showing how we might store information about the TP53 gene:\n\n::: {#abf68a02 .cell execution_count=87}\n``` {.python .cell-code}\n# Gene information database\n#\n# Imagine there are more genes in here too....\ngene_database = {\n    \"TP53\": {\n        \"full_name\": \"Tumor Protein P53\",\n        \"chromosome\": \"17\",\n        \"position\": {\"start\": 7_571_720, \"end\": 7_590_868},\n        \"aliases\": [\"p53\", \"TRP53\"],\n    }\n}\nprint(gene_database)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'TP53': {'full_name': 'Tumor Protein P53', 'chromosome': '17', 'position': {'start': 7571720, 'end': 7590868}, 'aliases': ['p53', 'TRP53']}}\n```\n:::\n:::\n\n\nLet's use the filing cabinet metaphor again: the main drawer is labeled \"TP53\", and inside that drawer are several folders containing different types of information. Some of these folders (like \"position\") contain their own sub-folders! (Alright, it's not the greatest metaphor...but hopefully you get the idea!)\n\nLet's break down what we're storing:\n\n- Basic information: The full name and chromosome location\n- Position data: Both start and end coordinates on the chromosome\n- Alternative names: A list of other common names for the gene\n\nTo access this information, we use square brackets to \"drill down\" through the layers. Each set of brackets takes us one level deeper:\n\n::: {#d2ab7102 .cell execution_count=88}\n``` {.python .cell-code}\n# Get the full name\ngene_name = gene_database[\"TP53\"][\"full_name\"]\nprint(gene_name)\n\n# Get the start position\nstart_position = gene_database[\"TP53\"][\"position\"][\"start\"]\nprint(start_position)\n\n# Get the first alias\nfirst_alias = gene_database[\"TP53\"][\"aliases\"][0]\nprint(first_alias)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTumor Protein P53\n7571720\np53\n```\n:::\n:::\n\n\nIt's pretty similar to nested lists, right?\n\n#### Handling Missing Data in Nested Dictionaries\n\nWith nested dictionaries, accessing missing data requires extra care to avoid errors. Let's see why:\n\n::: {#4a2aabfd .cell execution_count=89}\n``` {.python .cell-code}\n# Trying to access data that doesn't exist\ntry:\n    # Attempting to access methylation data that isn't stored\n    methylation = gene_database[\"TP53\"][\"methylation\"][\"site\"]\nexcept KeyError as error:\n    print(f\"Oops! That data isn't available: {error}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOops! That data isn't available: 'methylation'\n```\n:::\n:::\n\n\nThis code will raise a `KeyError` because we're trying to access a key (\"methylation\") that doesn't exist. When dealing with nested structures, it's particularly important to handle these cases because an error could occur at any level of nesting.\n\nHere is what happens if we try and access a key that doesn't exist in the `position` map:\n\n::: {#dccdb4aa .cell execution_count=90}\n``` {.python .cell-code}\ntry:\n    middle_position = gene_database[\"TP53\"][\"position\"][\"middle\"]\nexcept KeyError as error:\n    print(f\"Oops! That data isn't available: {error}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOops! That data isn't available: 'middle'\n```\n:::\n:::\n\n\nAs you see, this approach will work for missing keys at different levels of nesting.\n\nOne thing to be aware of if you are mixing lists and dictionaries is that while \"drilling down\" into the data structure you could potentially get errors other than `KeyError`:\n\n::: {#8bcef2f7 .cell execution_count=91}\n``` {.python .cell-code}\ntry:\n    an_alias = gene_database[\"TP53\"][\"aliases\"][10]\nexcept IndexError as error:\n    print(f\"Oops! That data isn't available: {error}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOops! That data isn't available: list index out of range\n```\n:::\n:::\n\n\nIn this case, we need to handle the `IndexError` because the data that the `aliases` key points to is a list, but that list doesn't have enough items to handle our request for the item at index `10`. Don't worry too much right now on handling specific errors. We will discuss error handling in greater depth in a future tutorial.\n\nWhile there are quite a few other ways to handle missing data when \"drilling down\" through nested data structures in Python, for now, we will just use the `try/except` approach similar to the one shown above.\n\n### Default Dictionaries: A Nice Way to Handle Missing Keys\n\nWe mentioned earlier that you should check for key presence in a dictionary before doing something interesting with that key to avoid key errors. Default dictionaries solve this problem elegantly by automatically creating new entries with preset values when you access a key that doesn't exist yet.\n\nA default dictionary is sort of like a self-initializing storage system. Instead of having to check if a key exists before using it, the dictionary takes care of that for you. It's particularly useful when you're counting occurrences or building categorized lists.\n\nYou can create default dictionaries with three common starting values:\n\n- `int`: starts new entries at zero (perfect for counting)\n- `list`: starts new entries with an empty list `[]` (great for categorizing or grouping)\n- `str`: starts new entries with an empty string `\"\"`\n\nHere is an example showing how to initialize default dictionaries:\n\n::: {#7dfb5848 .cell execution_count=92}\n``` {.python .cell-code}\nfrom collections import defaultdict\n\n# For counting things (starts at 0)\nnucleotide_counts = defaultdict(int)\n\n# For grouping things (starts with empty list)\ngenes_chromosomes = defaultdict(list)\n```\n:::\n\n\nLet's look at some practical examples.\n\n#### Counting Items with `defaultdict`\n\nSay we want to count nucleotides in a DNA sequence. It is pretty straightforward with a default dictionary:\n\n::: {#74334543 .cell execution_count=93}\n``` {.python .cell-code}\nnucleotide_counts = defaultdict(int)\ndna_sequence = \"ATGCATTAG\"\n\nfor base in dna_sequence:\n    nucleotide_counts[base] += 1\n\nfor nucleotide, count in nucleotide_counts.items():\n    print(f\"{nucleotide} => {count}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA => 3\nT => 3\nG => 2\nC => 1\n```\n:::\n:::\n\n\nWhat's happening here? Each time we see a nucleotide:\n\n- If we haven't seen it before, `defaultdict` automatically creates a counter starting at 0\n- We add 1 to the counter\n\nWithout `defaultdict`, we'd need this more complicated code:\n\n::: {#3555d95f .cell execution_count=94}\n``` {.python .cell-code}\nnucleotide_counts = {}\ndna_sequence = \"ATGCATTAG\"\n\nfor base in dna_sequence:\n    if base in nucleotide_counts:\n        nucleotide_counts[base] += 1\n    else:\n        nucleotide_counts[base] = 1\n\nfor nucleotide, count in nucleotide_counts.items():\n    print(f\"{nucleotide} => {count}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA => 3\nT => 3\nG => 2\nC => 1\n```\n:::\n:::\n\n\nYuck!\n\n#### Grouping Items with `defaultdict`\n\nDefault dictionaries are also great for grouping related items. Let's organize some genes by their chromosomes:\n\n::: {#c292c6ab .cell execution_count=95}\n``` {.python .cell-code}\nchromosomes = defaultdict(list)\n\nchromosomes[\"chr17\"].append(\"TP53\")\nchromosomes[\"chr13\"].append(\"BRCA2\")\nchromosomes[\"chr17\"].append(\"BRCA1\")\n\nfor chromosome, genes in chromosomes.items():\n    for gene in genes:\n        print(f\"{chromosome}, {gene}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nchr17, TP53\nchr17, BRCA1\nchr13, BRCA2\n```\n:::\n:::\n\n\nNotice how we didn't need to create empty lists for each chromosome first? The `defaultdict` does it for us. Each time we reference a new chromosome, it automatically creates an empty list ready to store genes.\n\n#### `defaultdict` Summary\n\nThe default dictionary approach is particularly useful when you're:\n\n- Counting frequencies of any kind\n- Grouping items by categories\n- Building collections of related items\n\nDefault dictionaries combine the power of regular dictionaries with automatic handling of new keys, making your code both simpler and more robust.\n\n### Counters\n\nPython has another type of dictionary called a [counter](https://docs.python.org/3/library/collections.html#counter-objects). Counters provide a convenient way to tally [hashable](https://docs.python.org/3/glossary.html#term-hashable) items.\n\nLet's return to our example from above, but this time, we will use a `Counter`.\n\n::: {#06b82109 .cell execution_count=96}\n``` {.python .cell-code}\nfrom collections import Counter\n\n# This is all you need to tally the nucleotides!\nnucleotide_counts = Counter(\"ATGCATTAG\")\n\n# You can loop through the Counter like a dictionary\nfor nucleotide, count in nucleotide_counts.items():\n    print(f\"{nucleotide} => {count}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA => 3\nT => 3\nG => 2\nC => 1\n```\n:::\n:::\n\n\nWe can find the N most common items using [most_common](https://docs.python.org/3/library/collections.html#collections.Counter.most_common):\n\n::: {#fbe91525 .cell execution_count=97}\n``` {.python .cell-code}\nprint(nucleotide_counts.most_common(2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[('A', 3), ('T', 3)]\n```\n:::\n:::\n\n\nVery nice!\n\nWhat if we wanted to calculate the ratio of nucleotides rather than the raw counts? A counter can help us here too:\n\n::: {#3122d150 .cell execution_count=98}\n``` {.python .cell-code}\nnucleotide_counts = Counter(\"ATGCATTAG\")\n\ntotal = nucleotide_counts.total()\n\nfor nucleotide, count in nucleotide_counts.items():\n    ratio = count / total\n    print(f\"{nucleotide} => {ratio:.3f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA => 0.333\nT => 0.333\nG => 0.222\nC => 0.111\n```\n:::\n:::\n\n\nPretty cool, right?\n\nCounters have lots of other neat methods and operator support that you may want to check out and use in your own programs.\n\n## Control Flow with Collections\n\nNow that we have covered some of Python's data structures and collections, and gone over the different type of loops, let's dive a little deeper into how you can combine collections, loops, and control flow into more realistic programs.\n\n### Overview\n\nYou have already seen how to loop over collections and sequences. But it never hurts to have a few more examples. Here is the for loop on a couple of different type of sequences:\n\n::: {#376b9177 .cell execution_count=99}\n``` {.python .cell-code}\nphrase = \"Hello, Python!\"\nfor letter in phrase:\n    print(letter)\n\nfoods = [\"apple\", \"pie\", \"grape\", \"cookie\"]\nfor food in foods:\n    print(food)\n\nfor number in range(2, 10, 2):\n    print(number)\n\nprices = {\"book\": 19.99, \"pencil\": 0.55}\n\n# By default, we only get the keys of a dictionary\n# in the for loop\nfor item in prices:\n    print(item)\n\n# Use .items() to get the key and value\nfor item, price in prices.items():\n    print(f\"{item} => ${price}\")\n\n# Use .values() to get just the values\nfor price in prices.values():\n    print(price)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nH\ne\nl\nl\no\n,\n \nP\ny\nt\nh\no\nn\n!\napple\npie\ngrape\ncookie\n2\n4\n6\n8\nbook\npencil\nbook => $19.99\npencil => $0.55\n19.99\n0.55\n```\n:::\n:::\n\n\nAs we mentioned earlier, you can use the for loop on anything that is [iterable](https://docs.python.org/3/glossary.html#term-iterable).\n\nRecall that if you want to get the position of the item in the sequence over which you are looping, use `enumerate`.\n\n::: {#4d0b52ec .cell execution_count=100}\n``` {.python .cell-code}\nphrase = \"Hello, Python!\"\nfor index, letter in enumerate(phrase):\n    print(f\"{index}: {letter}\")\n\nfoods = [\"apple\", \"pie\", \"grape\", \"cookie\"]\nfor index, food in enumerate(foods):\n    print(f\"{index}: {food}\")\n\nfor index, number in enumerate(range(2, 10, 2)):\n    print(f\"{index}: {number}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0: H\n1: e\n2: l\n3: l\n4: o\n5: ,\n6:  \n7: P\n8: y\n9: t\n10: h\n11: o\n12: n\n13: !\n0: apple\n1: pie\n2: grape\n3: cookie\n0: 2\n1: 4\n2: 6\n3: 8\n```\n:::\n:::\n\n\nYou can use `enumerate` with dictionaries as well, but it is a bit less common, as many times when you are using a dictionary you don't really care about the order anyway.\n\n### Controlling the Flow of Loops\n\nWhen you're working with loops, sometimes you need more than just going through items one by one. You might want to skip certain items, stop the loop early, or take different actions based on what you find. Let's explore some techniques that will give you more control over how your loops behave.\n\n#### Making Decisions in Loops\n\nWe can use boolean expressions and conditional statements to make decisions inside of loops. This allows us to take different actions depending on characteristics of the data.\n\n::: {#4a881a80 .cell execution_count=101}\n``` {.python .cell-code}\nfor n in range(10):\n    if n > 5:\n        print(n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6\n7\n8\n9\n```\n:::\n:::\n\n\nHere, we are looping through the numbers from 0 to 9, and if the number is 6 or more, then we print it, otherwise, we just go on to the next number.\n\nIn this example, we want to keep DNA sequences that start with the start codon `ATG`:\n\n::: {#ec5aa775 .cell execution_count=102}\n``` {.python .cell-code}\nstart_codon = \"ATG\"\nsequences = ['ATGCGC', 'AATTAA', 'GCGCGC', 'TATATA']\n\nwith_start_codons = []\n\nfor sequence in sequences:\n    if sequence.startswith(start_codon):\n        with_start_codons.append(sequence)\n\nprint(with_start_codons)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['ATGCGC']\n```\n:::\n:::\n\n\nThis example is actually a decent one for a comprehension:\n\n::: {#24521023 .cell execution_count=103}\n``` {.python .cell-code}\nstart_codon = \"ATG\"\nsequences = ['ATGCGC', 'AATTAA', 'GCGCGC', 'TATATA']\n\nwith_start_codons = [\n    sequence for sequence in sequences if sequence.startswith(start_codon)\n]\n\nprint(with_start_codons)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['ATGCGC']\n```\n:::\n:::\n\n\nComprehensions can be nice for simple filtering and transformations, like in this example. However, you should be cautious about making them too complex. As a rule of thumb:\n\nGood for comprehensions:\n\n- Simple filters (like checking if something starts with \"ATG\")\n- Basic transformations (like converting strings to uppercase)\n- When the logic fits naturally on one line\n\nAvoid comprehensions when:\n\n- The logic gets nested or complicated\n- Multiple operations are involved\n- The line becomes hard to read at a glance\n\nIn this case, the comprehension is kind of nice because it's doing a single, straightforward filter operation. But remember: code readability is more important than being clever. If you find yourself writing a complex comprehension, consider using a regular for loop instead.\n\n#### `break`\n\nSometimes you find what you're looking for before going through the entire sequence. The `break` statement is like having an \"early exit\" button -- it lets you stop the loop immediately when certain conditions are met. Sometimes this can make your code more efficient by preventing unnecessary iterations.\n\nIn this example, we are interested in seeing if a collection of DNA sequences contains at least one sequence with an ambiguous base (`N`), and if so, save that DNA fragment and stop looking:\n\n::: {#97156a21 .cell execution_count=104}\n``` {.python .cell-code}\nsequences = ['ATGCGC', 'AATTAGA', 'GCNGCGC', 'TCATATA']\n\nfor i, sequence in enumerate(sequences):\n    print(f\"checking sequence {i+1}\")\n    # Recall that we can use `in` to check if a\n    # letter is in a word.\n    if \"N\" in sequence:\n        print(f\"sequence {i+1} had an N!\\n\")\n        sequence_with_n = sequence\n        break\n\nprint(sequence_with_n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nchecking sequence 1\nchecking sequence 2\nchecking sequence 3\nsequence 3 had an N!\n\nGCNGCGC\n```\n:::\n:::\n\n\nNotice how the loop stops after the 3rd sequence and doesn't continue all the way until the end. This is thanks to the `break` keyword.\n\n#### `continue`\n\nThink of `continue` as a \"skip to the next item\" command. When you hit a `continue` statement, the loop immediately jumps to the next iteration. This is perfect for when you want to skip over certain items without stopping the entire loop, like focusing only on the data points that meet your criteria.\n\nIn this example, we only want to process protein fragments that start with Methionine (`M`) and skip the others. While there are multiple ways to approach this, let's use `continue`:\n\n::: {#cce931d4 .cell execution_count=105}\n``` {.python .cell-code}\nproteins = [\"MVQIPQNPL\", \"ILVDGSSYLYR\", \"MAYHAFPPLTNSA\", \"GEPTGA\"]\n\nfor protein in proteins:\n    if not protein.startswith(\"M\"):\n        continue\n\n    print(f\"we will process {protein}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nwe will process MVQIPQNPL\nwe will process MAYHAFPPLTNSA\n```\n:::\n:::\n\n\nThis example is a little bit contrived. I actually think writing it _without_ the `continue` is clearer:\n\n::: {#08da4360 .cell execution_count=106}\n``` {.python .cell-code}\nproteins = [\"MVQIPQNPL\", \"ILVDGSSYLYR\", \"MAYHAFPPLTNSA\", \"GEPTGA\"]\n\nfor protein in proteins:\n    if protein.startswith(\"M\"):\n        print(f\"we will process {protein}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nwe will process MVQIPQNPL\nwe will process MAYHAFPPLTNSA\n```\n:::\n:::\n\n\n### A Practical Example: Simulating Bacterial Growth\n\nLet's look at something more interesting -- simulating how bacteria might grow over time. We'll create a simple model where each bacterium can grow, shrink, or stay the same size each day.\n\n_Pay particular attention to this exmaple. It will be useful for Miniproject 1!_\n\n::: {#89028cd1 .cell execution_count=107}\n``` {.python .cell-code}\nimport random\n\ntotal_bacteria = 15\n\n# Make 15 bacteria all starting with size 10\nbacteria = [10] * total_bacteria\n\n# Simple \"growth\" rules:\n#\n# - 50% chance to grow\n# - 25% chance to shrink\n# - 25% chance to stay the same\n\n# The outer loop tracks days in the experiment\nfor day in range(20):\n\n    # The inner loop tracks each individual bateria\n    for i in range(total_bacteria):\n        chance = random.random()\n\n        # First we check if this bacterium will grow today\n        if chance < 0.5:\n            bacteria[i] += 1\n        # If it will not grow, we need to check if it will shrink\n        elif chance < 0.75:\n            bacteria[i] -= 1\n\n        # We don't need the `else` here because if the bacterium\n        # won't grow AND it won't shrink, then no action is required.\n\n# Finally, we print out the sizes of all the bacteria\n# at the end of the experiment\nfor id, size in enumerate(bacteria):\n    print(f\"bacterium {id+1}, size: {size}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbacterium 1, size: 12\nbacterium 2, size: 16\nbacterium 3, size: 15\nbacterium 4, size: 14\nbacterium 5, size: 11\nbacterium 6, size: 20\nbacterium 7, size: 15\nbacterium 8, size: 15\nbacterium 9, size: 10\nbacterium 10, size: 19\nbacterium 11, size: 15\nbacterium 12, size: 13\nbacterium 13, size: 9\nbacterium 14, size: 15\nbacterium 15, size: 15\n```\n:::\n:::\n\n\nHere is what is happening:\n\n- In the outer loop, we run the simulation for 20 days, with each iteration representing one day of bacterial growth.\n- In the inner loop, we check each bacterium in our population and apply the growth rules using random chances.\n- Then we loop through the bacteria sizes and print out the final size of each bacterium. (We treat the bacterium's location in the array (plus one) as its ID.)\n\n#### How the Random Choices Work\n\nThe clever part here is how we use a single random number to make weighted choices. Think of it like a number line from 0 to 1, divided into three sections:\n\n```\n┌────────────────────┬──────────┬──────────┐\n│ 50%                │ 25%      │ 25%      │\n└────────────────────┴──────────┴──────────┘\n↑                    ↑          ↑          ↑\n0.0                  0.5        0.75       1.0\n```\n\nWhen we generate a random number between 0 and 1:\n\n- If it falls in the first half (0.0-0.5), the bacterium grows\n- If it falls in the next quarter (0.5-0.75), the bacterium shrinks\n- If it falls in the last quarter (0.75-1.0), the bacterium stays the same size\n\nThis is one way to implement different probabilities for different outcomes. While this example uses bacterial growth, you could adapt this pattern for any situation where you need to simulate random events with different probabilities -- like mutation rates, drug responses, or population changes.\n\nIf you are curious, Python has a [method](https://docs.python.org/3/library/random.html#random.choices) that simplifies this random choice logic. Check it out if you're curious! You might want to use it for your first miniproject....\n\n## Common Sequence Operations\n\nYou may have noticed that we can treat many of Python's collection types in a similar way.\n\nOne of Python's most helpful features is that many collection types (like lists, strings, and tuples) share the [same basic operations](https://docs.python.org/3/library/stdtypes.html#common-sequence-operations). This means once you learn how to work with one type of sequence, you can apply that knowledge to others -- you can find the length of any sequence using `len()`, check if something exists in a sequence using `in`, or grab a specific element using square bracket notation `[]`.\n\nFor instance, whether you're working with a DNA sequence as a string or a list of gene names, you can use the same syntax: `len(\"ATCG\")` and `len([\"nrdA\", \"nrdJ\"])` both work the same way!\n\n## Choosing the Right Collection\n\nWhen deciding which type of collection to use, consider these three key questions:\n\n1. \"How will I create or receive this data initially?\"\n2. \"How will I need to access this data later?\"\n3. \"How will I need to modify this data?\"\n\nHere's a practical guide to help you choose:\n\n### Use a list when...\n\n- Your data has a meaningful order (e.g., lines from a file, time series)\n- You need to access items by position (index) or slices\n- You need ordered operations (iteration in sequence, sorting, reversing)\n- You want efficient operations at the end of the collection (append/pop)\n- You need to maintain duplicates\n- You need to modify items in place\n\n### Use a dictionary when...\n\n- Your data naturally comes as key-value pairs\n- You need to look up values by a unique identifier (key)\n- You need to efficiently find, add, or update specific items without linear searching\n- You want to map one piece of data to another\n- You need to combine data from multiple sources using a common key\n\n### Use a set when...\n\n- You only care about uniqueness, not order or association\n- You need automatic elimination of duplicates\n- You're only concerned with presence/absence of items\n- You need to perform set operations (unions, intersections, differences)\n- You need fast membership testing\n\n### Examples\n\nFor instance, when processing a FASTA file, you'll encounter ID-sequence pairs. If you need to access sequences by their identifiers later, a dictionary is the natural choice. However, if you're only interested in the sequences themselves and won't need to reference them by ID, storing just the sequences in a list would be more appropriate.\n\nAs another example, consider analyzing homology search results where you need to organize multiple hits that correspond to each query sequence. If you'll need to retrieve all hits for a specific query using its identifier, a dictionary is ideal. You could structure it with query IDs as keys and lists of corresponding hits as values, allowing efficient lookup of results for any particular query of interest:\n\n::: {#f481d709 .cell execution_count=108}\n``` {.python .cell-code}\n# Tuples of query-target-bitscore -- imagine these come directly from a BLAST\n# output file or something similar.\nhomology_search_results = [\n    (\"query_1\", \"target_1\", 95),\n    (\"query_1\", \"target_2\", 32),\n    (\"query_2\", \"target_1\", 112)\n]\n\nquery_hits = {}\n\nfor query, target, bitscore in homology_search_results:\n    hit_info = (target, bitscore)\n\n    if query in query_hits:\n        query_hits[query].append(hit_info)\n    else:\n        query_hits[query] = [hit_info]\n\nprint(query_hits[\"query_2\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[('target_1', 112)]\n```\n:::\n:::\n\n\n### Summary\n\nTo summarize, select the collection type that both enhances code readability and aligns with your specific patterns of data creation, access, and modification throughout your program's workflow.\n\n## Key Takeaways\n\nWe've covered a lot of material about some of Python's most commonly used data structures. Here are some key takeaways.\n\n### General Suggestions\n\n- Generally keep data types consistent within collections\n- Use clear, descriptive names\n- Choose the simplest structure that works\n- Use list comprehensions for simple transformations\n- Handle missing dictionary keys with `get`\n- Consider memory usage with large datasets\n\n### Watch Out For\n\n- Modifying lists while iterating\n- Forgetting tuple immutability\n- Missing dictionary keys\n- Infinite loops\n- Using lists when dictionaries would be more appropriate\n\n",
    "supporting": [
      "collections_files"
    ],
    "filters": [],
    "includes": {}
  }
}