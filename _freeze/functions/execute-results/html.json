{
  "hash": "56a829a61c2f32f7a50fbfa46bd3f2d6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nauthor: \"Ryan M. Moore, PhD\"\ndate-modified: last-modified\ndate: \"2025-02-25\"\njupyter: python3\n---\n\n# Functions {#sec-functions}\n\n## Introduction\n\nUntil now, we've mostly been using built-in Python's functions like `print()`, `len()`, and `range()` to get things done. While Python's standard library provides a ton of useful functionality, eventually you will need to create something more tailored to your specific needs.\n\nThis is where custom functions come in. Functions are like reusable blocks of code that you design to perform specific tasks. Creating your own functions allows you to extend Python's capabilities beyond what's available \"out of the box.\" In this module, we'll explore functions from the ground up: their purpose, how to create them, and how to write them effectively.\n\nLearning to work with functions is a core programming skill that offers several key benefits:\n\n- It helps you tackle large problems by breaking them into smaller, manageable parts\n- It makes your code more organized and easier to follow\n- It makes your code easier for others to understand and use\n- It eliminates the need to copy and paste code repeatedly\n- It reduces mistakes by creating tested, reliable code blocks you can reuse\n\nWhether you're analyzing data sets, automating repetitive tasks, or building scientific applications, functions will become an essential part of your programming toolkit. Let's dive in and learn how to create them!\n\n### What is a Function?\n\nA function is a reusable block of code that performs a specific task, a sort of standard procedure for performing a particular computation or task in your code.\n\nFunctions help us organize our code by breaking down complex problems into smaller, more manageable pieces. For example, instead of writing one massive program that does everything, we can create separate functions for each logical step. This makes our code easier to write, understand, and fix when something goes wrong.\n\nOne important feature of functions is that we can give them descriptive names that explain what they do. When you see a function named `calculate_average` or `find_peak_values`, you immediately have a good idea of its purpose. This makes your code more readable and easier to maintain.\n\nYou might hear functions called by different names like methods, procedures, or subroutines, depending on the programming language or context. Don't worry too much about these different terms; for now, we will simply call them functions. Regardless of their name, their main purpose remains the same: to package up a set of instructions that we can easily reuse.\n\nLet's start with something familiar - mathematical functions. You might remember seeing expressions like $f(x) = 2x$ in math class. This simple function takes any number $x$ and doubles it. Graphically, it creates a straight line where each input $x$ corresponds to an output $y$ that's twice as large:\n\n```\n  y\n\n6 │        •\n  │       /\n  │      /\n4 │     •\n  │    /\n  │   /\n1 │  •\n  └─────────── x\n     1  2  3\n```\n\nWe can create a function with similar behavior in Python:\n\n::: {#8f47f980 .cell execution_count=1}\n``` {.python .cell-code}\ndef times_2(x):\n    return 2 * x\n```\n:::\n\n\nHere we see a function called `times_2` that takes a value `x` and returns a value that is twice as large (`2 * x`). Let's use the [seaborn](https://seaborn.pydata.org/) package to visualize some inputs and outputs of the `times_2` function:\n\n::: {#3a0ce6a3 .cell execution_count=2}\n``` {.python .cell-code}\n# Import the seaborn package\nimport seaborn as sns\n\n\n# Create some x values\nxs = [1, 2, 3]\n\n# The y values are results of running\n# the function on all the x values\nys = [times_2(x) for x in xs]\n\n# Print out the y values\nprint(ys)\n\n# Finally, draw a plot of the results.\nsns.relplot(ys, kind=\"line\", aspect=0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 4, 6]\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](functions_files/figure-html/cell-3-output-2.png){}\n:::\n:::\n\n\nAt its core, a function is like a machine that follows a specific set of instructions:\n\n```\n          ┌─────┐\ninput ──► │  ✦  │ ──► output\n          └─────┘\na function ──┘\n```\n\nYou put something in (input), the function processes it according to its instructions, and you get something out (output).\n\nAs we will see, Python functions are more flexible than mathematical ones. They can:\n\n- Take multiple inputs (or none at all)\n- Return collections of values (or nothing at all)\n- Perform actions beyond just calculations (like printing text or saving files)\n\n### Why Do We Need Functions?\n\nYou can think of Python functions as pre-packaged units of code that perform specific tasks. When you write a function, you're creating a reusable tool that you can call whenever you need it. Functions create a logical boundary around related operations, giving them a clear purpose and identity, which can make code more readable, reusable, and maintainable. Here's a simple example that shows how functions make code more readable:\n\n```python\ngene_expression_data = read_csv(\"gene_expression.csv\")\n\nupregulated_genes = find_upregulated_genes(gene_expression_data)\n\nplot_expression_data(upregulated_genes)\n```\n\nEven if you don't know exactly how these functions work internally, you can probably guess what this code does just by reading the function names. When you combine descriptive function names with clear variable names, your code becomes self-documenting, that is, it will be easier to understand without additional comments or explanations.\n\nHere are some of the advantages and benefits of using functions in programming:\n\n- Abstraction\n  - Functions hide complex operations behind simple, easy-to-use interfaces\n  - You can use a function without needing to understand all the details of how it works internally\n- Organization\n  - Functions help break down complex problems into smaller, manageable pieces\n  - A well-organized series of function calls is much easier to understand than a long block of detailed code\n- Reusability\n  - Once you write a function, you can use it again in similar contexts\n  - Functions can be shared across different projects\n  - This saves time and reduces the chance of errors from rewriting the same code\n- Testability\n  - Functions make it easier to test your code in small, isolated pieces\n  - You can verify each function works correctly on its own\n  - If individual functions work properly, you can more confidently combine them into larger programs\n\nFunctions are the building blocks of your programs. Each block performs a specific task, and when you combine them thoughtfully, you can create complex programs that solve real-world problems. The key is to make each function clear and focused -- if you can understand what each piece does on its own, it becomes much easier to work with them as a whole.\n\n## Function Syntax\n\nNow that we understand the basic concept of functions, let's look at how to write them in Python. In a sense, you will need to learn the grammar of writing functions in Python.\n\nHere's a simple example that checks if a DNA sequence ends with certain stop codons:\n\n::: {#406bcd25 .cell execution_count=3}\n``` {.python .cell-code}\ndef ends_with_stop_codon(dna_sequence, stop_codons):\n    \"\"\"Check if the given DNA sequence ends with any of the given stop codons.\"\"\"\n    result = dna_sequence.endswith(stop_codons)\n    return result\n\n\nstop_codons = (\"TAA\", \"TAG\", \"TGA\")\nresult = ends_with_stop_codon(\"ATGAAACCACTGGTGGTTAA\", stop_codons)\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\nLet's break down that down:\n\n### Function Definition\n\n::: {#6726fd15 .cell execution_count=4}\n``` {.python .cell-code}\ndef ends_with_stop_codon(dna_sequence, stop_codons): ...\n```\n:::\n\n\n- The `def` keyword tells Python you're creating a new function\n- `ends_with_stop_codon` is the name you're giving your function\n- Inside the parentheses are your parameters (`dna_sequence` and `stop_codons`)\n- The colon `:` marks where the function details begin\n\nRemember to use lowercase letters with underscores for function names (like `read_csv`, not `readCSV`).\n\n### Key Function Components\n\n- Docstring\n  - The text between triple quotes `\"\"\"...\"\"\"`\n  - Explains what the function does\n- Function body\n  - All the indented code below the function definition\n- Return statement\n  - `return result`\n  - Specifies what the function sends back\n- Function call\n  - `ends_with_stop_codon(\"ATGAAACCACTGGTGGTTAA\", stop_codons)`\n  - How you actually use the function\n\n### Indentation Matters\n\nPython uses indentation to know what code belongs to your function. Everything indented after the function definition is part of that function:\n\n::: {#9aadbf94 .cell execution_count=5}\n``` {.python .cell-code}\ndef hello(name, excitement):\n    \"\"\"Create a greeting message.\"\"\"\n    msg = f\"Hello, {name}\"\n\n    if excitement == \"intense\":\n        msg += \".\"\n    elif excitement == \"happy\":\n        msg += \"!!!\"\n    else:\n        msg += \"!\"\n\n    return msg\n```\n:::\n\n\n## Function Parameters {#sec-function-parameters}\n\nThe most common way of getting data into functions is through function parameters, which hold the data your function needs to work with.\n\nA quick note about terminology you'll encounter: You'll hear people use both \"parameters\" and \"arguments\" when talking about functions, and while they're often used interchangeably, in this tutorial we will make the following distinction:\n\n- Parameters are the names you list when you're creating your function. They are the \"placeholders\" that tell the function what data to expect.\n- Arguments are the actual values you send to the function when you use it.\n\nFor example, in this function, `a` and `b` are the parameters of the `add` function, and `1` and `2` are arguments to the function when it is called:\n\n::: {#234591f3 .cell execution_count=6}\n``` {.python .cell-code}\ndef add(a, b):\n    return a + b\n\n\nadd(1, 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n3\n```\n:::\n:::\n\n\nDon't worry too much about mixing up these terms. The important thing is understanding that functions need a way to receive data, and parameters/arguments are how we do that.\n\nFunction parameters and arguments are very flexible in Python. Let's see how we can define and use them.\n\n### Positional parameters\n\nLet's look at our `add` function again:\n\n::: {#53765335 .cell execution_count=7}\n``` {.python .cell-code}\ndef add(a, b):\n    return a + b\n```\n:::\n\n\nIn this function `a` and `b` are positional parameters. When we call this function, like `add(1, 2)`, Python matches each argument to its parameter based on position -- that's why they're called \"positional parameters\": the first argument (`1`) goes with the first parameter (`a`), and the second argument (`2`) goes with the second parameter (`b`).\n\nThis is the most basic and common way to define parameters in Python functions.\n\n### Keyword Arguments\n\nCheck out this function that \"clamps\" a number between an upper and lower bound:\n\n::: {#662c99e4 .cell execution_count=8}\n``` {.python .cell-code}\ndef clamp(x, min, max):\n    \"Clamp a number between a minimum and a maximum\"\n    if x < min:\n        return min\n    elif x > max:\n        return max\n    else:\n        return x\n```\n:::\n\n\n(For simplicity, we'll assume users provide valid inputs where `min` is always less than `max`.)\n\nWhile this function works, it has some potential usability issues. When calling this function, it's not immediately clear which argument goes where. For instance:\n\n- Should we put `min` before `max`, or vice versa?\n- Should the value we're clamping (`x`) go first, last, or in the middle?\n- Looking at a call like `clamp(37, 45, 63)`, it's not obvious which number represents what without checking the function definition.\n\nThis is where Python's keyword arguments come to the rescue! Instead of relying on the order of arguments, we can explicitly label them:\n\n::: {#b496fa1d .cell execution_count=9}\n``` {.python .cell-code}\nprint(clamp(10, min=25, max=75))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n25\n```\n:::\n:::\n\n\nThe format is straightforward: `keyword_arg=value`. The real power of keyword arguments is their flexibility. You can use keywords for some arguments but not others, and arrange the arguments in the order that makes the most sense for your use case.\n\nHere are several valid ways to call the same function:\n\n::: {#21f21323 .cell execution_count=10}\n``` {.python .cell-code}\nprint(clamp(10, max=75, min=25))\nprint(clamp(max=75, min=25, x=10))\nprint(clamp(min=25, max=75, x=10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n25\n25\n25\n```\n:::\n:::\n\n\nAll these calls do exactly the same thing, but the labeled arguments make it clear what each value represents.\n\n#### Rules for Using Keyword Arguments\n\nWhen using keyword arguments in Python, there are several important rules to follow. Let's look at some common mistakes and how to avoid them.\n\nDon't forget the required arguments:\n\n::: {#a2e79129 .cell execution_count=11}\n``` {.python .cell-code}\ntry:\n    # Where is the number to clamp?\n    clamp(min=25, max=75)\nexcept TypeError as error:\n    print(error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclamp() missing 1 required positional argument: 'x'\n```\n:::\n:::\n\n\nPut the positional arguments before the keyword arguments:\n\n```python\n# (If you try to run this, you will get a SyntaxError.)\n\n# The 10 needs to go first!\nclamp(min=25, max=75, 10)\n```\n\nDon't provide the same argument twice:\n\n::: {#6dca2724 .cell execution_count=12}\n``` {.python .cell-code}\ntry:\n    # Here, we're trying to set 'min' twice\n    clamp(10, 75, min=25)\nexcept TypeError as error:\n    print(error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclamp() got multiple values for argument 'min'\n```\n:::\n:::\n\n\nOnly use keyword arguments that the function expects:\n\n::: {#503f523d .cell execution_count=13}\n``` {.python .cell-code}\ntry:\n    # 'number' isn't a parameter name in clamp()\n    clamp(number=10, min=25, max=75)\nexcept TypeError as error:\n    print(error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclamp() got an unexpected keyword argument 'number'\n```\n:::\n:::\n\n\nEssentially, these rules exist to prevent ambiguity so that Python knows which arguments go with which parameters.\n\n### Default Argument Values\n\nWhen creating functions, you can set default values for their arguments. This means if you call your function without specifying all the arguments, Python will use these preset defaults instead. This essentially gives you a way to create optional functional parameters. Check it out:\n\n::: {#7ba38960 .cell execution_count=14}\n``` {.python .cell-code}\ndef hello(who=\"World\"):\n    print(f\"Hello, {who}!\")\n\n\nhello(\"Delaware\")\nhello()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, Delaware!\nHello, World!\n```\n:::\n:::\n\n\nIn this case, if no argument is provided when calling `hello`, Python automatically uses \"World\" as the default value.\n\nYou can also use variables to set these default values:\n\n::: {#f413eea4 .cell execution_count=15}\n``` {.python .cell-code}\nplace = \"World\"\n\n\ndef hello(who=place):\n    print(f\"Hello, {who}!\")\n\n\nhello(\"Delaware\")\nhello()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, Delaware!\nHello, World!\n```\n:::\n:::\n\n\nPython sets these default values when you first define the function, not when you call it. It will look at any variables available at that moment (what we call \"in scope\") to determine the default value. If you're using a variable as a default value, make sure it's defined before you create your function. We'll explore the concept of scope in more detail later in the tutorial.\n\n#### A Common Pitfall: Mutable Default Arguments\n\nLet's look at a subtle but important quirk in Python functions that can catch you off guard. Consider this seemingly straightforward function:\n\n::: {#ee8ef04e .cell execution_count=16}\n``` {.python .cell-code}\ndef sneaky_append(number, numbers=[]):\n    numbers.append(number)\n    return numbers\n```\n:::\n\n\nThis function looks like it should do something simple: take a number, add it to a list, and if no list is provided, start with an empty one. Sounds reasonable, right?\n\nLet's see what happens when we run it multiple times:\n\n::: {#c5e9b4bc .cell execution_count=17}\n``` {.python .cell-code}\nprint(sneaky_append(3))\nprint(sneaky_append(0))\nprint(sneaky_append(2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[3]\n[3, 0]\n[3, 0, 2]\n```\n:::\n:::\n\n\nSurprise! Instead of getting three separate lists, each containing one number, we get a single list that keeps growing. What's going on here?\n\nThe key is understanding when Python creates that empty list we used as a default argument. Python creates it once when the function is defined, not each time the function is called. This means all calls to the function are sharing the same list!\n\nHere's a better way to write this function:\n\n::: {#6ea4f0d1 .cell execution_count=18}\n``` {.python .cell-code}\ndef cozy_append(number, numbers=None):\n    if numbers is None:\n        numbers = []\n\n    numbers.append(number)\n    return numbers\n\n\nprint(cozy_append(3))\nprint(cozy_append(0))\nprint(cozy_append(2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[3]\n[0]\n[2]\n```\n:::\n:::\n\n\nIn this improved version, we use `None` as our default argument and create a new empty list inside the function each time it's called. This gives us the behavior we actually wanted: a fresh, empty list for each function call when no list is provided.\n\nThe takeaway? Be _very_ careful about using mutable objects (like lists, dictionaries, or sets) as default arguments. Instead, use `None` as your default and create your mutable object inside the function.\n\n### Combining Keyword Arguments & Default Arguments\n\nKeyword arguments and default arguments look pretty similar. Let's take a look at them in the same example.\n\nKeyword arguments can be combined with default arguments as well. Let's turn the `min` and `max` of our clamp function to default arguments.\n\n::: {#66982ea5 .cell execution_count=19}\n``` {.python .cell-code}\ndef clamp(x, min=25, max=75):\n    \"Clamp a number between a minimum and a maximum\"\n    if x < min:\n        return min\n    elif x > max:\n        return max\n    else:\n        return x\n\n\n# You can override just one default argument.\nprint(clamp(10, min=5))  # Uses the default max=75\n\n# All these calls do the same thing\n\n# Using keyword arguments for the default parameters\nprint(clamp(10, max=75, min=25))\n\n# Using all keyword arguments\nprint(clamp(max=75, min=25, x=10))\n\n# Different order, same result\nprint(clamp(min=25, max=75, x=10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10\n25\n25\n25\n```\n:::\n:::\n\n\nThere are a few important points to understand here:\n\n- Default arguments (`min=25, max=75` in the function definition) provide fallback values when those arguments aren't specified in the function call.\n- Keyword arguments (like `min=5` in the function call) let you specify which parameter you're passing a value to.\n- Even required parameters (like `x`) can be passed using keyword syntax (`x=10`), though this isn't required.\n- When using keyword arguments, the order doesn't matter as long as keyword arguments follow any positional arguments.\n\nThis flexibility can be useful when working with functions that have multiple parameters, as it can help make your code more readable and prevent mistakes from mixing up the order of arguments.\n\n### Functions That Can Take Any Number of Arguments\n\nSometimes you want to write a function that can handle different numbers of inputs. Python makes this possible with variable-length arguments. Let's explore how this works.\n\n#### Taking Multiple Positional Arguments\n\nTo specify that a function takes a variable number of positional arguments, you use the `*args` syntax. The asterisk (`*`) tells Python to accept any number of arguments and pack them into a tuple. Sometimes you will see these called _variadic_ arguments. Check it out:\n\n::: {#8e2a41fa .cell execution_count=20}\n``` {.python .cell-code}\ndef process_samples(*samples):\n    for sample in samples:\n        print(f\"Processing sample: {sample}\")\n\n\n# Works with any number of arguments\nprocess_samples(\"A1\")  # One sample\nprocess_samples(\"A1\", \"A2\", \"B1\", \"B2\")  # Three samples\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nProcessing sample: A1\nProcessing sample: A1\nProcessing sample: A2\nProcessing sample: B1\nProcessing sample: B2\n```\n:::\n:::\n\n\nYou can combine the variadic arguments with positional arguments, as long as the formally specified positional arguments come first:\n\n::: {#55dfeafe .cell execution_count=21}\n``` {.python .cell-code}\ndef print_stuff(separator, *words):\n    msg = separator.join(words)\n    print(msg)\n\n\nprint_stuff(\", \", \"apple\", \"banana\", \"cherry\", \"domino's pizza\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\napple, banana, cherry, domino's pizza\n```\n:::\n:::\n\n\nThe `*words` parameter tells Python to collect all remaining arguments into a tuple called `words`. Having to specify the separator first before all the words you want to print feels a bit awkward to me. We can improve this making `separator` a keyword argument that comes last:\n\n::: {#88c2c31d .cell execution_count=22}\n``` {.python .cell-code}\ndef print_stuff(*words, separator):\n    msg = separator.join(words)\n    print(msg)\n\n\nprint_stuff(\"apple\", \"banana\", \"cherry\", \"domino's pizza\", separator=\", \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\napple, banana, cherry, domino's pizza\n```\n:::\n:::\n\n\nWhen you have an argument that follows the variadic arguments, it must be used like a keyword argument. For example, this doesn't work:\n\n::: {#37c83fc7 .cell execution_count=23}\n``` {.python .cell-code}\ntry:\n    print_stuff(\"apple\", \"banana\", \"cherry\", \"domino's pizza\", \", \")\nexcept TypeError as error:\n    print(error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nprint_stuff() missing 1 required keyword-only argument: 'separator'\n```\n:::\n:::\n\n\nWithout using a keyword argument, Python has no way of knowing that the final argument you passed into the function shouldn't be part of the `words` tuple.\n\nFinally, it is very common in these situations that a default argument be provided to the argument that comes after a variadic argument list:\n\n::: {#1ad68ea5 .cell execution_count=24}\n``` {.python .cell-code}\ndef print_stuff(*words, separator=\", \"):\n    msg = separator.join(words)\n    print(msg)\n\n\nprint_stuff(\"apple\", \"banana\", \"cherry\", \"domino's pizza\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\napple, banana, cherry, domino's pizza\n```\n:::\n:::\n\n\n##### Collections & Variadic Arguments\n\nHere's something that might surprise you:\n\n::: {#a1e9a18d .cell execution_count=25}\n``` {.python .cell-code}\nfoods = [\"apple\", \"banana\", \"cherry\", \"domino's pizza\"]\n\ntry:\n    print_stuff(foods)\nexcept TypeError as error:\n    print(error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsequence item 0: expected str instance, list found\n```\n:::\n:::\n\n\nWhen we pass a list directly, Python treats it as a single argument. To tell Python to treat each item in the list as a separate argument, we need to [\"unpack\"](https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists) the list using the `*` operator:\n\n::: {#ebb86cc4 .cell execution_count=26}\n``` {.python .cell-code}\nfoods = [\"apple\", \"banana\", \"cherry\", \"domino's pizza\"]\nprint_stuff(*foods)  # This works!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\napple, banana, cherry, domino's pizza\n```\n:::\n:::\n\n\nLet's look at another example that shows how this behavior can be tricky:\n\n::: {#e7960049 .cell execution_count=27}\n``` {.python .cell-code}\ndef greeter(*names):\n    for name in names:\n        print(f\"Hello, {name}!\")\n\n\n# This passes three separate arguments\ngreeter(\"Ryan\", \"Pikachu\", \"Shaq\")\n\n# This passes one argument (a list)\nprint()\ngreeter([\"Ryan\", \"Pikachu\", \"Shaq\"])\n\n# This \"unpacks\" the list again into multiple arguments\nprint()\ngreeter(*[\"Ryan\", \"Pikachu\", \"Shaq\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, Ryan!\nHello, Pikachu!\nHello, Shaq!\n\nHello, ['Ryan', 'Pikachu', 'Shaq']!\n\nHello, Ryan!\nHello, Pikachu!\nHello, Shaq!\n```\n:::\n:::\n\n\nCompare that to the version of `greeter` that takes a single collection argument rather than a variable number of arguments.\n\n::: {#92d920ce .cell execution_count=28}\n``` {.python .cell-code}\ndef greeter(names):\n    for name in names:\n        print(f\"Hello, {name}!\")\n\n\n# This passes three separate arguments\ntry:\n    greeter(\"Ryan\", \"Pikachu\", \"Shaq\")\nexcept TypeError as error:\n    print(error)\n\n# This passes one argument (a list)\nprint()\ngreeter([\"Ryan\", \"Pikachu\", \"Shaq\"])\n\n# This \"unpacks\" the list again into multiple arguments\nprint()\n\ntry:\n    greeter(*[\"Ryan\", \"Pikachu\", \"Shaq\"])\nexcept TypeError as error:\n    print(error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ngreeter() takes 1 positional argument but 3 were given\n\nHello, Ryan!\nHello, Pikachu!\nHello, Shaq!\n\ngreeter() takes 1 positional argument but 3 were given\n```\n:::\n:::\n\n\nAs you see, we had to wrap some of these in try/except blocks since they are using the function incorrectly.\n\n#### Taking Multiple Keyword Arguments\n\nTo specify that a function takes a variable number of keyword arguments, you use the `**kwargs` syntax. The double asterisk (`**`) tells Python to accept any number of arguments and pack them into a dictionary.\n\nLet's look at an example that creates a simple product description:\n\n::: {#e1269495 .cell execution_count=29}\n``` {.python .cell-code}\ndef keyword_example(price, **keywords):\n    print(f\"the price is ${price}\")\n    for keyword, value in keywords.items():\n        print(f\"{keyword:>8s} => {value}\")\n\n\nkeyword_example(\n    7.99,\n    fruit=\"apple\",\n    dessert=\"tart\",\n    taste=\"yum!\",\n    coolness=\"very\",\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthe price is $7.99\n   fruit => apple\n dessert => tart\n   taste => yum!\ncoolness => very\n```\n:::\n:::\n\n\nIn this function, `price` is a regular parameter that must be provided, while `**keywords` captures any additional keyword arguments as a dictionary. The function then prints each keyword and its value.\n\nWhen using `**kwargs`, it must be the last parameter in your function definition. If you try to put other parameters after it, Python will raise an error. (Try it yourself by swapping the order of `price` and `**keywords` to see what happens!) Contrast this with the variable length positional arguments, which _could_ come before some keyword-only arguments.\n\nYou can also do the reverse: take a dictionary and \"unpack\" it into keyword arguments. Here's an example:\n\n::: {#af4a00fc .cell execution_count=30}\n``` {.python .cell-code}\ndef greeter(**greetings):\n    for greeting, people in greetings.items():\n        for person in people:\n            print(f\"{greeting} {person}\")\n\n\ngreeter(hello=[\"Ash\", \"Pikachu\"], goodbye=[\"Gary\", \"Eevee\"])\n\nprint()\n\ngreetings = {\"hello\": [\"Ash\", \"Pikachu\"], \"goodbye\": [\"Gary\", \"Eevee\"]}\ngreeter(**greetings)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello Ash\nhello Pikachu\ngoodbye Gary\ngoodbye Eevee\n\nhello Ash\nhello Pikachu\ngoodbye Gary\ngoodbye Eevee\n```\n:::\n:::\n\n\nBoth calls to `greeter()` produce the same output, showing two different ways to pass keyword arguments to a function.\n\n### Combining Variable-Length Arguments\n\nPython gives you the flexibility to combine regular parameters with variable-length arguments in the same function. Here's how it works:\n\n::: {#fa6abb27 .cell execution_count=31}\n``` {.python .cell-code}\ndef example(a, b, *arguments, **keyword_arguments):\n    print(\"a:\", a)\n    print(\"b:\", b)\n    print(\"arguments:\", arguments)\n    print(\"keyword_arguments:\", keyword_arguments)\n\n\nexample(1, 2, 3, 4, 5, hello=\"world\", color=\"orange\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na: 1\nb: 2\narguments: (3, 4, 5)\nkeyword_arguments: {'hello': 'world', 'color': 'orange'}\n```\n:::\n:::\n\n\nIn this example:\n\n- `a` and `b` are regular parameters that must be provided\n- `*arguments` collects any extra positional arguments (here: `3, 4, 5`)\n- `**keyword_arguments` collects any extra `name=value` pairs (here: `hello=\"world\"`, `color=\"orange\"`)\n\nYou'll often see these written in a shorter form as `*args` and `**kwargs` in Python code:\n\n::: {#898711cc .cell execution_count=32}\n``` {.python .cell-code}\ndef example(a, b, *args, **kwargs): ...\n```\n:::\n\n\nThis is just a common convention - `args` stands for \"arguments\" and `kwargs` for \"keyword arguments\". The important part is the `*` and `**` symbols, not the names themselves.\n\nCheck out this guide, [Python args and kwargs: Demystified](https://realpython.com/python-kwargs-and-args/), if you want to dive deeper into this topic.\n\n### Controlling How Arguments Are Passed\n\nWhen we call functions in Python, we can typically pass arguments in two ways: by their position in the parameter list or by explicitly naming them with keywords. However, Python also lets you set stricter rules about how arguments should be passed, requiring some to be positional-only or keyword-only. Here is how that looks:\n\n::: {#f54a286d .cell execution_count=33}\n``` {.python .cell-code}\ndef example(a, b, /, c, d, *, e, f): ...\n```\n:::\n\n\nThis function's parameters are divided into three groups:\n\n- Positional-only parameters (before the `/`):\n  - `a` and `b` must be passed by position\n- Standard parameters (between `/` and `*`):\n  - `c` and `d` can be passed either by position or keyword\n- Keyword-only parameters (after the `*`):\n  - `e` and `f` must be passed by keyword\n\nHere are some examples of valid and invalid ways to call the `example` function:\n\n::: {#5138eb96 .cell execution_count=34}\n``` {.python .cell-code}\n# Valid calls\n\nexample(1, 2, 3, 4, e=5, f=6)\nexample(1, 2, c=3, d=4, e=5, f=6)\n\n# Invalid calls\n\ntry:\n    example(a=1, b=2, c=3, d=4, e=5, f=6)\nexcept TypeError as error:\n    print(error)\n\n\ntry:\n    example(1, 2, 3, 4, 5, 6)\nexcept TypeError as error:\n    print(error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nexample() got some positional-only arguments passed as keyword arguments: 'a, b'\nexample() takes 4 positional arguments but 6 were given\n```\n:::\n:::\n\n\nDon't worry if this syntax seems tricky. While Python offers advanced parameter options, you won't need them too much when learning. Focus on mastering basic positional and keyword arguments first, as these cover most programming needs. For more details on advanced features, check the [Python documentation](https://docs.python.org/3/tutorial/controlflow.html#special-parameters) on special parameters.\n\n### Argument Evaluation in Function Calls\n\nWhen you call a function in Python, any expressions you use as arguments are evaluated _before_ the function receives them, so that the function only receives the final result of any expressions. In other words, the function never \"sees\" the original expression, only its evaluated result. This applies to simple arithmetic, variables, other function calls, or any other valid Python expression. Check it out:\n\n::: {#e8903c46 .cell execution_count=35}\n``` {.python .cell-code}\ndef print_name(name):\n    print(f\"the name is: '{name}'\")\n\n\nfirst_name = \"Zinedine\"\nlast_name = \"Zidane\"\n\n# A simple string as an argument\nprint_name(\"Lionel\")\n\n# Variables as arguments\nprint_name(first_name)\nprint_name(last_name)\n\n# A complex expression as an argument. Python calculates the complete string\n# first, then passes only the result to the function.\nprint_name(first_name + \" \" + last_name + \"!!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthe name is: 'Lionel'\nthe name is: 'Zinedine'\nthe name is: 'Zidane'\nthe name is: 'Zinedine Zidane!!'\n```\n:::\n:::\n\n\nFunction calls within arguments follow the same rule - they're evaluated before the outer function receives the result:\n\n::: {#242ba324 .cell execution_count=36}\n``` {.python .cell-code}\ndef double(x):\n    return x * 2\n\n\nprint(double(2))\nprint(double(double(2)))\n\nfour = 4\nprint(double(8) * four)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\n8\n64\n```\n:::\n:::\n\n\nTo sum it up, Python first evaluates all expressions in your function call, and only then passes these final values to the function.\n\n## Return Values\n\nEvery function in Python can give back (or \"return\") a value when it finishes running. We use the `return` keyword to specify what value we want to get back:\n\n```python\nimport random\n\ndef random_number():\n    return random.random()\n\nprint(random_number())\nprint(random_number())\n```\n\nLet's explore some interesting ways we can use `return` statements.\n\n### Returning Multiple Values\n\nSometimes we want a function to give back more than one piece of information. While Python doesn't technically return multiple values at once, we can package multiple values into a tuple and return that instead:\n\n::: {#e70f6a93 .cell execution_count=37}\n``` {.python .cell-code}\ndef gc_count(dna_sequence):\n    g_count = dna_sequence.count(\"G\")\n    c_count = dna_sequence.count(\"C\")\n\n    return g_count, c_count\n\n\ndna_sequence = \"ACTGACTG\"\n\n# We can unpack the returned values into separate variables\ng_count, c_count = gc_count(dna_sequence)\nprint(g_count, c_count, sep=\", \")\n\n# Behind the scenes, Python is creating a tuple\nprint(type(gc_count(dna_sequence)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2, 2\n<class 'tuple'>\n```\n:::\n:::\n\n\nThis is a convenient way to get multiple values out of a function. Python makes it easy to unpack these values into separate variables that we can use later in our code.\n\n### Functions With No Return Value\n\nWhat happens when a function doesn't explicitly return anything? Check out this little function that just prints a greeting:\n\n::: {#ea05c861 .cell execution_count=38}\n``` {.python .cell-code}\ndef say_hello(name):\n    msg = f\"Hello, {name}!\"\n    print(msg)\n\n\nsay_hello(\"Luka\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, Luka!\n```\n:::\n:::\n\n\nWhen we don't specify a return value, Python automatically returns a special value called `None`:\n\n::: {#0296f620 .cell execution_count=39}\n``` {.python .cell-code}\nresult = say_hello(\"LeBron\")\nprint(\"the result of `say_hello` is:\", result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, LeBron!\nthe result of `say_hello` is: None\n```\n:::\n:::\n\n\n`None` is Python's way of representing \"nothing\" or \"no value.\" We can also explicitly return `None` when we want to indicate that a function couldn't produce a meaningful result. Here's an example:\n\n::: {#e1777a78 .cell execution_count=40}\n``` {.python .cell-code}\ndef find_motif(dna_sequence, motif):\n    \"\"\"\n    Find the position of a motif in a DNA sequence.\n\n    Args:\n        dna_sequence (str): DNA sequence to search\n        motif (str): Motif to find\n\n    Returns:\n        position (int or None): Starting position of motif if found, None otherwise\n    \"\"\"\n    position = dna_sequence.find(motif)\n\n    if position == -1:\n        return None\n    else:\n        return position\n\n\nsequence = \"ATCGTATAGCAT\"\nprint(find_motif(sequence, \"TATA\"))\nprint(find_motif(sequence, \"GGGC\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\nNone\n```\n:::\n:::\n\n\nIn this example, if we can't find the motif, we return `None` to indicate that no result was found. This is a pretty common pattern. You'll see it in built-in methods too, like the dictionary `get()` method:\n\n::: {#7ac96537 .cell execution_count=41}\n``` {.python .cell-code}\nd = {\"a\": 1, \"b\": 2}\n\n# Tries to get a value that doesn't exist\nresult = d.get(\"c\")\n\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNone\n```\n:::\n:::\n\n\n`None` is particularly useful when you need to indicate the absence of a value or when a function couldn't complete its intended task successfully.\n\n#### Aside: Early Returns & Conditional Expressions\n\nLet's look at a few different ways to write the same function. We'll use our motif-finding code as an example:\n\n::: {#ce3da21c .cell execution_count=42}\n``` {.python .cell-code}\ndef find_motif(dna_sequence, motif):\n    position = dna_sequence.find(motif)\n\n    # Standard if/else\n    if position == -1:\n        return None\n    else:\n        return position\n```\n:::\n\n\nWhile this standard if/else structure works perfectly well, you might encounter two other common patterns when reading Python code:\n\n##### Early Return Pattern\n\nHere is the Early Return Pattern:\n\n::: {#c692bd48 .cell execution_count=43}\n``` {.python .cell-code}\ndef find_motif_version_2(dna_sequence, motif):\n    position = dna_sequence.find(motif)\n\n    if position == -1:\n        # Exit the function early if no match is found\n        return None\n\n    # Otherwise return the position\n    return position\n```\n:::\n\n\nIn this function, using the early return pattern doesn't really make that much of a difference, because it is small. You could imagine a larger function that might have a few more checks leading to more nesting of conditional statements. In these cases, the early return pattern can really shine. Check out intentionally complicated example that takes some gene expression data and does some checks on it:\n\n::: {#9b5c0ea0 .cell execution_count=44}\n``` {.python .cell-code}\n# Without early returns => complex nesting and logic\ndef process_gene_data(gene_id, sequence, expression_level):\n    if gene_id is not None:\n        if sequence is not None:\n            if len(sequence) >= 50:\n                if expression_level is not None:\n                    if expression_level > 0:\n                        # Actually process the data\n                        processed_data = {\n                            \"id\": gene_id,\n                            \"sequence\": sequence,\n                            \"expression\": expression_level,\n                            \"normalized\": expression_level / 100,\n                        }\n                        return processed_data\n                    else:\n                        return {\"error\": \"Expression level must be positive\"}\n                else:\n                    return {\"error\": \"Missing expression level\"}\n            else:\n                return {\"error\": \"Sequence too short\"}\n        else:\n            return {\"error\": \"Missing sequence\"}\n    else:\n        return {\"error\": \"Missing gene ID\"}\n```\n:::\n\n\nLet's untangle that mess using the early return pattern:\n\n::: {#106dcbee .cell execution_count=45}\n``` {.python .cell-code}\ndef process_gene_data(gene_id, sequence, expression_level):\n    if gene_id is None:\n        return {\"error\": \"Missing gene ID\"}\n\n    if sequence is None:\n        return {\"error\": \"Missing sequence\"}\n\n    if len(sequence) >= 50:\n        return {\"error\": \"Sequence too short\"}\n\n    if expression_level is None:\n        return {\"error\": \"Missing expression level\"}\n\n    if expression_level <= 0:\n        return {\"error\": \"Expression level must be positive\"}\n\n    # At this point, we know the data is valid, so we can process it.\n    processed_data = {\n        \"id\": gene_id,\n        \"sequence\": sequence,\n        \"expression\": expression_level,\n        \"normalized\": expression_level / 100,\n    }\n\n    return processed_data\n```\n:::\n\n\nAgain, this is an intentionally complex example to prove a point about early returns, but the point still stands: the second version is _much_ less complex. It shows how early returns can:\n\n- Make input validation clearer and more maintainable\n- Avoid deeply nested conditional statements\n- Separate validation logic from the main processing\n- Make it easier to add new validation steps later\n\n##### Conditional Expressions\n\nThe other pattern is using a [conditional expressions](https://docs.python.org/3/reference/expressions.html#conditional-expressions) (also called a ternary operator) for the return value:\n\n::: {#a8ac0445 .cell execution_count=46}\n``` {.python .cell-code}\ndef find_motif_version_2(dna_sequence, motif):\n    position = dna_sequence.find(motif)\n\n    # Conditional expression\n    return None if position == -1 else position\n```\n:::\n\n\nYou can also flip the condition around if it makes more sense for your specific case:\n\n::: {#6a5d1754 .cell execution_count=47}\n``` {.python .cell-code}\ndef find_motif_version_3(dna_sequence, motif):\n    position = dna_sequence.find(motif)\n\n    # Conditional expression with the check reversed\n    return position if position != -1 else None\n```\n:::\n\n\n##### Recap\n\nAll these versions do exactly the same thing, but they express it in slightly different ways:\n\n- The standard if/else is the most verbose but also the most explicit\n- The early return pattern can make code more readable when you have multiple conditions to check\n- The conditional expression is more compact but might take some getting used to\n\nThere's no \"best\" way -- they're all valid Python. However, it's good practice to be consistent within a single script or project. In situations like these, it can often make sense to pick the style that makes the most sense to you and your colleagues and stick with it.\n\nCheck out [PEP 308](https://peps.python.org/pep-0308/) for the full story behind Python's conditional expressions.\n\n## Scope & Name Resolution: Where Can You Use Your Variables? {#sec-scope}\n\nScope is a set of rules that determine where you can use different names in your code (like variables, function names, etc.). Scope is essentially the \"visibility\" of variables in different parts of your code. Let's look at a simple example to understand this better:\n\n::: {#b9b10471 .cell execution_count=48}\n``` {.python .cell-code}\ndef some_genes():\n    # Create a list of genes inside the function\n    genes = [\"nrdA\", \"nrdJ\"]\n\n    # We can use `genes` here because we're inside the function\n    # where it was created\n    print(genes)\n\n\n# Let's try to access `genes` outside the function\ntry:\n    print(genes)\nexcept NameError as error:\n    print(error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nname 'genes' is not defined\n```\n:::\n:::\n\n\nIn this code, `genes` only exists inside the `some_genes` function. When we're working inside that function, `genes` is \"in scope\", meaning we can use it. However, as soon as we step outside the function, `genes` goes \"out of scope\", and we can't access it anymore.\n\nWhen does a name come into scope? In Python, this happens when you first create it, which can happen in several ways:\n\n- Assigning a value to a variable (`x = 1`)\n- Importing a module (`import random`)\n- Defining a function (`def add(): ...`)\n- Creating function parameters (`def add(x, y): ...`)\n\nNext, let's look at how Python decides whether a name is in scope or not.\n\n### Understanding Scope: How Python Finds Variables\n\nWhen you write code, Python needs to know where to look for the variables and functions you're trying to use. It follows a specific search pattern called the LEGB Rule, which defines four levels of scope (think of scope as the \"visibility\" of variables in different parts of your code).\n\nLet's break down these levels from smallest to largest:\n\n- Local Scope (L)\n  - This is the most immediate scope, created whenever you define a function\n  - Variables created inside a function only exist inside that function\n  - Each time you call the function, Python creates a fresh local scope\n- Enclosing Scope (E)\n  - This comes into play when you have a function inside another function\n  - The outer function's scope becomes the \"enclosing\" scope for the inner function\n  - The inner function can \"see\" and use variables from the outer function\n  - We'll explore this more when we discuss nested functions\n- Global Scope (G)\n  - These are variables defined in the main body of your script\n  - They're accessible throughout your program\n- Built-in Scope (B)\n  - This is Python's pre-loaded toolkit\n  - Includes all of Python's built-in functions like `print()`, `len()`, and `max()`\n  - These tools are always available, no matter where you are in your code\n\nWhen you use a variable name, Python searches through these scopes in order (L → E → G → B) until it finds a match. If it can't find the name anywhere, you'll get a `NameError`.\n\nLet's go through each of these in more detail.\n\n### Local Scope: What Happens in a Function, Stays in a Function\n\nWhen we write functions, we create what's called a \"local scope\", which is sort of like the function's private workspace. Any variables we create inside a function only exist inside that function. Once the function finishes running, these variables disappear, and we can't access them from outside the function.\n\n_Important Note about Quarto and Jupyter Notebooks: In our notebook environment, code cells can see variables that were created in previous cells. For our examples to make sense, we need to start fresh. We'll use a special notebook command called [\"reset\"](https://ipython.readthedocs.io/en/stable/interactive/magics.html#magic-reset) to clear out any existing variables._\n\n::: {#0ba50d36 .cell execution_count=49}\n``` {.python .cell-code}\n# This is a special notebook command that clears all our previous variables.\n# You won't use this in regular Python programs, it's just for notebooks.\n%reset -f\n\n\ndef example(x):\n    # Here, we can use 'x' because it's a parameter passed to our function\n    # We can also create new variables like 'y'\n    y = 10\n    print(x * y)\n\n\n# This works fine\nexample(2)\n\n# But watch what happens when we try to use these variables outside the\n# function.\n\ntry:\n    # This will be an error because 'x' doesn't exist out here\n    print(x)\nexcept NameError as error:\n    print(error)\n\ntry:\n    # Same problem with 'y': it only existed inside the function\n    print(y)\nexcept NameError as error:\n    print(error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n20\nname 'x' is not defined\nname 'y' is not defined\n```\n:::\n:::\n\n\nThis behavior is intentional! It helps keep our functions self-contained and prevents them from accidentally interfering with code outside the function. By default, functions can read variables from the global scope (outside the function), but they can't modify them or create new global variables from inside the function.\n\n### Enclosing Scope: Functions Within Functions\n\nSometimes we write functions inside other functions (nested functions). When we do this, the inner function has access to variables defined in the outer function. This relationship creates what we call an \"enclosing scope.\"\n\nLet's look at an example:\n\n::: {#efd0e926 .cell execution_count=50}\n``` {.python .cell-code}\n%reset -f\n\n\ndef outer():\n    # These variables are accessible throughout outer() and inner()\n    x = 1\n    y = 2\n\n    def inner():\n        # This creates a new 'y' that's different from the outer y\n        y = 10\n        print(f\"from inner -- x: {x}, y: {y}\")\n        return x + y\n\n    # Calculate z using inner()\n    z = inner()\n\n    print(f\"from outer -- x: {x}, y: {y}, z: {z}\")\n\n\nouter()\n\n# Once outer() finishes running, we can't access any of its variables\n# or the inner() function anymore:\n\ntry:\n    x\nexcept NameError as error:\n    print(f\"trying to access 'x' in global scope -- {error}\")\n\ntry:\n    y\nexcept NameError as error:\n    print(f\"trying to access 'y' in global scope -- {error}\")\n\ntry:\n    z\nexcept NameError as error:\n    print(f\"trying to access 'z' in global scope -- {error}\")\n\ntry:\n    inner()\nexcept NameError as error:\n    print(f\"trying to access 'inner' in global scope -- {error}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfrom inner -- x: 1, y: 10\nfrom outer -- x: 1, y: 2, z: 11\ntrying to access 'x' in global scope -- name 'x' is not defined\ntrying to access 'y' in global scope -- name 'y' is not defined\ntrying to access 'z' in global scope -- name 'z' is not defined\ntrying to access 'inner' in global scope -- name 'inner' is not defined\n```\n:::\n:::\n\n\nIn this example, `inner()` can \"see\" and use variables defined in `outer()` because `outer()` is its enclosing scope. Think of it like `inner()` being contained within `outer()`'s environment.\n\nA few key points:\n\n- Variables defined in `outer()` are accessible inside `inner()`\n- If `inner()` creates a variable with the same name as one in `outer()`, the inner version takes precedence inside `inner()` (like `y` in our example)\n- Once `outer()` finishes running, none of its variables or the `inner()` function are accessible anymore\n\nThis concept of enclosing scope is useful when you want to create a function that needs access to variables from its surrounding context while keeping those variables private from the rest of your program.\n\n### Global Scope: The World Is Your Variable\n\nNext up is global scope, which refers to variables that are defined at the top level of your Python script. While we'll dive deeper into this when we cover modules, here's what you need to know for now:\n\n::: {#69544419 .cell execution_count=51}\n``` {.python .cell-code}\n%reset -f\n\nname = \"Pikachu\"\n\n\ndef say_hi():\n    print(f\"Hi, {name}!\")\n\n\nsay_hi()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHi, Pikachu!\n```\n:::\n:::\n\n\nIn this example, `name` is a global variable because it's defined outside of any function. Functions can \"see\" and use global variables, which is why our `say_hi()` function can access `name`.\n\nHowever, there's an important limitation: functions can't modify global variables directly. Here's what happens when we try:\n\n::: {#e342ed95 .cell execution_count=52}\n``` {.python .cell-code}\n%reset -f\n\nbest_player = \"Messi\"\n\n\ndef update_best_player():\n    best_player = \"Ronaldo\"\n\n\nprint(best_player)\nupdate_best_player()\nprint(best_player)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMessi\nMessi\n```\n:::\n:::\n\n\nNotice that `best_player` stays as \"Messi\" even after we run the function. When we create `best_player = \"Ronaldo\"` inside the function, we're actually creating a new, local variable that only exists inside the function. It doesn't affect the global `best_player`.\n\nThere is a way to modify global variables from within a function using the `global` keyword, though it's generally not recommended:\n\n::: {#96051fc5 .cell execution_count=53}\n``` {.python .cell-code}\n%reset -f\n\nbest_player = \"Messi\"\n\n\ndef update_best_player():\n    # This tells Python we want to modify the global variable\n    global best_player\n    best_player = \"Ronaldo\"\n\n\nprint(best_player)\nupdate_best_player()\nprint(best_player)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMessi\nRonaldo\n```\n:::\n:::\n\n\nWhile using `global` works, it's usually better to avoid it. Good programming practice encourage passing values as parameters and returning results from functions instead. This makes your code easier to understand and maintain.\n\n(There's also a similar feature called `nonlocal` for nested functions, but that's a topic for another day!)\n\n#### Changing Mutable Values from Within a Function {#sec-mutable-parameters}\n\nLet's look at how functions can modify certain types of data (like lists) that exist outside the function. This is a common pattern in Python, so it's important to understand what's happening.\n\n::: {#dece6a43 .cell execution_count=54}\n``` {.python .cell-code}\nnumbers = [1, 2]\n\n\ndef append():\n    numbers.append(3)\n\n\nappend()\nprint(numbers)\nappend()\nprint(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3]\n[1, 2, 3, 3]\n```\n:::\n:::\n\n\nThis works because lists in Python are mutable (changeable). Even though the list `numbers` is defined outside our function, we can still modify it from inside the function because Python is just following a reference to where that list lives in memory.\n\nHere's another example that makes this concept more explicit:\n\n::: {#8a5566a3 .cell execution_count=55}\n``` {.python .cell-code}\ndef append_to(numbers, number):\n    print(f\"inside append_to, list id is {id(numbers)}\")\n    numbers.append(number)\n\n\nsome_numbers = [10, 11]\nprint(f\"list {id(some_numbers)}: {some_numbers}\")\n\nappend_to(some_numbers, 12)\nprint(f\"list {id(some_numbers)}: {some_numbers}\")\n\nappend_to(some_numbers, 13)\nprint(f\"list {id(some_numbers)}: {some_numbers}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlist 4605307968: [10, 11]\ninside append_to, list id is 4605307968\nlist 4605307968: [10, 11, 12]\ninside append_to, list id is 4605307968\nlist 4605307968: [10, 11, 12, 13]\n```\n:::\n:::\n\n\nIn this version, we're being more explicit by passing the list as an argument to our function. The [`id()`](https://docs.python.org/3/library/functions.html#id) function shows us the memory address where our list lives. Notice how this ID stays the same throughout the program -- that's because we're always working with the same list, just referring to it by different names (`some_numbers` outside the function and `numbers` inside it).\n\nThis behavior highlights an important aspect of how Python handles variables and mutable objects: variables are like name tags that point to data, rather than containers that hold data. When we pass a list to a function, we're giving that function another name tag that points to the same data. We'll revisit this topic again when we cover classes later in the course.\n\n### Built-In Scope: Python's Ready-to-Use Tools\n\nThink of Python's built-in scope as your basic toolkit that's always available when you start Python. These are the fundamental tools that Python automatically loads for you, and they're the last place Python looks when trying to find where a name is defined (remember our LEGB rule).\n\nYou've already been using built-in functions throughout this course. For example:\n\n::: {#80ae8955 .cell execution_count=56}\n``` {.python .cell-code}\ntotal = sum(range(6))\nprint(total)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n15\n```\n:::\n:::\n\n\nThese functions like `sum()` and `print()` aren't magic, they actually live in a specific place in Python called the `builtins` module, which contains essential tools like built-in functions, constants, and error types that you can use anywhere in your code.\n\nYou can see what's available using Python's special `__builtins__` name:\n\n::: {#53f04e6a .cell execution_count=57}\n``` {.python .cell-code}\n# Let's look at the first 10 built-in tools\nfor thing in dir(__builtins__)[0:10]:\n    print(thing)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nArithmeticError\nAssertionError\nAttributeError\nBaseException\nBaseExceptionGroup\nBlockingIOError\nBrokenPipeError\nBufferError\nBytesWarning\nChildProcessError\n```\n:::\n:::\n\n\nWhile you normally don't need to, you can also access these tools directly through the `builtins` module:\n\n::: {#2dcba21f .cell execution_count=58}\n``` {.python .cell-code}\nimport builtins\n\ntotal = builtins.sum(builtins.range(6))\nbuiltins.print(total)\n\n%reset -f\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n15\n```\n:::\n:::\n\n\nThis explicit way of accessing built-ins isn't common practice. It's just helpful to understand where these tools actually live in Python's structure.\n\n### LEGB Recap\n\n```\n┌─ BUILT-IN SCOPE ───────────────────────────────┐\n│ (print, len, str, etc.)                        │\n│ ┌─ GLOBAL SCOPE ─────────────────────────────┐ │\n│ │ global_var = 100                           │ │\n│ │ ┌─ ENCLOSING SCOPE ──────────────────────┐ │ │\n│ │ │ def outer_function():                  │ │ │\n│ │ │     outer_var = 200                    │ │ │\n│ │ │ ┌─ LOCAL SCOPE ──────────────────────┐ │ │ │\n│ │ │ │ def inner_function():              │ │ │ │\n│ │ │ │     local_var = 300                │ │ │ │\n│ │ │ │     print(local_var)               │ │ │ │\n│ │ │ │     print(outer_var)               │ │ │ │\n│ │ │ │     print(global_var)              │ │ │ │\n│ │ │ └────────────────────────────────────┘ │ │ │\n│ │ └────────────────────────────────────────┘ │ │\n│ └────────────────────────────────────────────┘ │\n└────────────────────────────────────────────────┘\n```\n\n- **Built-in Scope**: Contains Python's pre-built functions and tools that are always available\n- **Global Scope**: Where your main program variables live\n- **Enclosing Scope**: Contains variables from outer functions\n- **Local Scope**: Contains variables defined within the current function\n\nWhen your code needs to use a variable, Python looks for it starting from the innermost scope (local) and works its way outward until it finds it. This is why you can use global variables inside functions, but you can't use local variables outside their functions.\n\n### Special Cases in Python Scope\n\nWhile we've covered the main rules of scope, Python has a few special situations that work a bit differently. Let's look at three interesting cases that might surprise you.\n\n#### List Comprehensions Keep Their Variables Private\n\nWhen you use a list comprehension (that shorthand way to create lists), Python handles its variables differently than regular loops. Here's what I mean:\n\n::: {#db2c86e8 .cell execution_count=59}\n``` {.python .cell-code}\n%reset -f\n\n# This list comprehension doubles each number from 0 to 4\nnumbers = [x * 2 for x in range(5)]\nprint(numbers)\n\n# Try to access 'x' - it won't work!\ntry:\n    x\nexcept NameError as error:\n    print(error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 2, 4, 6, 8]\nname 'x' is not defined\n```\n:::\n:::\n\n\nCompare this to a regular for loop, where the loop variable sticks around:\n\n::: {#5be46307 .cell execution_count=60}\n``` {.python .cell-code}\n%reset -f\n\n# Regular for loop doing the same thing\nnumbers = []\nfor x in range(5):\n    numbers.append(x * 2)\nprint(numbers)\n\n# Here we can still use 'x' - it exists!\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 2, 4, 6, 8]\n4\n```\n:::\n:::\n\n\n#### Error Variables Stay in Their Block\n\nWhen handling errors (which we'll cover more in a later tutorial), variables created in `except` blocks are only available within that block:\n\n::: {#6af422e4 .cell execution_count=61}\n``` {.python .cell-code}\ntry:\n    1 / 0\nexcept ZeroDivisionError as error:\n    print(error)  # Works here\n\n# Try to use 'error' later...\ntry:\n    print(error)  # Won't work!\nexcept NameError:\n    print(\"can't get the original 'error' here\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndivision by zero\ncan't get the original 'error' here\n```\n:::\n:::\n\n\nThese special cases are part of Python's design to prevent variables from accidentally leaking into parts of your code where they weren't intended to be used. While they might seem like quirks at first, they actually help keep your code cleaner and more predictable.\n\n## Best Practices for Writing Functions\n\nWhen you're learning to write functions, you'll find lots of advice online, some of it contradictory! However, most guidelines share a common goal: making your code easier to understand and maintain. Here are some practical tips to help you write better functions from the start.\n\n### Use Clear, Meaningful Names\n\nFunction names are like labels on laboratory equipment -- they should clearly indicate what they do:\n\n::: {#a4c00614 .cell execution_count=62}\n``` {.python .cell-code}\n# Not very helpful\ndef calc(x, y):\n    return x * y\n\n\n# Much clearer\ndef area(length, width):\n    return length * width\n```\n:::\n\n\nStay consistent with your naming style. Pick one approach and stick with it:\n\n::: {#9898e78e .cell execution_count=63}\n``` {.python .cell-code}\n# Inconsistent naming\ndef area(length, width): ...\ndef getPerimeter(l, w): ...\ndef calcvolume(x, y, z): ...\n\n\n# Better -- consistent and clear\ndef area(length, width): ...\ndef perimeter(length, width): ...\ndef volume(length, width, height): ...\n```\n:::\n\n\n### Keep Functions Focused and Concise\n\nEach function should do one specific task well. If you find your function doing multiple different things, it's usually better to split it into smaller, more focused functions.\n\nHere's an example analyzing a DNA sequence:\n\n::: {#209ea1b7 .cell execution_count=64}\n``` {.python .cell-code}\n# Too many tasks in one function\ndef process_dna_sequence(sequence):\n    has_start = sequence.startswith(\"ATG\")\n    has_stop = sequence.endswith((\"TAA\", \"TAG\", \"TGA\"))\n    gc_content = (sequence.count(\"G\") + sequence.count(\"C\")) / len(sequence)\n    return has_start, has_stop, nucleotide_counts, gc_content\n\n\n# Better: Split into focused functions\ndef has_start_codon(sequence):\n    return sequence.startswith(\"ATG\")\n\n\ndef has_stop_codon(sequence):\n    return sequence.endswith((\"TAA\", \"TAG\", \"TGA\"))\n\n\ndef calculate_gc_percentage(sequence):\n    gc_count = sequence.count(\"G\") + sequence.count(\"C\")\n    return gc_count / len(sequence) * 100\n```\n:::\n\n\n### Make Function Behavior Clear and Predictable\n\nWhen writing functions, make it obvious what data the function needs to do its job. Pass required data directly to the function rather than having it rely on information defined elsewhere in your code.\n\n::: {#6f65c5c8 .cell execution_count=65}\n``` {.python .cell-code}\n# Less clear -- relies on external data\nmeasurements = []\n\n\ndef add_measurement(new_measurement):\n    measurements.append(new_measurement)\n    return sum(measurements) / len(measurements)\n\n\n# Better -- everything the function needs is passed directly\ndef add_measurement(measurements, new_measurement):\n    measurements.append(new_measurement)\n    return sum(measurements) / len(measurements)\n```\n:::\n\n\n### When Should You Write a Function?\n\nConsider writing a function when:\n\n- You have a specific task that you can clearly define\n- You find yourself copying and pasting similar code multiple times\n- You want to make complex operations easier to understand\n- You plan to reuse the same code in different parts of your project\n\n### Summary\n\nThese guidelines will help you write functions that are easier to understand, test, and maintain. As you gain experience, you'll develop an intuition for when and how to apply these practices. Remember, the goal is to write code that both you and others can easily work with, even months or years after it was written.\n\n## Function Documentation: Making Your Code Clear and Useful {#sec-function-docs}\n\nYou could think of documentation as leaving helpful instructions for yourself and others about how your code works. While it might seem tedious at first, good documentation is like a roadmap that helps people understand and use your code correctly.\n\nLet's look at an example of a function without documentation:\n\n::: {#3304ff90 .cell execution_count=66}\n``` {.python .cell-code}\ndef math_monster_addition(a, b):\n    if a >= b:\n        return a + b\n    else:\n        return a - b\n```\n:::\n\n\nLooking at this code, you can figure out what it does, but not why it exists or when you should use it. Let's improve it by adding proper documentation:\n\n::: {#3f7ec31b .cell execution_count=67}\n``` {.python .cell-code}\ndef add_or_subtract(a, b):\n    \"\"\"\n    Performs addition or subtraction based on the relative values of two numbers.\n\n    This function models the Math Monster's arithmetic behavior.  When the\n    first number is bigger (or equal), the monster is happy and adds the\n    numbers.  When the first number is smaller, the monster gets grumpy and\n    subtracts them instead.\n\n    Args:\n        a (numeric): First number\n        b (numeric): Second number\n\n    Returns:\n        numeric: The sum of a and b if a is greater than or equal to b,\n          otherwise returns the difference (a - b).\n\n    Examples:\n        >>> add_or_subtract(5, 3)  #=>  8\n        >>> add_or_subtract(2, 7)  #=> -5\n        >>> add_or_subtract(1, 1)  #=>  2\n    \"\"\"\n    if a >= b:\n        return a + b\n    else:\n        return a - b\n```\n:::\n\n\n### Key Parts of Good Documentation\n\n- **Summary Line**: A brief, clear statement of what the function does.\n- **Description**: More detailed explanation of the function's purpose and behavior.\n- **Args**: List of parameters with their types and descriptions.\n- **Returns**: What the function gives back and under what conditions.\n- **Examples**: Real-world usage examples showing inputs and outputs.\n\n### Documentation Style\n\nWhile there are several ways to format documentation (like [Google's style](https://google.github.io/styleguide/pyguide.html#383-functions-and-methods) shown above), what matters most is consistency. Pick one style and stick with it throughout your project. You can explore different styles in [Real Python's documentation guide](https://realpython.com/documenting-python-code/).\n\n### Why Documentation Matters\n\nGood documentation:\n\n- Makes your code more accessible to others\n- Helps you remember how your own code works months later\n- Can reveal problems in your code design\n- Makes your code more maintainable\n- Enables automatic documentation generation\n\n### A Note on Writing Documentation\n\nIf you find it difficult to write clear documentation for a function, it might be a sign that the function is too complex or trying to do too many things. Use documentation as an opportunity to review and potentially simplify your code.\n\nRemember: The goal isn't to document every single line of code, but to provide enough information so that someone (including future you) can understand and use your code effectively.\n\n## Advanced Topics\n\nLet's explore a few more interesting features of Python functions that you might encounter in your programming journey.\n\n### Function Names and Aliases\n\nThink of function names as labels. You can create multiple labels (aliases) that point to the same function, similar to how you might have different names for the same thing:\n\n::: {#1c29251c .cell execution_count=68}\n``` {.python .cell-code}\ndef add1(x):\n    return x + 1\n\n\n# Create another name for the same function\nadd_one = add1\n\nprint(add1(2))  # Prints 3\nprint(add_one(2))  # Also prints 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n3\n```\n:::\n:::\n\n\nThis can be useful when you want to use a more context-appropriate name:\n\n::: {#12b39c12 .cell execution_count=69}\n``` {.python .cell-code}\ndef calculate_tax(amount):\n    return amount * 0.2\n\n\n# Using a more specific name for sales contexts\nsales_tax = calculate_tax\n\nprice = 100\ntax = sales_tax(price)  # Clearer what this represents\n```\n:::\n\n\nEven when two functions do exactly the same thing, Python treats them as distinct objects if they're defined separately:\n\n::: {#a4e8b9f2 .cell execution_count=70}\n``` {.python .cell-code}\ndef add1(x):\n    return x + 1\n\n\ndef add_one(x):\n    return x + 1\n\n\nprint(\"add1 points to\", add1)\nprint(\"add_one points to\", add_one)\nprint(\"add1 == add_one is\", add1 == add_one)\n\nprint(f\"add1(2) == {add1(2)}\")\nprint(f\"add_one(2) == {add_one(2)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nadd1 points to <function add1 at 0x1127fbf60>\nadd_one points to <function add_one at 0x1127fbe20>\nadd1 == add_one is False\nadd1(2) == 3\nadd_one(2) == 3\n```\n:::\n:::\n\n\n### Functions as Objects\n\nIn Python, functions are objects that you can work with just like numbers or strings. Here's a practical example using Python's `sorted` function:\n\n::: {#f47a0f81 .cell execution_count=71}\n``` {.python .cell-code}\n# Default sorting (alphabetical)\nwords = [\"apple\", \"pie\", \"is\", \"good\"]\nsorted_words = sorted(words)\nprint(sorted_words)\n\n# Sorting by length instead.  Here, `len` is the built-in length function.\nsorted_words = sorted(words, key=len)\nprint(sorted_words)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['apple', 'good', 'is', 'pie']\n['is', 'pie', 'good', 'apple']\n```\n:::\n:::\n\n\nWe can also write our own functions to customize sorting. Here's an example with student grades:\n\n::: {#9110f061 .cell execution_count=72}\n``` {.python .cell-code}\ndef get_grade(student):\n    return student[1]\n\n\nstudent_grades = [(\"Pikachu\", 97), (\"Charmander\", 91), (\"Bulbasaur\", 86)]\nsorted_student_grades = sorted(student_grades, key=get_grade)\nprint(sorted_student_grades)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[('Bulbasaur', 86), ('Charmander', 91), ('Pikachu', 97)]\n```\n:::\n:::\n\n\n### Lambda Expressions\n\nSometimes writing a full function is overkill for a simple operation. That's where lambda expressions come in -- they're tiny, unnamed functions:\n\n```python\nstudent_grades = [(\"Pikachu\", 97), (\"Charmander\", 91), (\"Bulbasaur\", 86)]\nsorted_student_grades = sorted(student_grades, key=lambda student: student[1])\nprint(sorted_student_grades)\n```\n\nWhile you can store lambda functions in variables, it's usually better to write a regular function if you plan to reuse the code.\n\n### Type Hints\n\nYou might see functions written with extra information about their inputs and outputs:\n\n::: {#53ff8201 .cell execution_count=73}\n``` {.python .cell-code}\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n\n\ndef add(a: int, b: int) -> int:\n    return a + b\n```\n:::\n\n\nThese are called type hints. They help document:\n\n- What kind of data a function expects (like `name: str` meaning \"name should be a string\")\n- What kind of data it returns (like `-> str` meaning \"returns a string\")\n\nKey points about type hints:\n\n- They're optional\n- Python doesn't enforce them automatically\n- They're fairly common in larger projects\n- You can ignore them while learning Python\n\nType hints are helpful for documentation and code maintenance, but your code will work perfectly fine without them!\n\n## Wrap-Up\n\nFunctions are one of the most fundamental and powerful concepts in Python programming. In this tutorial, we've covered everything from basic function syntax to advanced topics like variable-length arguments and scope rules. You've learned how to write clear, reusable code by packaging logic into well-named functions, how to work with different types of parameters, and how to use return values effectively. We've also explored important concepts like variable scope, documentation best practices, and some advanced features like lambda expressions and type hints. With this foundation in functions, you're now equipped to write more organized, maintainable, and self-documenting Python code that can be easily shared and reused across your bioinformatics projects.\n\n## Suggested Readings\n\nYou might enjoy checking out some of these resources:\n\n- Python Docs: [4.8. Defining Functions](https://docs.python.org/3/tutorial/controlflow.html#defining-functions)\n- Google Python Style Guide: [Functions and Methods](https://google.github.io/styleguide/pyguide.html#s3.8.3-functions-and-methods)\n- Real Python: [Python Scope & the LEGB Rule: Resolving Names in Your Code](https://realpython.com/python-scope-legb-rule/)\n- [Type hints cheat sheet](https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html#functions)\n\n",
    "supporting": [
      "functions_files"
    ],
    "filters": [],
    "includes": {}
  }
}