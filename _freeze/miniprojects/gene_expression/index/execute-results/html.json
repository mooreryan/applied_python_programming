{
  "hash": "7d4a80ee4590ea90dd2136e52af17258",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nauthor: \"Ryan M. Moore, PhD\"\ndate-modified: last-modified\ndate: \"2025-03-24\"\njupyter: python3\n---\n\n# Miniproject 2: Gene Expression Analysis {.unnumbered}\n\n_Note: To complete the miniproject, download the [quarto document](https://github.com/mooreryan/applied_python_programming/blob/main/miniprojects/gene_expression/index.qmd) and complete any required sections._\n\n## Overview\n\nIn this miniproject, you will analyze gene expression data to find genes that show different activity levels between two conditions (such as treatment vs. control). Gene expression analysis is a technique used in molecular biology that helps scientists understand how cells respond to different conditions by measuring changes in gene activity.\n\nThis project gives you a chance to use your Python skills on a real biological problem while practicing the concepts you've learned in the course so far.\n\n## Learning Objectives\n\nBy completing this miniproject, you will:\n\n- Practice working with functions and classes\n- Improve your ability to read example code and use it to build out longer solutions\n- Gain hands-on experience working with CSV data\n- Apply simple calculations to biological datasets\n- Learn to interpret biological results that come from computational analysis\n\n## Data Info\n\n### Input Data\n\nYou will work with a simplified gene expression dataset that shows expression values for six genes across two conditions (control and treatment). Each condition has three samples: C1, C2, C3 for control and T1, T2, T3 for treatment. Here's what the data looks like in table format:\n\n| GeneId | C1 | C2 | C3 | T1 | T2 | T3 |\n|--------|----|----|----|----|----|----|\n| gene_1 | 37 | 42 | 39 | 24 | 27 | 22 |\n| gene_2 | 39 | na | 40 | 18 | 16 | 20 |\n| gene_3 | 42 | 40 | 39 | 55 | 62 | 60 |\n| gene_4 | 38 | 40 | 39 | 96 | 85 | 89 |\n| gene_5 | 39 | 37 | 39 | 38 | na | 41 |\n| gene_6 | 39 | 40 | 41 | 38 | 35 | 42 |\n\nEach row represents a single gene. Each column contains the expression value for that gene in a specific sample.\n\nTo make this data easier to work with in Python, we'll store it as a string in CSV format:\n\n::: {#a0336129 .cell execution_count=1}\n``` {.python .cell-code}\nexpression_data_text = \"\"\"\nGeneId,C1,C2,C3,T1,T2,T3\ngene_1,37,42,39,24,27,22\ngene_2,39,na,40,18,16,20\ngene_3,42,40,39,55,62,60\ngene_4,38,40,39,96,85,89\ngene_5,39,37,39,38,na,41\ngene_6,39,40,41,38,35,42\n\"\"\".strip()\n```\n:::\n\n\nWe use `.strip()` at the end to remove any extra blank lines (whitespace) at the beginning or end of our text.\n\n### Output Data\n\nFor this problem, for each gene, you need to calculate and print out:\n\n1. The mean expression value in control samples\n2. The mean expression value in treatment samples\n3. The log2 fold change in expression (calculated as `log2(mean_treatment / mean_control)`)\n4. The gene's expression status\n\nYour output should be in tab-separated value (TSV) format. When complete, it should look something like this:\n\n```\nGeneId\tControl\tTreatment\tFC\tStatus\ngene_1\t39.3\t24.3\t-0.69\t⇣\ngene_2\t39.5\t18.0\t-1.13\t⇊\ngene_3\t40.3\t59.0\t0.55\t⇡\ngene_4\t39.0\t90.0\t1.21\t⇈\ngene_5\t38.3\t39.5\t0.04\t⇄\ngene_6\t40.0\t38.3\t-0.06\t⇄\n```\n\nFor easier reading, here is what that data looks like as a table.\n\n| GeneId | Control | Treatment | FC    | Status |\n|--------|---------|-----------|-------|--------|\n| gene_1 |    39.3 |      24.3 | -0.69 | ⇣      |\n| gene_2 |    39.5 |      18.0 | -1.13 | ⇊      |\n| gene_3 |    40.3 |      59.0 |  0.55 | ⇡      |\n| gene_4 |    39.0 |      90.0 |  1.21 | ⇈      |\n| gene_5 |    38.3 |      39.5 |  0.04 | ⇄      |\n| gene_6 |    40.0 |      38.3 | -0.06 | ⇄      |\n\nMore detailed instructions are given in the following sections.\n\n## Your Tasks\n\nPlease submit a Quarto notebook containing:\n\n- Code that transforms the gene expression data into the format described above\n- A brief analysis (1-2 paragraphs) interpreting your findings, explaining your implementation choices, and any challenges you faced\n\nFor this miniproject, I'm providing more structured guidelines to help you practice breaking down problems and to give you specific practice with functions and classes. Your solution should include these components:\n\n- A function called `mean` that calculates the average of a list of numbers, skipping any `None` values\n- A `Gene` class\n  - Required instance attributes:\n    - `gene_id`\n    - `control_values`\n    - `treatment_values`\n  - Required instance methods:\n    - `__init__`\n    - `mean_control_value`\n    - `mean_treatment_value`\n    - `fold_change`\n    - `log2_fold_change`\n    - `status`\n    - `print_expression_info`\n- Functions for parsing input data:\n  - `is_header`\n  - `parse_float`\n  - `parse_data_row`\n  - `parse_expression_data`\n- A variable called `expression_data_text` to hold the raw data\n  - Code to run the whole process:\n    - Parse `expression_data_text` into `gene_expression_data`\n    - Print a header line\n    - Loop through each `Gene` object and display its expression information\n\nThis might seem like a lot, but don't worry! In the next section, we'll break down each component, explain what they should do, and provide helpful examples to guide your solution.\n\n## Suggestions and Code Samples\n\nIn this section, we will go over suggestions on how to structure your code and some code samples that will be helpful when writing your solution. Think of these as building blocks that you can adapt to your solution!\n\n_Note: In the following code samples, you will see `pass` and `...`. These are Python's \"placeholders\" that mark where code needs to be added later. When you see these placeholders in the examples, it's a signal that you should replace them with your own code. Think of them as temporary markers saying \"your code goes here.\"_\n\n### General Tips\n\n- Use clear variable names and add comments to explain your logic.\n- Use docstrings to add context to functions and classes. This helps you remember what each function does.\n- Keep your functions short and focused on one task. Use the examples to guide you!\n- Don't forget to handle potential errors in the data, such as missing values or mathematical errors.\n- When you're stuck, review similar examples from class materials. The solutions to many problems use similar techniques to those we've already covered.\n\n### Parsing Numbers\n\nThe data for this assignment comes to you as a string. You'll need to convert some of these strings into numbers (or expression values). Converting strings to numbers (also called \"parsing\") can be done using the `int` and `float` functions:\n\n::: {#cd68169f .cell execution_count=2}\n``` {.python .cell-code}\nprint(int(\"32\"))\nprint(float(\"4.7\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n32\n4.7\n```\n:::\n:::\n\n\nThis works perfectly when the string actually represents a number. But what happens when the string you're trying to convert isn't a valid number?\n\n```python\nfloat(\"na\")\n```\n\nIf you run this code, you'll get an error:\n\n```\nValueError                Traceback (most recent call last)\nCell In[1], line 1\n----> 1 float(\"na\")\n\nValueError: could not convert string to float: 'na'\n```\n\nWe discussed this exact situation of trying to convert a non-number to a float in [Tutorial 6](https://mooreryan.github.io/practical_python/chapters/06_errors.html#reading-error-messages).\n\nWhen facing this problem, we need to decide: should our program crash, or should we handle the error gracefully? For this gene expression miniproject, we need to parse many expression values. If a few are \"bad,\" we probably don't want the entire analysis to fail. We could either assign a default value or skip the problematic entries.\n\nThese types of decisions should be based on your biological knowledge of the data and understanding of why these issues might occur.\n\nLet's consider the presence of `na` values (meaning \"data not available\"). You should ask yourself: \"What do these `na` values actually mean in my dataset?\" For example:\n\n- Was there a problem with the sample during sequencing?\n- Was there contamination?\n- Were there no reads mapping to that gene in that sample?\n- Was there a data entry error?\n\nYour answer guides your strategy. If `na` indicates unreliable data due to transcription errors (perhaps values copied incorrectly from a lab notebook), we might want to ignore these values by converting them to Python's `None` value. Alternatively, if `na` represents zero reads mapping to a gene, we should convert it to `0`.\n\nThis is where your biology expertise becomes valuable:  understanding what your data actually represents.\n\nFor this project, let's assume that `na` indicates an unknown problem, and we should convert these values to `None`. We can use `try/except` like this:\n\n::: {#88ad6231 .cell execution_count=3}\n``` {.python .cell-code}\ntry:\n    result = float(\"na\")\nexcept ValueError:\n    print(\"could not convert 'na' to a float\")\n\nresult = None\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncould not convert 'na' to a float\n```\n:::\n:::\n\n\nThis approach works well! Note that catching a `ValueError` will also handle other issues like `float(\"47b\")` or `float(\"apple pie\")` -- any invalid number format. For this miniproject, we'll treat all number conversion problems as errors to be skipped.\n\nHere's how we can write this as a reusable function:\n\n::: {#2e5d720e .cell execution_count=4}\n``` {.python .cell-code}\ndef parse_float(string):\n    try:\n        return float(string)\n    except ValueError:\n        print(f\"could not convert '{string}' to a float\")\n        return None\n```\n:::\n\n\nLet's test our function:\n\n::: {#5dd9cfb7 .cell execution_count=5}\n``` {.python .cell-code}\nprint(parse_float(\"3\"))\nprint(parse_float(\"3.14\"))\nprint(parse_float(\"4.3e-2\"))\nprint(parse_float(\"na\"))\nprint(parse_float(\"apple pie\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3.0\n3.14\n0.043\ncould not convert 'na' to a float\nNone\ncould not convert 'apple pie' to a float\nNone\n```\n:::\n:::\n\n\nIt's best to use this more robust error handling approach to parse floating-point numbers in your miniproject code instead of using the `float` function directly. This method helps your program handle unexpected inputs gracefully rather than crashing.\n\n### Arithmetic Mean & Removing `None` Values\n\nLet's remember how to calculate the arithmetic mean (average) of a list of numbers: add all the numbers together, then divide by how many numbers you have.\n\n- To add up all numbers in a list, use the `sum` function\n- To count how many items are in a list, use the `len` function\n\nWhen working with biological data, you might use functions like `parse_float` that we discussed earlier. These functions can sometimes return `None` values when they encounter data they can't convert. Before calculating the mean, you need to remove these `None` values because:\n\n1. You can't add `None` to a number (it will cause an error)\n2. `None` values shouldn't be counted when determining the list length\n\nHere are two simple ways to create a new list that contains only the non-`None` values:\n\n::: {#a46e3eb4 .cell execution_count=6}\n``` {.python .cell-code}\nnumbers = [1, None, 2, None, 3]\nfiltered_numbers = []\n\nfor number in numbers:\n    if number is not None:\n        filtered_numbers.append(number)\n\nprint(filtered_numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3]\n```\n:::\n:::\n\n\nOr, using a shorter approach called a list comprehension:\n\n::: {#1fc04266 .cell execution_count=7}\n``` {.python .cell-code}\nnumbers = [1, None, 2, None, 3]\nfiltered_numbers = [number for number in numbers if number is not None]\nprint(filtered_numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3]\n```\n:::\n:::\n\n\nYou should run filtering code like this _before_ calculating the mean. This ensures your program works correctly and doesn't crash. Your mean function might look something like this:\n\n```python\ndef mean(numbers):\n    # Filter out all the None values from `numbers`\n    filtered_numbers = ...\n\n    # Calculate the mean:\n    # ... sum up the numbers ...\n    # ... divide the sum by the total non-None elements in the list ...\n    pass\n```\n\n### The `Gene` Class\n\nOne of the requirements is that you need to create a `Gene` class to organize the expression data for each gene. [Tutorial 5](https://mooreryan.github.io/practical_python/chapters/05_classes.html#methods) contains all the information you need about building classes for this miniproject. To help you get started, I've provided a skeleton of the class you'll need to create. Each method includes comments to guide you through the implementation process.\n\n```python\nclass Gene:\n    def __init__(self, id, control_expression_values, treatment_expression_values):\n        # ... assign your instance attributes here ...\n        pass\n\n    def mean_control_value(self):\n        # ... calculate the mean value of expression in control samples\n        pass\n\n    def mean_treatment_value(self):\n        # ... calculate the mean value of expression in treatment samples\n        pass\n\n    def fold_change(self):\n        # ... calculate the fold change ...\n        pass\n\n    def log2_fold_change(self):\n        fold_change = self.fold_change()\n\n        # ... calculate log2 of the fold change ...\n        pass\n\n    def status(self):\n        log2_fold_change = self.log2_fold_change()\n\n        # Run the logic to test status of fold change\n        pass\n\n    def print_expression_info(self):\n        # get rounded mean control expression value\n\n        # get rounded mean treatment expression value\n\n        # get rounded log2 fold change\n\n        # get gene status\n\n        # print gene_id, mean_control_value, mean_treatment_value,\n        # log2_fold_change, and status separated by tabs\n        pass\n```\n\nNow, let's go over some of the individual methods.\n\n#### Mean Expression\n\nLet's see an example of how to calculate mean expression.  You should use the `mean` function that you have already written.\n\n```python\n# This is a placeholder for the mean function you will have defined.\ndef mean(numbers):\n    pass\n\ngene_1_control_expression_values = [10, None, 20]\ngene_1_treatment_expression_values = [None, 40, 30]\n\ngene_1_control_expression_mean = mean(gene_1_control_expression_values)\ngene_2_treatment_expression_mean = mean(gene_2_treatment_expression_values)\n```\n\nThis shows the basic approach if you weren't using a class structure. For your assignment, you'll need to adapt this concept to create the instance methods `mean_control_value` and `mean_treatment_value`.\n\nRemember that in a class, expression values are stored as instance attributes. You'll need to access them using `self.my_instance_attribute` syntax. This allows each gene object to calculate its own mean expression values based on the data stored within it.\n\n#### Fold Change\n\nWe are interested in finding the fold change, which is the ratio between the mean expression in the treatment group and the mean expression in the control group. Simply put:\n\n```\ngene_1_fold_change = gene_1_treatment_expression_mean / gene_1_control_expression_mean\n```\n\nCan you think of any potential errors that might occur when running this code? (For example, what happens if the control value is zero? Check [this section](https://mooreryan.github.io/practical_python/chapters/06_errors.html#exception-hierarchies) of Tutorial 6 for a hint about handling this type of error.)\n\nScientists often use the log base 2 of the fold change instead of the raw fold change. This makes the numbers easier to interpret:\n\n- A gene expressed twice as much in treatment vs control has a log2 fold change of 1\n- A gene expressed half as much in treatment vs control has a log2 fold change of -1\n- Genes with similar expression in both conditions have values close to 0\n\nHere's how to calculate the log2 fold change:\n\n::: {#c1eda89e .cell execution_count=8}\n``` {.python .cell-code}\nimport math\n\nmean_treatment_expression = 20.5\nmean_control_expression = 13.2\n\nfold_change = mean_treatment_expression / mean_control_expression\nlog2_fold_change = math.log2(fold_change)\nprint(log2_fold_change)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.6350859801469928\n```\n:::\n:::\n\n\nLike the regular fold change calculation, this code might also produce errors depending on your input values. Can you identify potential issues and how to handle them?\n\nYou'll need to implement this code as part of your `Gene` class by creating `fold_change` and `log2_fold_change` methods. Remember that since these are instance methods, you'll need to access the data using `self`.\n\n#### Gene Status\n\nFor each gene, you'll need to assign a \"status\" based on its log2 fold change value. The status shows whether a gene is upregulated (more active) or downregulated (less active) between experimental conditions. Here's how to categorize them:\n\n- Less than -1.0 -> strong downregulation (shown as `\"⇊\"`)\n- Between -1.0 and -0.5 -> slight downregulation (shown as `\"⇣\"`)\n- Between -0.5 and 0.5 -> neither up- nor downregulated (shown as `\"⇄\"`)\n- Between 0.5 and 1.0 -> slight upregulation (shown as `\"⇡\"`)\n- Greater than 1.0 -> strong upregulation (shown as `\"⇈\"`)\n\nYou should structure your code using if-elif-else statements like this:\n\n```\nif ...conditional statement...:\n    # Strong upregulation\n    return \"⇈\"\nelif ...conditional statement...:\n    # Slight upregulation\n    return \"⇡\"\nelif ...conditional statement...:\n    # Strong downregulation\n    return \"⇊\"\nelif ...conditional statement...:\n    # Slight downregulation\n    return \"⇣\"\nelse:\n    # Neither up- or downregulated\n    return \"⇄\"\n```\n\nReplace each `...conditional statement...` with the appropriate condition based on the log2 fold change values.\n\nThis code needs to be integrated into your `Gene` class. Here's how you might do it:\n\n```python\nclass Gene:\n    # ... other methods ...\n\n    def status(self):\n        log2_fold_change = self.log2_fold_change()\n\n        if ...conditional statement...:\n            # Strong upregulation\n            return \"⇈\"\n        elif ...conditional statement...:\n            # Slight upregulation\n            return \"⇡\"\n        elif ...conditional statement...:\n            # Strong downregulation\n            return \"⇊\"\n        elif ...conditional statement...:\n            # Slight downregulation\n            return \"⇣\"\n        else:\n            # Neither up- or downregulated\n            return \"⇄\"\n```\n\n#### Printing Expression Info\n\nThe `print_expression_info` method displays the gene's expression data in an organized format. This method should:\n\n1. Gets the mean control expression value (rounded to 1 decimal place)\n2. Gets the mean treatment expression value (rounded to 1 decimal place)\n3. Gets the log2 fold change (rounded to 2 decimal places)\n4. Gets the gene's expression status (shown as an arrow symbol)\n5. Prints all these values separated by tabs\n\nThis should be an instance method in your `Gene` class. To get these values, use the other methods you've defined in the class by calling them with the `self.my_method` syntax. For example, you can get the rounded mean control value with `round(self.mean_control_value(), 1)`, and the expression status with `self.status()`.\n\nThat's it for the `Gene` class! Let's move on to parsing the expression data.\n\n### Parsing Gene Expression Data\n\nParsing this data will involve:\n\n- Looping through lines in a text file: `for line in text.splitlines()`\n- Splitting a line at commas: `line.strip().split(\",\")`\n- Checking if a line is the header row: `line.startswith(\"... some string ...\")`\n\nLet's walk through the three functions you need to complete this task: `is_header`, `parse_data_row`, and `parse_expression_data`.\n\n#### `is_header`\n\n```python\ndef is_header(line):\n    # Do some check to see if line is a header or not\n    pass\n```\n\nTo identify the header line, use a function that checks if a line begins with a specific string. Look at the first line of your data file and identify what makes it different from the data rows. Use this characteristic to identify the header.\n\n#### `parse_data_row`\n\n```python\n# Each line represents a \"row\" or \"record\" of expression data for a\n# particular gene.\ndef parse_data_row(line):\n    fields = line.strip().split(\",\")\n\n    # Get the gene_id\n    gene_id = ...\n\n    # Parse the control values\n    control_values = ...\n\n    # Parse the treatment values\n    treatment_values = ...\n\n    # Create the Gene object\n    gene = Gene(gene_id, control_values, treatment_values)\n\n    return gene\n```\n\nWhen you use `line.strip().split(\",\")`, the `fields` variable becomes a list containing each item from your comma-separated line.\n\nThe list elements will be organized like this:\n- Position 0: gene id\n- Positions 1-3: expression values for the control samples (3 samples)\n- Positions 4-6: expression values for the treatment samples (3 samples)\n\nFor example:\n\n```python\nfields = [\"gene_1\", \"10\", \"15\", \"12\", \"100\", \"150\", \"120\"]\n```\n\nYou can extract these values using list slicing:\n\n```python\ngene_id = fields[0]\ncontrol_values = fields[1:4]\ntreatment_values = fields[4:7]\n```\n\nRemember that these values will be strings. You'll need to convert `control_values` and `treatment_values` to floats using your `parse_float` function and either a loop or list comprehension.\n\n#### `parse_expression_data`\n\nThis function combines the other steps we've discussed. Here's an outline to get you started:\n\n```python\ndef parse_expression_data(text):\n    # Create an empty list to store gene expression data\n\n    # For each line in the text file:\n        # Check if it's a header line\n        # If it's not a header:\n            # Parse the data line\n            gene = parse_data_row(line)\n\n            # Add the gene to your gene expression data list\n\n    # Return the complete gene expression data\n    pass\n```\n\nFill in the details using what you've learned about checking for headers and parsing data rows.\n\n### Putting It All Together\n\nAll together, your code might be organized something like this:\n\n```python\nimport math\n\n# define a mean function that can handles lists with both numbers and None\n# values\n\n# define the Gene class:\n    # define the __init__ method\n    # define the mean_control_value method\n    # define the mean_treatment_value method\n    # define the fold_change method\n    # define the log2_fold_change method\n    # define the status method\n    # define the print_expression_info method\n\n# define is_header function\n\n# define parse_float function\n\n# define parse_data_row function\n\n# define parse_expression_data function\n\n# define a variable to hold the expression data text\nexpression_data_text = \"\"\"\nGeneId,C1,C2,C3,T1,T2,T3\ngene_1,37,42,39,24,27,22\ngene_2,39,na,40,18,16,20\ngene_3,42,40,39,55,62,60\ngene_4,38,40,39,96,85,89\ngene_5,39,37,39,38,na,41\ngene_6,39,40,41,38,35,42\n\"\"\".strip()\n\n# Parse the gene expression data using your parse_expression_data function\ngene_expression_data = parse_expression_data(expression_data_text)\n\n# Print the header line\nprint(\"GeneId\", \"Control\", \"Treatment\", \"FC\", \"Status\", sep=\"\\t\")\n\n# Print the gene expression data for each gene\nfor gene in gene_expression_data:\n    gene.print_expression_info()\n```\n\nYour complete solution will likely be between 100-150 lines of code, not including docstrings and comments. This length will vary based on your coding style. For example, using list comprehensions instead of loops might make your code shorter. Adding extra helper functions or using more detailed comments will make it longer.\n\nDon't worry if this seems like a lot of code! This miniproject isn't asking you to do anything extremely complex. The challenge is bringing multiple concepts together to solve a bigger problem -- a common approach in bioinformatics workflows.\n\nIf you get stuck, remember to:\n1. Review the example code from tutorials\n2. Look back at previous assignments and miniprojects\n3. Break down each problem into smaller steps\n4. Build your solution one function at a time\n\nIf you're still having trouble, we can discuss any issues during class or student hours!\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}