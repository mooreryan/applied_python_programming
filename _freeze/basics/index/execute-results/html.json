{
  "hash": "aeaedbbe1e1b06ad35813ab3445ba8b0",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nauthor: \"Ryan M. Moore, PhD\"\ndate-modified: last-modified\ndate: \"2025-02-04\"\njupyter: python3\n---\n\n# Basics {#sec-basics}\n\nWelcome to the first chapter of _Applied Python Programming for Life Scientists: From Fundamentals to Algorithmic Thinking and Data-Driven Discovery_! In this chapter, we'll explore the fundamental building blocks of Python programming, including:\n\n- Variables and how to use them\n- Basic data types (numbers, text, and true/false values)\n- Common operators for calculations and comparisons\n- Essential built-in functions\n- How to control program flow with conditional statements\n\nThis is a comprehensive chapter that covers a lot of ground, but don't feel pressured to master everything at once. We'll be practicing these concepts throughout the course. This is your first exposure to thinking and programming in Python, and you will build up your skills throughout the course.\n\n## Introduction to Python\n\nLet's start with some high-level information about Python.\n\n### What is Python?\n\nPython is a high-level, interpreted programming language known for its approachability and readability. Created by Guido van Rossum in 1991, it has become an incredibly popular languages for data science, scientific computing, and bioinformatics.\n\n#### High level\n\nPython is a high-level programming language, meaning it handles many complex computational details automatically. For example, rather than managing computer memory directly, Python does this for you. This allows biologists and researchers to focus on solving scientific problems rather than dealing with technical computing details.\n\n#### Interpreted\n\nPython is an interpreted language, which means you can write code and run it immediately without an extra compilation step. This makes it a great choice for bioinformatics and exploratory data analysis work where you often need to:\n\n- Test different approaches to data analysis\n- Quickly prototype analysis pipelines\n- Interactively explore datasets\n\n#### Readable syntax\n\nPython's code is designed to be readable and clear, often reading almost like English. For example:\n\n```python\nif dna_sequence.startswith(start_codon) and dna_sequence.endswith(stop_codon):\n    potential_genes.append(dna_sequence)\n```\n\nEven if you're new to programming, you can probably guess that this code is looking for potential genes by checking a DNA sequence for a start and a stop codon, and if found, adding the sequence to a list of potential genes.\n\nThis readability is particularly valuable in research settings where code needs to be shared and reviewed by collaborators.\n\n### Use cases\n\nPython is a versatile language that can be used for a wide range of applications, including:\n\n- Artificial intelligence and machine learning (e.g., TensorFlow, PyTorch)\n- Web development (Django, Flask)\n- Desktop applications (PyQt, Tkinter)\n- Game development (Pygame)\n- Automation and scripting\n\nAnd of course, bioinformatics and scientific computing:\n\n- Sequence analysis and processing (Biopython, pysam)\n- Phylogenetics (ETE Toolkit)\n- Data visualization (matplotlib, seaborn)\n- Pipeline automation (snakemake for reproducible workflows)\n- Microbial ecology and microbiome analysis (QIIME)\n\n### Why Python for bioinformatics?\n\nPython has become a widely used tool in bioinformatics for several key reasons:\n\n- **Rich ecosystem**: Extensive libraries specifically for biological data analysis\n- **Active scientific community**: Regular updates and support for bioinformatics tools\n- **Integration capabilities**: Easily connects with other bioinformatics tools and databases\n- **Data science support**: Strong support for data manipulation and statistical analysis\n- **Reproducibility**: Excellent tools for creating reproducible research workflows\n\nWhether you're analyzing sequencing data, building analysis pipelines, or developing new computational methods, Python provides the tools and community support needed for modern biological research.\n\n### Good Entry to Other Languages\n\nPython is a flexible language, that supports different programming styles and paradigms.  The skills you master while learning Python are highly transferable to other languages. While Python has many specifics and quirks, the high-level concepts will take you a long way regardless of the language.\n\n### Summary\n\nTo summarize why we are using Python for this course:\n\n- It's approachable\n- It has widespread usage across academia and industry\n- Highly used in data science and life science research\n- Skills gained from learning Python are transferable to other programming languages\n\n## Variables\n\nVariables are like labeled containers for storing data in your program. Just as you might label test tubes in a lab to keep track of different samples, variables let you give meaningful names to your data, whether they're numbers, text, true/false values, or more complex information.\n\nFor example, instead of working with raw values like this:\n\n::: {#c10c5098 .cell execution_count=1}\n``` {.python .cell-code}\nif 47 > 40:\n    print(\"Temperature too high!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTemperature too high!\n```\n:::\n:::\n\n\nYou can use descriptive variables to make your code clearer:\n\n::: {#efdf51db .cell execution_count=2}\n``` {.python .cell-code}\ntemperature = 42.3\ntemperature_threshold = 40.0\n\nif temperature > temperature_threshold:\n    print(\"Temperature too high!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTemperature too high!\n```\n:::\n:::\n\n\nIn this section, we'll cover:\n\n- Creating and using variables\n- Understanding basic data types (numbers, text, true/false values)\n- Following Python's naming conventions\n- Converting between different data types\n- Best practices for using variables in scientific code\n\nBy the end, you'll be able to use variables effectively to write clear, maintainable research code.\n\n### Creating variables\n\nIn Python, you create a variable by giving a name to a value using the `=` operator. Here's a basic example:\n\n::: {#b4d2aca1 .cell execution_count=3}\n``` {.python .cell-code}\nsequence_length = 1000\nspecies_name = \"Escherichia coli\"\n```\n:::\n\n\nYou can then use these variables anywhere in your code by referring to their names. Variables can be combined to create new variables:\n\n::: {#f2b76ec5 .cell execution_count=4}\n``` {.python .cell-code}\n# Combining text (string) variables\ngenus = \"Escherichia\"\nspecies = \"coli\"\nfull_name = genus + \" \" + species\nprint(full_name)\n\n# Calculations with numeric variables\nreads_forward = 1000000\nreads_reverse = 950000\ntotal_reads = reads_forward + reads_reverse\nprint(total_reads)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEscherichia coli\n1950000\n```\n:::\n:::\n\n\nNotice how the `+` operator works differently depending on what type of data we're using:\n\n- With text (strings), it joins them together\n- With numbers, it adds them\n\nYou can also use variables in more complex calculations:\n\n::: {#f00f23cc .cell execution_count=5}\n``` {.python .cell-code}\ngc_count = 2200\ntotal_bases = 5000\ngc_content = gc_count / total_bases\nprint(gc_content)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.44\n```\n:::\n:::\n\n\nThe ability to give meaningful names to values makes your code easier to understand and modify. Instead of trying to remember what the number `5000` represents, you can use a clear variable name like `total_bases`.\n\n### Reassigning variables\n\nPython allows you to change what's stored in a variable after you create it. Let's see how this works:\n\n::: {#38795a77 .cell execution_count=6}\n``` {.python .cell-code}\nread_depth = 100\nprint(f\"Initial read depth: {read_depth}\")\n\nread_depth = 47\nprint(f\"Updated read depth: {read_depth}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInitial read depth: 100\nUpdated read depth: 47\n```\n:::\n:::\n\n\n::: { .callout-note collapse=\"false\" }\nYou will learn more about the `f\"...\"` syntax in the section on strings later in this chapter!\n:::\n\nThis flexibility extends even further.  Python lets you change not just the value, but also the type of data a variable holds:\n\n::: {#0872e08b .cell execution_count=7}\n``` {.python .cell-code}\nquality_score = 30\nquality_score = \"High quality\"\nprint(quality_score)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHigh quality\n```\n:::\n:::\n\n\nWhile this flexibility can be useful, it can also lead to unexpected behavior if you're not careful. Here's an example that could cause problems in a sequence analysis pipeline:\n\n::: {#359d2e80 .cell execution_count=8}\n``` {.python .cell-code}\n# Correctly calculates and prints the total number of sequences.\nsequences_per_sample = 1000\nsample_count = 3\ntotal_sequences = sequences_per_sample * sample_count\nprint(f\"total sequences: {total_sequences}\")\n\n# This one produces an unexpected result!\nsequences_per_sample = \"1000 sequences \"\nsample_count = 3\ntotal_sequences = sequences_per_sample * sample_count\nprint(f\"total sequences: {total_sequences}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntotal sequences: 3000\ntotal sequences: 1000 sequences 1000 sequences 1000 sequences \n```\n:::\n:::\n\n\nIn the second case, instead of performing multiplication, Python repeats the string `\"1000 sequences \"` 3 times! This is probably not what you wanted in your genomics pipeline!\n\nThis kind of type changing can be a common source of bugs, especially when:\n\n- Processing input from files or users\n- Handling missing or invalid data\n- Converting between different data formats\n\nFor this reason, it is often best is to be consistent with your variable types throughout your code, and explicitly convert between types when necessary.  We will talk more about this throughout the course.\n\n#### Augmented assignments\n\nLet's look at a common pattern when working with variables. Here's one way to increment a counter:\n\n::: {#c4d72c46 .cell execution_count=9}\n``` {.python .cell-code}\nread_count = 100\nread_count = read_count + 50\nprint(f\"Total reads: {read_count}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTotal reads: 150\n```\n:::\n:::\n\n\nPython provides a shorter way to write this using augmented assignment operators:\n\n::: {#05497102 .cell execution_count=10}\n``` {.python .cell-code}\nread_count = 100\nread_count += 50\nprint(f\"Total reads: {read_count}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTotal reads: 150\n```\n:::\n:::\n\n\nThese augmented operators combine arithmetic with assignment. Common ones include:\n\n- `+=`: augmented addition (increment)\n- `-=`: augmented subtraction (decrement)\n- `*=`: augmented multiplication\n- `/=`: augmented division\n\nThese operators are particularly handy when updating running totals or counters, like when tracking how many sequences pass quality filters. We'll explore more uses in the subsequent chapters.\n\n### Named constants\n\nSometimes you'll want to define values that shouldn't change throughout your program.\n\n::: {#e7438150 .cell execution_count=11}\n``` {.python .cell-code}\nGENETIC_CODE_SIZE = 64\nprint(f\"There are {GENETIC_CODE_SIZE} codons in the standard genetic code\")\n\nDNA_BASES = ['A', 'T', 'C', 'G']\nprint(f\"The DNA bases are: {DNA_BASES}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThere are 64 codons in the standard genetic code\nThe DNA bases are: ['A', 'T', 'C', 'G']\n```\n:::\n:::\n\n\nIn Python, we use `ALL_CAPS` names as a convention to indicate these values shouldn't change. However, it's important to understand that Python doesn't actually prevent these values from being changed. For example:\n\n::: {#1dda7626 .cell execution_count=12}\n``` {.python .cell-code}\nMIN_QUALITY_SCORE = 30\nprint(f\"Filtering sequences with quality scores below {MIN_QUALITY_SCORE}\")\n\nMIN_QUALITY_SCORE = 20  # We can change it, even though we shouldn't!\nprint(f\"Filtering sequences with quality scores below {MIN_QUALITY_SCORE}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFiltering sequences with quality scores below 30\nFiltering sequences with quality scores below 20\n```\n:::\n:::\n\n\nIn a way, Python variables are like labels on laboratory samples: you can always move a label from one test tube to another. When you write:\n\n::: {#c4911856 .cell execution_count=13}\n``` {.python .cell-code}\nDNA_BASES = ['A', 'T', 'C', 'G']\nDNA_BASES = ['A', 'U', 'C', 'G']  # Oops, switched to RNA bases!\nprint(f\"These are now RNA bases: {DNA_BASES}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThese are now RNA bases: ['A', 'U', 'C', 'G']\n```\n:::\n:::\n\n\nYou're not modifying the original list of DNA bases.  Instead, you're creating a new list and moving the `DNA_BASES` label to point to it instead of the old one. The original list isn't \"protected\" in any way. So, it's more of a convention that `ALL_CAPS` variables be treated as constants in your code, even though Python won't enforce this rule.\n\n### Dangerous assignments\n\nHere's a common pitfall when naming variables in Python: accidentally overwriting built-in functions.\n\nPython has several built-in functions that are always available, including one called `str` that converts values to strings. For example:\n\n```\nsequence = str()  # Creates an empty string\nsequence\n```\n\n::: { .callout-warning collapse=\"false\" }\nIf you convert this static code block to one that is runnable, and then actually run it, it would cause errors in the rest of the notebook in any place that uses the `str` function. If you do this, you will need to restart the notebook kernel.\n:::\n\nHowever, Python will let you use these built-in names as variable names (though you shouldn't!):\n\n```\nstr = \"ATCGGCTAA\"  # Again, don't do this!\n```\n\nNow if you try to use the `str` function later in your code:\n\n```\nquality_score = 35\nsequence_info = str(quality_score)  # This will fail!\n```\n\nYou'll get an error:\n\n```\nTypeError: 'str' object is not callable\n```\n\nThis error occurs because we've \"shadowed\" the built-in `str` function with our own variable. Python now thinks we're trying to use the string \"ATCGGCTAA\" as a function, which doesn't work!\n\nWe'll discuss errors in more detail in @sec-errors-exceptions. For now, remember to avoid using Python's built-in names (like `str`, `list`, `dict`, `set`, `len`) as variable names. You can find a complete list of built-ins in the [Python documentation](https://docs.python.org/3/library/functions.html#built-in-functions).\n\n### Naming variables\n\nClear, descriptive variable names are crucial for writing clear, understandable code. When you revisit your analysis scripts months later, good variable names will help you remember what each part of your code does.\n\n#### Valid names\n\nPython variable names can include:\n\n- Letters (A-Z, a-z)\n- Numbers (0-9, but not as the first character)\n- Underscores (\\_)\n\nWhile Python allows Unicode characters (like Greek letters), it's usually better to stick with standard characters:\n\n::: {#b27806bd .cell execution_count=14}\n``` {.python .cell-code}\nπ = 3.14  # Possible, but not recommended\npi = 3.14  # Better!\n```\n:::\n\n\n#### Case Sensitivity\n\nPython treats uppercase and lowercase letters as different characters:\n\n::: {#9abc2826 .cell execution_count=15}\n``` {.python .cell-code}\nsequence = \"ATCG\"\nSequence = \"GCTA\"\nprint(f\"{sequence} != {Sequence}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nATCG != GCTA\n```\n:::\n:::\n\n\nTo avoid confusion, stick with lowercase for most variable names.\n\n#### Naming Conventions\n\nFor multi-word variable names, Python programmers typically use `snake_case` (lowercase words separated by underscores):\n\n::: {#8d0ae7ad .cell execution_count=16}\n``` {.python .cell-code}\n# Good -- snake case\nread_length = 150\nsequence_count = 1000\nis_high_quality = True\n\n# Avoid -- camelCase or PascalCase\nreadLength = 150\nSequenceCount = 1000\n```\n:::\n\n\nOther languages may have different conventions, or sometimes a particular project might have its own conventions.  In these cases, it's probably best to go with the flow of the project you're working on.\n\n#### Guidelines for Good Names\n\nHere are some best practices for naming variables in your code:\n\nUse descriptive names that explain the variable's purpose:\n\n::: {#8d13a66a .cell execution_count=17}\n``` {.python .cell-code}\n# Clear and descriptive\nsequence_length = 1000\nquality_threshold = 30\n\n# Too vague\nx = 1000\nthreshold = 30\n```\n:::\n\n\nUse nouns for variables that hold values:\n\n::: {#5425dbd8 .cell execution_count=18}\n``` {.python .cell-code}\nread_count = 500\ndna_sequence = \"ATCG\"\n```\n:::\n\n\nBoolean variables often start with `is_`, `has_`, or similar:\n\n::: {#accf9211 .cell execution_count=19}\n``` {.python .cell-code}\nis_paired_end = True\nhas_adapter = False\n```\n:::\n\n\nCollections, which we'll cover in @sec-collections, often use plural names:\n\n::: {#35c9d806 .cell execution_count=20}\n``` {.python .cell-code}\nsequences = [\"ATCG\", \"GCTA\"]\nquality_scores = [30, 35, 40]\n```\n:::\n\n\nSometimes, it's actually nicer to use a short name for a variable.  Some common exceptions where short names are okay include:\n\n- `i`, `j`, `k` for loop indices\n- `x`, `y`, `z` for coordinates\n- Standard abbreviations like `msg` for message, `num` for number\n\nAnother tip is to keep names reasonably short while still being clear:\n\n::: {#6e1a6ed0 .cell execution_count=21}\n``` {.python .cell-code}\n# Too long\nnumber_of_sequences_passing_quality_filter = 100\n# Better\npassing_sequences = 100\n```\n:::\n\n\nRemember: your code will be read more often than it's written, both by others and by your (future) self. Clear, descriptive variable names make your code easier to understand and maintain.\n\nFor more detailed naming guidelines, check Python's [PEP 8 Style Guide](https://peps.python.org/pep-0008/#naming-conventions).\n\n## Data Types\n\nPython has many different types of data it can work with. Each data type has its own special properties and uses.\n\nIn this section, we'll cover the basic data types you'll use frequently in your code:\n\n- Numbers\n  - Integers (whole numbers, like sequence lengths or read counts)\n  - Floating-point numbers (decimal numbers, like expression levels or ratios)\n- Strings (text, like DNA sequences or gene names)\n- Boolean values (True/False, like whether a sequence passed quality control)\n\nWe'll learn how to:\n\n- Identify what type of data you're working with\n- Convert between different types when needed\n\nUnderstanding these fundamental data types is crucial for handling data correctly in your programs.\n\n### Checking the type of a value\n\nPython is a dynamically typed language, which means a variable's type can change during your program. While this flexibility is useful, you will sometimes need to figure out the type of a variable to avoid errors in your analysis.\n\nYou can check a variable's type using Python's built-in `type()` function. Here's how:\n\n::: {#59de64e6 .cell execution_count=22}\n``` {.python .cell-code}\nsequence_length = 150\nprint(type(sequence_length))\n\nsequence = \"ATCGGCTAA\"\nprint(type(sequence))\n\nis_valid = True\nprint(type(is_valid))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'int'>\n<class 'str'>\n<class 'bool'>\n```\n:::\n:::\n\n\nAs shown above, `type()` tells us exactly what kind of data we're working with. This can be helpful when debugging calculations that aren't working as expected, or verifying data is in the correct format.\n\n::: { .callout-tip collapse=\"false\" }\nDon't worry too much about the `class` keyword in the output, we'll cover classes in detail later. For now, focus on recognizing the basic types: `int` for integers, `str` for strings (text), and `bool` for True/False values.\n:::\n\n### Numeric types (int, float)\n\nPython has two main types for handling numbers:\n\n- `int`: Integers (whole numbers) for counting things like:\n  - Number of sequences\n  - Read lengths\n  - Gene counts\n- `float`: Floating-point numbers (decimals) for measurements like:\n  - Expression levels\n  - P-values\n  - GC content percentages\n\nFor readability with large numbers, you can use underscores: `1_000_000` reads is clearer than `1000000` reads.\n\n#### Numeric operations\n\nThe operators `+`, `-`, `*`, `/` are used to perform the basic arithmetic operations.\n\n::: {#de01ed65 .cell execution_count=23}\n``` {.python .cell-code}\nforward_reads = 1000\nreverse_reads = 800\nprint(forward_reads + reverse_reads)\nprint(forward_reads - reverse_reads)\nprint(forward_reads * 2)\nprint((forward_reads + reverse_reads) / 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1800\n200\n2000\n18.0\n```\n:::\n:::\n\n\nFloat division (`/`) always returns a float, whereas integer division (`//`) returns an int by performing [floor division](https://docs.python.org/3/glossary.html#term-floor-division).  Check out the difference between the two kinds of division.\n\n::: {#6ce89869 .cell execution_count=24}\n``` {.python .cell-code}\ntotal_bases = 17\nreads = 5\nprint(f\"  float division: {total_bases / reads}\")\nprint(f\"integer division: {total_bases // reads}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  float division: 3.4\ninteger division: 3\n```\n:::\n:::\n\n\nThe operator `**` is used for exponents.\n\n::: {#1f3e6d7f .cell execution_count=25}\n``` {.python .cell-code}\nprint(2**8)\nprint(8**2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n256\n64\n```\n:::\n:::\n\n\nParentheses `()` can be used to group expressions and control the order of operations. You can use parenthesis to override the standard order of operations.\n\n::: {#119705f9 .cell execution_count=26}\n``` {.python .cell-code}\n# Multiplication before addition\nprint(2 + 3 * 4)\n\n# This forces addition to happen first\nprint((2 + 3) * 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n14\n20\n```\n:::\n:::\n\n\nModulo (`%`) gives remainder of division.  Here is an example that uses the position in a gene, and tells if it is the 1st, 2nd, or 3rd base of the codon.\n\n::: {#feb1291c .cell execution_count=27}\n``` {.python .cell-code}\n# Position in the gene\nposition = 17\n\n# Which position in codon? (0, 1, or 2)\ncodon_position = position % 3\n\nprint(codon_position)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n```\n:::\n:::\n\n\n::: { .callout-warning collapse=\"false\" }\nBe careful about combining negative numbers with floor division or modulo. Here are some interesting examples showing how negative numbers behave with floor division and modulo in Python.\n\nHere are some examples using floor division with negative numbers:\n\n::: {#e10f37f0 .cell execution_count=28}\n``` {.python .cell-code}\n# Rounds down to nearest integer\nprint(17 // 5)\n# Rounds down, not toward zero\nprint(-17 // 5)\nprint(17 // -5)\nprint(-17 // -5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n-4\n-4\n3\n```\n:::\n:::\n\n\nAnd the same examples, but this time using `%`:\n\n::: {#b054f56b .cell execution_count=29}\n``` {.python .cell-code}\nprint(17 % 5)\n# Result is positive with positive divisor\nprint(-17 % 5)\n# Result has same sign as divisor\nprint(17 % -5)\nprint(-17 % -5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n3\n-3\n-2\n```\n:::\n:::\n\n\nDon't worry too much about the details of how negative numbers work with division and modulo operations. Just be aware that they can behave unexpectedly, and look up the specific rules if you need them.\n:::\n\n#### Scientific notation\n\nScientific notation is helpful when working with very large or small numbers:\n\n::: {#5430f60f .cell execution_count=30}\n``` {.python .cell-code}\n# 3.2 billion bases\ngenome_size = 3.2e9\n\n# 0.00000001 mutations per base\nmutation_rate = 1e-8\n```\n:::\n\n\nYou can use these like any other numbers:\n\n::: {#39fd2bac .cell execution_count=31}\n``` {.python .cell-code}\nprint(1.2e3 == 1200.0)\nprint(1.2e3 * 10 == 12000.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nTrue\n```\n:::\n:::\n\n\n#### Precision Considerations\n\nWhile we won't get into this too much in this course, it's good to now a bit about precision of Python's number types.\n\n##### Integers\n\nPython can handle arbitrarily large integers, limited only by memory:\n\n::: {#aa3a22bb .cell execution_count=32}\n``` {.python .cell-code}\nbig_number = 125670495610435017239401723907559279347192756\nprint(big_number)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n125670495610435017239401723907559279347192756\n```\n:::\n:::\n\n\nNot all languages have this; it's a pretty nice feature!\n\n##### Floats\n\nFloating-point numbers have limited precision (about 15-17 decimal digits). This can affect calculations:\n\n::: {#16e2dd03 .cell execution_count=33}\n``` {.python .cell-code}\nx = 0.1\ny = 0.2\n\n# Do you think this will be `0.3`?\nprint(x + y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.30000000000000004\n```\n:::\n:::\n\n\nWhile these precision errors are usually small, they can accumulate and cause problems depending on the kinds of calculations you're doing. (One classic example is dealing with money.)\n\n### Strings\n\nStrings are how Python handles text data, like sequences or gene names.\n\n::: {#60f4122a .cell execution_count=34}\n``` {.python .cell-code}\n# Strings can use single or double quotes\nsequence = 'ATCG'\ngene_name = \"nrdA\"\nprint(sequence)\nprint(gene_name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nATCG\nnrdA\n```\n:::\n:::\n\n\nStrings are immutable: once created, they cannot be modified. For example, you can't change individual bases in a sequence directly:\n\n::: {#acadf1ab .cell execution_count=35}\n``` {.python .cell-code}\ndna = \"ATCG\"\n# This would raise an error:\n# dna[0] = \"G\"\n```\n:::\n\n\nTry uncommenting that line (by deleting the `#` at the start of the line) and see what happens! If you do, you will see an error that looks something like this:\n\n```\nTypeError: 'str' object does not support item assignment\n```\n\nYou can combine strings using the `+` operator:\n\n::: {#2e9a7702 .cell execution_count=36}\n``` {.python .cell-code}\n# String concatenation\nsequence_1 = \"ATCG\"\nsequence_2 = \"GCTA\"\nfull_sequence = sequence_1 + sequence_2\nprint(\"the sequence is: \" + full_sequence)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthe sequence is: ATCGGCTA\n```\n:::\n:::\n\n\nSpecial characters can be included using escape sequences:\n\n- `\\n` for new line\n- `\\t` for tab\n- `\\\\` for backslash\n\nThis example uses tabs and newlines to format the output in a specific way:\n\n::: {#462117ae .cell execution_count=37}\n``` {.python .cell-code}\n# Formatting sequence output\nprint(\"Sequence 1:\\tATCG\\nSequence 2:\\tGCTA\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSequence 1:\tATCG\nSequence 2:\tGCTA\n```\n:::\n:::\n\n\nF-strings (format strings) are particularly useful for creating formatted output. They allow you to embed variables and expressions in strings using the `{expression}` syntax:\n\n::: {#551a262f .cell execution_count=38}\n``` {.python .cell-code}\ngene_id = \"nrdJ\"\nposition = 37_531\n\nprint(f\"Gene {gene_id} is located at position {position}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGene nrdJ is located at position 37531\n```\n:::\n:::\n\n\nF-strings can also format numbers, which can be useful for scientific notation and precision control:\n\n::: {#c4e5224e .cell execution_count=39}\n``` {.python .cell-code}\n# Two decimal places\ngc_content = 0.42857142857\nprint(f\"GC content: {gc_content:.2f}\")\n\n# Scientific notation\np_value = 0.000000342\nprint(f\"P-value: {p_value:.2e}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGC content: 0.43\nP-value: 3.42e-07\n```\n:::\n:::\n\n\nOne other neat thing about format strings is that you can automatically include the name of a variable in the output.  This is very useful for trying to figure out what is going on in your programs!\n\n::: {#06f5882a .cell execution_count=40}\n``` {.python .cell-code}\ngc_content = 0.42857142857\n\n# Print the name of the variable and its value\nprint(f\"{gc_content=}\")\n\n# This time, only show two decimals places.\nprint(f\"{gc_content=:.2f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ngc_content=0.42857142857\ngc_content=0.43\n```\n:::\n:::\n\n\nStrings can contain [Unicode characters](https://home.unicode.org/):\n\n::: {#31c9c35f .cell execution_count=41}\n``` {.python .cell-code}\n# Unicode characters\nprint(\"你好\")\nprint(\"こんにちは\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n你好\nこんにちは\n```\n:::\n:::\n\n\nWe mentioned above that unicode characters can be used as variable names, but its better to stick with basic [ASCII characters](https://en.wikipedia.org/wiki/ASCII) for code:\n\n::: {#d13a8229 .cell execution_count=42}\n``` {.python .cell-code}\n# Possible, but not recommended\nα = 0.05\nβ = 0.20\n\n# Better!\nalpha = 0.05\nbeta = 0.20\n```\n:::\n\n\nDon't worry too much about Unicode characters for now.  Just now that Python supports them.\n\n#### Common string operations\n\nString operations are useful for processing and manipulating textual data, formatting output, and cleaning up input in your applications and analysis pipelines.\n\n##### String concatenation with `+`\n\nThe `+` operator joins strings together:\n\n::: {#aed0ef6e .cell execution_count=43}\n``` {.python .cell-code}\n# Joining DNA sequences\nsequence1 = \"ATCG\"\nsequence2 = \"GCTA\"\ncombined_sequence = sequence1 + sequence2\nprint(combined_sequence)\n\n# Adding labels to sequences\ngene_id = \"nrdA\"\nlabeled_sequence = gene_id + \": \" + combined_sequence\nprint(labeled_sequence)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nATCGGCTA\nnrdA: ATCGGCTA\n```\n:::\n:::\n\n\n##### String repetition with `*`\n\nThe `*` operator repeats a string a specified number of times:\n\n::: {#5062ab33 .cell execution_count=44}\n``` {.python .cell-code}\n# Repeating DNA motifs\nmotif = \"AT\"\nrepeat = motif * 3\nprint(repeat)\n\n# Creating alignment gap markers\ngap = \"-\" * 6\nprint(gap)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nATATAT\n------\n```\n:::\n:::\n\n\n##### String indexing\n\nPython uses zero-based indexing to access individual characters in a string. \n\n::: {#1ffdf9ff .cell execution_count=45}\n``` {.python .cell-code}\ns = \"Hello, world!\"\nprint(s[0])\nprint(s[7])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nH\nw\n```\n:::\n:::\n\n\nYou can also use negative indices to count from the end:\n\n::: {#b249a663 .cell execution_count=46}\n``` {.python .cell-code}\ns = \"Hello, world!\"\nprint(s[-1])\nprint(s[-8])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n!\n,\n```\n:::\n:::\n\n\n::: { .callout-warning collapse=\"false\" }\nMany life scientists are familiar with the [R programming language](https://www.r-project.org/). \n\nBe aware that R uses one-based indexing, whereas Python uses zero-based indexing.  That is, the first character in a string in Python is 0, but in R it is 1.\n:::\n\n##### String slicing\n\nSlicing lets you extract parts of a string using the format `[start:end]`. The `end` index is exclusive:\n\n::: {#3baa8672 .cell execution_count=47}\n``` {.python .cell-code}\ns = \"Hello, World!\"\n\nprint(s[0:5])\nprint(s[7:])\nprint(s[:5])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello\nWorld!\nHello\n```\n:::\n:::\n\n\nTake note of how negative indexing works in the context of string slicing:\n\n::: {#6bd4996c .cell execution_count=48}\n``` {.python .cell-code}\ns = \"Hello, World!\"\n\nprint(s[-6:])\nprint(s[-12:-8])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWorld!\nello\n```\n:::\n:::\n\n\nGenerally, you will want to avoid writing string slicing with two negative numbers...it get's a bit tricky to read!\n\n##### String methods\n\nPython strings have lots of built-in methods for common operations. Here are a few common ones:\n\n::: {#8d6d5144 .cell execution_count=49}\n``` {.python .cell-code}\n# Clean up sequence data with leading/trailing white space\nraw_sequence = \"  ATCG GCTA  \"\nclean_sequence = raw_sequence.strip()\nprint(\"|\" + raw_sequence + \"|\")\nprint(\"|\" + clean_sequence + \"|\")\n\n# Convert between upper and lower case\nmixed_sequence = \"AtCg\"\nprint(mixed_sequence.upper())\nprint(mixed_sequence.lower())\n\n# Chaining methods\nmessy_sequence = \"  AtCg  \"\nclean_upper = messy_sequence.strip().upper()\nprint(\"|\" + clean_upper + \"|\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n|  ATCG GCTA  |\n|ATCG GCTA|\nATCG\natcg\n|ATCG|\n```\n:::\n:::\n\n\n(You will see more about method chaining in @sec-oop, for now, just make note of how it looks.)\n\n### Boolean values\n\nBoolean values represent binary states (True/False) and are used to make decisions in code:\n\n- `True` represents a condition being met\n- `False` represents a condition not being met\n\n::: { .callout-important collapse=\"false\" }\nNote the capitalization.  `True` and `False` both start with capital letters!\n:::\n\nBoolean variables often use prefixes like `is_`, `has_`, or `contains_` to more clearly indicate their purpose:\n\n```python\nis_paired_end = True\nhas_adapter = False\ncontains_start_codon = True\n```\n\nBoolean values are used in control flow, that is, they drive decision-making in your code:\n\n::: {#fac1b9bb .cell execution_count=50}\n``` {.python .cell-code}\nis_high_quality = True\nif is_high_quality:\n    print(\"Sequence passes quality check!\")\n\nhas_ambiguous_bases = False\nif has_ambiguous_bases:\n    # This won't execute because condition is False\n    print(\"Warning: Sequence contains N's\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSequence passes quality check!\n```\n:::\n:::\n\n\n::: { .callout-tip collapse=\"false\" }\nLater in this chapter (@sec-control-flow), we will go into more detail about control flow.\n:::\n\nBoolean values are created through comparisons:\n\n::: {#5813d1cf .cell execution_count=51}\n``` {.python .cell-code}\n# Quality score checking\nquality_score = 35\nprint(quality_score > 30)\nprint(quality_score < 20)\nprint(quality_score == 40)\nprint(quality_score != 35)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\nFalse\nFalse\n```\n:::\n:::\n\n\nLogical operators (`and`, `or`, `not`) combine boolean values:\n\n::: {#37da6867 .cell execution_count=52}\n``` {.python .cell-code}\n# Logical operations\nprint(True and False)\nprint(True or False)\nprint(not True)\nprint(not False)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\nTrue\nFalse\nTrue\n```\n:::\n:::\n\n\nFor example, you could use logical operators to combine multiple logical statements:\n\n::: {#893c0b7c .cell execution_count=53}\n``` {.python .cell-code}\nis_long_enough = False\nis_high_quality = True\nprint(is_long_enough and is_high_quality)\n\nis_exempt = True\nexceeds_threshold = False\nprint(is_exempt or exceeds_threshold)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\nTrue\n```\n:::\n:::\n\n\n#### Comparison Operators In Depth\n\nComparison operators are used to \"compare\" values. They return a boolean value (`True` or `False`) and are often used in conditional statements and loops to control program flow.\n\nThe basic comparison operators are:\n\n- `==`: equal to\n- `!=`: not equal to\n- `<`: strictly less than\n- `<=`: less than or equal to\n- `>`: strictly greater than\n- `>=`: greater than or equal to\n\nAdditional operators we'll cover later:\n\n- `is`, `is not`: object identity\n- `in`, `not in`: sequence membership\n\nHere are a couple examples:\n\n::: {#2b9108b4 .cell execution_count=54}\n``` {.python .cell-code}\n# Basic boolean values\nis_sunny = True\nis_raining = False\n\nprint(f\"Is it sunny? {is_sunny}\")\nprint(f\"Is it raining? {is_raining}\")\n\n# Comparison operations produce boolean results\ntemperature = 25\nis_hot = temperature > 30\nprint(f\"Is it hot? {is_hot}\")\n\n# Logical operations\nis_good_weather = is_sunny and not is_raining\nprint(f\"Is it good weather? {is_good_weather}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIs it sunny? True\nIs it raining? False\nIs it hot? False\nIs it good weather? True\n```\n:::\n:::\n\n\nHere is a list of most of them. Can you guess what the answers will be?\n\n::: {#b52efdb8 .cell execution_count=55}\n``` {.python .cell-code}\n# Comparison operations\nprint(5 == 5)\nprint(5 != 5)\nprint(5 < 3)\nprint(5 <= 3)\nprint(5 <= 5)\nprint(5 > 3)\nprint(5 >= 3)\nprint(5 >= 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\nFalse\nFalse\nTrue\nTrue\nTrue\nTrue\n```\n:::\n:::\n\n\n##### Chained Comparisons\n\nHere is a pretty neat Python feature: comparisons can be chained together, e.g. `1 < 2 < 3` is equivalent to `1 < 2 and 2 < 3`.\n\n::: {#7f911b25 .cell execution_count=56}\n``` {.python .cell-code}\n# Chained comparisons\nprint(1 < 2 < 3)\nprint(1 < 2 < 2)\nprint(1 < 2 <= 2)\n\n# This one is a bit weird, but it's valid Python!\nprint(1 < 2 > 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\nTrue\nFalse\n```\n:::\n:::\n\n\nThe comparisons operators can also be used to compare the values of variables.\n\n::: {#495e4016 .cell execution_count=57}\n``` {.python .cell-code}\n# Check if value is in valid range\ncoverage = 30\nprint(10 < coverage < 50)\n\nquality_score = 35\nprint(20 < quality_score <= 40)\n\n# Multiple range checks\ntemperature = 37.2\nprint(37.0 <= temperature <= 37.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nTrue\nTrue\n```\n:::\n:::\n\n\nCompare that to the same example without the chained comparisons:\n\n::: {#6a5049d2 .cell execution_count=58}\n``` {.python .cell-code}\n# Check if value is in valid range\ncoverage = 30\nprint(10 < coverage and coverage < 50)\n\nquality_score = 35\nprint(20 < quality_score and quality_score <= 40)\n\n# Multiple range checks\ntemperature = 37.2\nprint(37.0 <= temperature and temperature <= 37.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nTrue\nTrue\n```\n:::\n:::\n\n\n::: { .callout-tip collapse=\"false\" }\nUsing chained comparisons judiciously can really tidy up your code!\n:::\n\n##### Comparing Strings & Other Values\n\nPython's comparison operators work with many types of values, not just numbers, allowing comparisons between various types of data. Be careful though: while some comparisons may seem intuitive, others might require careful consideration or custom implementation.\n\n::: {#33f075b1 .cell execution_count=59}\n``` {.python .cell-code}\n# Comparison of different types\nprint(\"Hello\" == \"Hello\")\nprint(\"Hello\" == \"World\")\nprint(\"Hello\" == 5)\nprint(\"Hello\" == True)\n\n# Some non-numeric types also have a natural ordering.\nprint(\"is 'a' < 'b'?\", \"a\" < \"b\")\nprint(\"is 'a' < 'A'?\", \"a\" < \"A\")\n\n# This is a bit weird, but it's valid Python!\n#\n# You can look into what's going on here if you're interested,\n# but you don't need to worry about it otherwise.\nprint([1, 2, 3] <= [10, 20, 30])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\nFalse\nFalse\nis 'a' < 'b'? True\nis 'a' < 'A'? False\nTrue\n```\n:::\n:::\n\n\n#### Logical Operators In Depth\n\nLogical operators give you a way to combine or modify simple yes/no conditions in your code, much like how you might combine criteria when filtering data in Excel.\n\nYou can use logical operators to express conditions like:\n\n- \"If a DNA sequence is **both** longer than 250 bases **AND** has no ambiguous bases, include it in the analysis\"\n- \"If a gene is **either** highly expressed **OR** shows significant differential expression, flag it for further study\"\n- \"If a sample is **NOT** properly labeled, skip it and log a warning\"\n\nThese operators (`and`, `or`, `not`) work similarly to the way we combine conditions in everyday language. Just as you might say \"I'll go for a run if it's not raining AND the temperature is above 60°F,\" you can write code that makes decisions based on multiple criteria.\n\nHere are a couple of examples:\n\n```python\n# In a sequence quality filtering pipeline\n#\n# Both conditions must be true\nif sequence_length >= 250 and quality_score >= 30:\n    keep(sequence)\n\n# In a variant calling pipeline\n#\n# Either condition being true is sufficient\nif mutation_frequency > 0.01 or supporting_reads >= 100:\n    report(variant)\n\n# In a data validation step\n#\n# Triggers if the condition is false\nif not sample_id.startswith('PROJ_'):\n    warn_user(sample_id)\n```\n\n(If you try to run the above code, you will get errors, because we haven't defined the functions `keep`, `report`, and `warn_user`.  It's just to illustrate the point.)\n\nThese operators are sort of like the digital equivalent of the decision-making process you use in the lab: checking multiple criteria before proceeding with an experiment, or having alternative procedures based on different conditions.\n\n##### Behavior of logical operators\n\nLet's take a closer look at how Python's logical operators (`and`, `or`, `not`) work. As I mentioned in the last section, these operators give us ways to check multiple conditions.  In plain language:\n\n- `and`: Requires ALL criteria to be met (e.g., both proper staining AND correct cell count)\n- `or`: Accepts ANY of several criteria (e.g., either elevated temperature OR positive test result)\n- `not`: Reverses a condition (e.g., _NOT_ contaminated)\n\nHere's a [truth table](https://en.wikipedia.org/wiki/Truth_table) showing all possible combinations.\n\n| **A** | **B** | **A and B** | **A or B** | **not A** |\n| ----- | ----- | ----------- | ---------- | --------- |\n| True  | True  | True        | True       | False     |\n| True  | False | False       | True       | False     |\n| False | True  | False       | True       | True      |\n| False | False | False       | False      | True      |\n\nHere are the rules:\n\n- `and` only gives True if both conditions are True\n- `or` gives True if at least one condition is True \n- `not` flips True to False and vice versa\n\nPython can also evaluate non-boolean values (values that aren't strictly `True` or `False`) using these operators. We call values that Python treats as `True` \"truthy\" and values it treats as `False` \"falsy\". This can be useful important when working with different types of data in your programs or analysis pipelines.\n\n##### Understanding \"Truthy\" and \"Falsy\" Values\n\nIn Python, every value can be interpreted as either \"true-like\" (truthy) or \"false-like\" (falsy) when used in logical operations. We do something similar in biology, where we might categorize results as \"positive\" or \"negative\" even though the underlying data is more complex than a simple yes/no answer.\n\n\"Falsy\" values as representing empty, zero, or null states, or, the _absence of meaningful data_. Python considers the following values as \"falsy\":\n\n- `False`: The boolean False value\n- `None`: Python's way of representing \"nothing\" or \"no value\" (e.g., like a blank entry in a spreadsheet)\n- Any form of zero (like `0`, `0.0`)\n- Empty containers:\n  - Empty string (`\"\"`)\n  - Empty list (`[]`)\n  - Empty set (`set()`)\n  - Empty dictionary (`{}`)\n\nEverything else is considered \"truthy\".  That is, it represents the presence of some meaningful value or data.\n\nI realize that the above is a bit abstract, so let's check out a few examples to try and make it more clear.  We can use Python's built-in [bool()](https://docs.python.org/3/library/functions.html#bool) function to explicitly check whether Python considers a value truthy or falsy.\n\nHaving no samples is falsy:\n\n::: {#d2c89ffe .cell execution_count=60}\n``` {.python .cell-code}\nsample_count = 0\n# False (no samples)\nprint(bool(sample_count))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\n```\n:::\n:::\n\n\nHaving an empty list of IDs is falsy:\n\n::: {#bd11a8d0 .cell execution_count=61}\n``` {.python .cell-code}\nsample_ids = []\n# False (empty list of IDs)\nprint(bool(sample_ids))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\n```\n:::\n:::\n\n\nHaving an empty data table (represented as a dictionary), is falsy:\n\n::: {#61f9ed6d .cell execution_count=62}\n``` {.python .cell-code}\npatient_data = {}\n# False (empty data table)\nprint(bool(patient_data))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\n```\n:::\n:::\n\n\nHaving some samples is truthy:\n\n::: {#4189746b .cell execution_count=63}\n``` {.python .cell-code}\nsample_count = 5\n# True (we have samples)\nprint(bool(sample_count))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\nHaving some sample IDs is truthy: \n\n::: {#3bb96826 .cell execution_count=64}\n``` {.python .cell-code}\nsample_ids = [\"A1\", \"B2\"]\n# True (we have some IDs)\nprint(bool(sample_ids))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\nHaving some patient data is truthy: \n\n::: {#b7d8c894 .cell execution_count=65}\n``` {.python .cell-code}\npatient_data = {\"age\": 45}\n# True (we have some data)\nprint(bool(patient_data))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\nJust to repeat myself, the basic idea is: absence of data is falsy, presence of data is truthy.\n\nUnderstanding truthy and falsy values becomes particularly useful when writing conditions in your code, like checking whether you have data before proceeding with analysis.  \n\nThis example is sort of like saying, \"If there are some sample IDs, then process them.\"\n\n```python\nif sample_ids:\n    process_samples(sample_ids)\nelse:\n    print(\"No samples to process\")\n```\n\nYou will often see code that relies of the truthiness or falsiness of values \"in the wild\" and as we work through the course.\n\n##### Using `and` and `or` for Control Flow\n\nOne kind of neat thing about the logical operators is that you can directly use them as a type of control flow. (We talk more about control flow in the next section: @sec-control-flow.)\n\n###### `and`\n\nGiven an expression `a and b`, the following steps are taken:\n\n1. First, evaluate `a`.\n2. If `a` is \"falsy\", then return the value of `a`.\n3. Otherwise, evaluate `b` and return its value.\n\nCheck it out:\n\n::: {#f521442c .cell execution_count=66}\n``` {.python .cell-code}\na = \"apple\"\nb = \"banana\"\nresult = a and b\nprint(result)\n\nname = \"Maya\"\nage = 45\nresult = age >= 18 and f\"{name} is an adult\"\nprint(result)\n\nname = \"Amira\"\nage = 15\nresult = age >= 18 and f\"{name} is an adult\"\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbanana\nMaya is an adult\nFalse\n```\n:::\n:::\n\n\n###### `or`\n\nGiven an expression `a or b`, the following steps are taken:\n\n1. First, evaluate `a`.\n2. If `a` is \"truthy\", then return the value of `a`.\n3. Otherwise, evaluate `b` and return its value.\n\nLet's return to the previous example, but this time we will use `or` instead of `and`.\n\n::: {#87701577 .cell execution_count=67}\n``` {.python .cell-code}\na = \"apple\"\nb = \"banana\"\nresult = a or b\nprint(result)\n\nname = \"Maya\"\nage = 45\n# Observe that this code isn't really doing what we want it to do.\n# `result` will be True, rather than \"Maya is an adult\".\n# That's because it should be using `and`\n#   ...again, it's just for illustration.\nresult = age >= 18 or f\"{name} is an adult\"\nprint(result)\n\nname = \"Amira\"\nage = 15\n# This code is a bit obscure, and you probably wouldn't\n# write it like this in practice.  But it illustrates the\n# point.\nresult = age >= 18 or f\"{name} is not an adult\"\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\napple\nTrue\nAmira is not an adult\n```\n:::\n:::\n\n\n###### Short-Circuiting\n\nThe above behavior is known as short-circuiting.  You can read a bit more about it in [this section of The Python Tutorial](https://docs.python.org/3/tutorial/datastructures.html#more-on-conditions).\n\n::: { .callout-tip collapse=\"false\" }\nHere's a fun tip.  I knew that [The Python Tutorial](https://docs.python.org/3/tutorial/index.html) covered short-circuiting somewhere in in, but couldn't remember which section it was in.  So, I used this book's [search app](https://suhotro.appliedpythonprogramming.com/) to find it.  \n\nTry searching for \"short circuit evaluation\" and see what you find.\n\n(Turns out is was in the section on [Data Structures](https://docs.python.org/3/tutorial/datastructures.html).)\n:::\n\n## Control Flow {#sec-control-flow}\n\nControl flow as the decision-making logic in your code.  Just as you make decisions in the lab (\"if the pH is too high, add buffer\"), your code needs to make decisions about how to handle different situations.\n\nIn this section, we'll cover several ways to build these decision points into your code:\n\n- Simple `if` statements (like \"if the sequence quality is low, skip it\")\n- `if-else` statements (like \"if the gene is expressed, mark it as active; otherwise, mark it as inactive\")\n- `if-elif-else` chains (for handling multiple possibilities, like taking different actions depending on a range of p-values)\n- Nested conditions (for more complex decisions -- we will see some examples of these too)\n\nControl flow is essential for writing programs that can:\n\n- Handle different scenarios\n- Make decisions based on data\n- Conditionally process data\n- Respond to user input\n\nNow, enough waffling, let's see some code!\n\n### `if` Statements\n\nAn `if` statement is essentially a basic yes/no check.  Here, we print a message if the quality score is above a certain threshold.\n\n::: {#0cc7d5d4 .cell execution_count=68}\n``` {.python .cell-code}\nquality_score = 35\n\nif quality_score > 30:\n    print(\"Sample passes QC\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSample passes QC\n```\n:::\n:::\n\n\n### `if-else` Statements\n\nRather than doing nothing if the `if` condition does not hold, `if-else` statements handle two alternative outcomes.\n\n::: {#5f2f5647 .cell execution_count=69}\n``` {.python .cell-code}\nexpression_level = 1.5\n\nif expression_level > 1.0:\n    print(\"Gene is upregulated\")\nelse:\n    print(\"Gene is not upregulated\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGene is upregulated\n```\n:::\n:::\n\n\nIn that example, we wanted to give the user different information depending if the gene was upregulated or not.\n\n### `if-elif-else` Chains\n\nThese are used for handling multiple possibilities, like categorizing p-values or expression levels:\n\n::: {#94a79ea9 .cell execution_count=70}\n``` {.python .cell-code}\np_value = 0.03\nif p_value < 0.01:\n    print(\"Highly significant\")\nelif p_value < 0.05:\n    print(\"Significant\")\nelse:\n    print(\"Not significant\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSignificant\n```\n:::\n:::\n\n\n### Multiple Conditions\n\nSometimes you need to check multiple criteria, like filtering sequencing data:\n\n::: {#e8835f0d .cell execution_count=71}\n``` {.python .cell-code}\nread_length = 100\ngc_content = 0.45\nquality_score = 35\n\nif read_length >= 100 and quality_score > 30 and 0.4 <= gc_content <= 0.6:\n    print(\"Read passes all quality filters\")\nelse:\n    print(\"Read filtered out\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRead passes all quality filters\n```\n:::\n:::\n\n\n::: { .callout-tip collapse=\"false\" }\nPay attention to this example...it may come in handy in your homework assignments!\n:::\n\n### Nested Conditional Statements\n\nConditional statements can also be nested. Here is some code that is checking if someone can go to the beach. If they are not at work, and the weather is sunny, then they can go to the beach.\n\nLet's look at a couple of different ways we might express this.  Remember that plain English can be ambiguous, so there may be multiple ways we can interpret the task.\n\n::: {#80a959a1 .cell execution_count=72}\n``` {.python .cell-code}\nat_work = False\nweather = \"sunny\"\n\nif weather == \"sunny\" and not at_work:\n    print(\"It's sunny and you are not at work, let's go to the beach!\")\nelse:\n    print(\"We can't go to the beach today for some reason.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIt's sunny and you are not at work, let's go to the beach!\n```\n:::\n:::\n\n\nLet's move the check for at_work nested inside the if statement that checks\nthe weather. Note that this code isn't equivalent to the previous code, but since we're in the section about nested conditionals, it will give you a good idea about how to subtly change the meaning of the code!\n\n::: {#ebab2e87 .cell execution_count=73}\n``` {.python .cell-code}\nif weather == \"sunny\":\n    if at_work:\n        print(\"You are at work and can't go to the beach.\")\n    else:\n        print(\"It's sunny and you are not at work, let's go to the beach!\")\nelse:\n    print(\"It's not sunny, so we can't go to the beach regardless.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIt's sunny and you are not at work, let's go to the beach!\n```\n:::\n:::\n\n\nJust so that it is very clear, let's write code that behaves the same, but un-nested.\n\n::: {#372ea62f .cell execution_count=74}\n``` {.python .cell-code}\nif weather == \"sunny\" and at_work:\n    print(\"You are at work and can't go to the beach.\")\nelif weather == \"sunny\":\n    print(\"It's sunny and you are not at work, let's go to the beach!\")\nelse:\n    print(\"It's not sunny, so we can't go to the beach regardless.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIt's sunny and you are not at work, let's go to the beach!\n```\n:::\n:::\n\n\n::: { #tip-01-nested-conditionals .callout-tip title=\"Stop & Think\" collapse=\"false\" }\nWhich of the above two examples do think is more clear and why?\n:::\n\n### General Control Flow Tips\n\nControl flow provides a way to insert decision points into your code.  Here are a few tips to keep in mind:\n\n- Conditions are checked in order from top to bottom\n- Only the first matching condition's code block will execute\n- Keep your conditions clear and logical\n- Try to avoid deeply nested conditions as they can become confusing\n\n### A Note on Keeping Things Simple\n\nJust as you want to keep your experimental protocols clear and straightforward, the same principle applies to writing conditional statements in your code. Trying to follow along with a set of deeply nested if-statements is like trying to follow a complicated diagnostic flowchart: the more branches and decision points you add, the easier it is to lose track of where you are.\n\nFor example, imagine designing a PCR troubleshooting guide where each problem leads to three more questions, each with their own set of follow-up questions. While technically complete, it would be challenging for anyone to follow correctly. The same goes for code.  When we stack too many decisions inside other decisions, we're setting ourselves up for confusion.\n\nHere's why keeping conditions simple matters:\n\n- Each decision point is an opportunity for something to go wrong \n- Complex nested conditions are harder to debug\n- Simple, clear code is easier for you and your colleagues to review and understand\n\nIf you find yourself writing deeply nested conditions, it's often a sign to step back and consider whether there's a clearer way to structure your code.\n\n## Basic Built-in Functions\n\nPython's built-in functions are your basic toolkit.  They're always there when you need them, no special setup required. You will use them a ton, and get to know them well!\n\nHere are some of commonly used built-in functions:\n\n- `print()`: Displays your data or results\n- `len()`: Counts the length of something\n- `abs()`: Gives you the absolute value\n- `round()`: Tidies up decimal numbers\n- `min()` and `max()`: Find the lowest and highest values\n- `sum()`: Adds up a collection of numbers\n- `type()`: Tells you what kind of data you're working with (helpful for debugging)\n\nLet's check out some examples!\n\n### print()\n\n::: {#0439d220 .cell execution_count=75}\n``` {.python .cell-code}\n# Printing experimental results\nprint(\"Gene expression analysis complete!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGene expression analysis complete!\n```\n:::\n:::\n\n\n### len()\n\n::: {#e5f3c658 .cell execution_count=76}\n``` {.python .cell-code}\n# Checking sequence length\ndna_sequence = \"ATCGATCGTAGCTAGCTAG\"\nlength = len(dna_sequence)\nprint(f\"This DNA sequence is {length} base pairs long.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis DNA sequence is 19 base pairs long.\n```\n:::\n:::\n\n\n### abs()\n\n::: {#ca4f478f .cell execution_count=77}\n``` {.python .cell-code}\n# Working with expression fold changes\nfold_change = -2.5\nabsolute_change = abs(fold_change)\nprint(f\"The absolute fold change is {absolute_change}x.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe absolute fold change is 2.5x.\n```\n:::\n:::\n\n\n### round()\n\n::: {#03775aaf .cell execution_count=78}\n``` {.python .cell-code}\n# Cleaning up p-values\np_value = 0.0000234567\nrounded_p = round(p_value, 6)\nprint(f\"p-value = {rounded_p}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\np-value = 2.3e-05\n```\n:::\n:::\n\n\n### min() and max()\n\n::: {#821d1ddf .cell execution_count=79}\n``` {.python .cell-code}\n# Analyzing multiple expression values\nexpression_levels = [10.2, 5.7, 8.9, 12.3, 6.8]\nlowest = min(expression_levels)\nhighest = max(expression_levels)\nprint(f\"Expression range: {lowest} to {highest}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExpression range: 5.7 to 12.3\n```\n:::\n:::\n\n\n### sum()\n\n::: {#8e6d7b97 .cell execution_count=80}\n``` {.python .cell-code}\n# Calculating average coverage\ncoverage_values = [15, 22, 18, 20, 17]\naverage_coverage = sum(coverage_values) / len(coverage_values)\nprint(f\"Average sequencing coverage: {average_coverage}x\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAverage sequencing coverage: 18.4x\n```\n:::\n:::\n\n\n### type()\n\n::: {#1de122a3 .cell execution_count=81}\n``` {.python .cell-code}\n# Checking data types\ngene_name = \"nrdA\"\ndata_type = type(gene_name)\nprint(f\"The variable gene_name is of type: {data_type}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe variable gene_name is of type: <class 'str'>\n```\n:::\n:::\n\n\nTo use these functions, just type the function name followed by parentheses containing your data (the \"arguments\"). Some functions, like `min()` and `max()`, can handle multiple inputs, which is handy when comparing several values at once.\n\n## Wrap-Up\n\nIn this chapter, we covered some fundamentals of Python programming that you'll use throughout your bioinformatics work:\n\n- **Variables** help you store and manage data with meaningful names\n- **Data types** like numbers, strings, and booleans let you work with different kinds of data\n- **Control flow** statements help your programs make decisions based on data\n- **Built-in functions** provide essential tools for common programming tasks\n\nRemember:\n\n- Choose clear, descriptive variable names\n- Be mindful of data types when performing operations\n- Keep conditional logic as simple as possible\n- Make use of Python's built-in functions for common tasks\n\nThese basics form the foundation for more advanced programming concepts we'll explore in future chapters. Practice working with these fundamentals! They are the tools you will come back to again and again.\n\nFinally, don't expect everything to click for you at once. Programming is a skill that develops over time with continued practice. Focus on understanding one concept at a time, and remember that you can always refer back to this chapter as a reference.\n\nNext up, we'll build on these basics to work with more complex data structures and write functions of our own!\n\n## Practice Problems\n\nTake a look at @sec-basics-practice-problems for some practice problems. Try working through them. Applying the concepts from this chapter is one of the most effective ways to learn!\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}