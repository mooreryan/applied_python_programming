{
  "hash": "96e9305b74e5a21561b46a95e480cbd9",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nauthor: \"Ryan M. Moore, PhD\"\ndate-modified: last-modified\ndate: \"2025-05-23\"\njupyter: python3\n---\n\n# Basics: Practice Problem Solutions {#sec-basics-practice-problem-solutions}\n\n## Solution to [Problem @sec-assigning-variables-printing]\n\n::: {#d2ec7059 .cell execution_count=1}\n``` {.python .cell-code}\nspecies_name = \"Escherichia coli\"\ngenome_size = 4_600_000\n\nprint(f\"The species {species_name} has a genome size of {genome_size} base pairs.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe species Escherichia coli has a genome size of 4600000 base pairs.\n```\n:::\n:::\n\n\n## Solution to [Problem @sec-calculating-formatting-gc-content]\n\n::: {#7fcce2c8 .cell execution_count=2}\n``` {.python .cell-code}\ngc_count = 19_123\ntotal_bases = 40_000\n\ngc_content = gc_count / total_bases\nprint(f\"GC content: {gc_content:.2f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGC content: 0.48\n```\n:::\n:::\n\n\n## Solution to [Problem @sec-string-slicing-concatenation]\n\n::: {#93bb9652 .cell execution_count=3}\n``` {.python .cell-code}\nsequence = \"ACTGGTCAA\"\nprint(f\"{sequence=}\")\n\nfirst_four = sequence[0:4]\nlast_five = sequence[4:9]\nprint(f\"{first_four=}; {last_five=}\")\n\ncombined = first_four + last_five\nprint(f\"{combined=}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsequence='ACTGGTCAA'\nfirst_four='ACTG'; last_five='GTCAA'\ncombined='ACTGGTCAA'\n```\n:::\n:::\n\n\n## Solution to [Problem @sec-working-booleans-conditional-execution]\n\n::: {#7992e835 .cell execution_count=4}\n``` {.python .cell-code}\nquality_score = 28\nif quality_score >= 30:\n    print(\"Pass\")\nelse:\n    print(\"Fail\")\n\nis_long_enough = True\nis_high_quality = False\n\nif is_long_enough and is_high_quality:\n    print(\"Accepted\")\nelse:\n    print(\"Rejected\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFail\nRejected\n```\n:::\n:::\n\n\n## Solution to [Problem @sec-using-builtin-functions-list-ops]\n\n::: {#1ddba473 .cell execution_count=5}\n``` {.python .cell-code}\nexpression_levels = [2.1, 3.4, 1.8, 6.2, 4.0]\n\nmin_value = min(expression_levels)\nmax_value = max(expression_levels)\nmean_value = sum(expression_levels) / len(expression_levels)\n\n\nprint(f\"min: {min_value}\")\nprint(f\"max: {max_value}\")\nprint(f\"mean: {mean_value}\")\n\nfirst_item = expression_levels[0]\nprint(f\"type of first item: {type(first_item)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmin: 1.8\nmax: 6.2\nmean: 3.5\ntype of first item: <class 'float'>\n```\n:::\n:::\n\n\n## Solution to [Problem @sec-truthy-falsy-checking-emptiness]\n\n::: {#31b8e8ae .cell execution_count=6}\n``` {.python .cell-code}\nsequences = []\n\nif sequences:\n    print(\"Sequences loaded!\")\nelse:\n    print(\"No sequences found!\")\n\nprint(bool(\"\"))\nprint(bool(\"AGTC\"))\nprint(bool(0))\nprint(bool(3.14))\nprint(bool([]))\nprint(bool([\"AGTC\"]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNo sequences found!\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\n```\n:::\n:::\n\n\n## Solution to [Problem @sec-avoiding-builtin-name-shadowing]\n\n::: {#33370bff .cell execution_count=7}\n``` {.python .cell-code}\nstr = \"ACTG\"\nprint(len(str))\n\n# Note: Don't worry about the try/except for now.\n# There will be a whole chapter about it later!\ntry:\n    pi = str(3.14)\nexcept TypeError as error:\n    print(f\"There was an error! {error=}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4\nThere was an error! error=TypeError(\"'str' object is not callable\")\n```\n:::\n:::\n\n\n## Solution to [Problem @sec-filtering-multiple-criteria]\n\n::: {#3df9acd4 .cell execution_count=8}\n``` {.python .cell-code}\nread_length = 120\ngc_content = 0.55\nquality_score = 32\n\nread_length_good = read_length >= 100\ngc_content_good = 0.4 <= gc_content <= 0.6\nquality_score_good = quality_score > 30\n\nif read_length_good and gc_content_good and quality_score_good:\n    print(\"Read passes all quality filters\")\nelse:\n    print(\"Read filtered out\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRead passes all quality filters\n```\n:::\n:::\n\n\n## Solution to [Problem @sec-formatting-scientific-output]\n\n::: {#139584b1 .cell execution_count=9}\n``` {.python .cell-code}\ngene_id = \"nrdA\"\np_value = 0.000012345\n\nprint(f\"Gene {gene_id} => {p_value:.2e}\")\n\nif p_value < 0.01:\n    print(\"Highly significant\")\nelif p_value < 0.05:\n    print(\"Significant\")\nelif p_value < 0.10:\n    print(\"Almost significant\")\nelse:\n    print(\"Not significant\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGene nrdA => 1.23e-05\nHighly significant\n```\n:::\n:::\n\n\n## Solution to [Problem @sec-sequence-analysis]\n\n::: {#d986b7cd .cell execution_count=10}\n``` {.python .cell-code}\ndna_sequence = \"TGacTGatcGT\".upper()\n\nsequence_length = len(dna_sequence)\n\na_count = dna_sequence.count(\"A\")\nc_count = dna_sequence.count(\"C\")\ng_count = dna_sequence.count(\"G\")\nt_count = dna_sequence.count(\"T\")\n\nambiguous_count = dna_sequence.count(\"N\")\n\ngc_content = (g_count + c_count) / sequence_length * 100\n\nmolecular_weight = (\n    a_count * 313.2 + t_count * 304.2 + c_count * 289.2 + g_count * 329.2 + 79.0\n)\n\nprint(f\"DNA Sequence: {dna_sequence}\")\nprint(f\"Length: {sequence_length}\")\nprint(f\"Nucleotide counts\")\nprint(f\"A: {a_count}, C: {c_count}, G: {g_count}, T: {t_count}\")\nprint(f\"Ambiguous count: {ambiguous_count}\")\nprint(f\"GC Content (%): {gc_content:.1f}\")\nprint(f\"Molecular weight: {molecular_weight:.1f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDNA Sequence: TGACTGATCGT\nLength: 11\nNucleotide counts\nA: 2, C: 2, G: 3, T: 4\nAmbiguous count: 0\nGC Content (%): 45.5\nMolecular weight: 3488.2\n```\n:::\n:::\n\n\n## Solution to [Problem @sec-nested-conditions-sequence-filtering]\n\n::: {#0c5a96f6 .cell execution_count=11}\n``` {.python .cell-code}\nsequence_length = 250\nquality_score = 32\nambiguous_bases = 1\n\nif sequence_length >= 200:\n    if quality_score >= 30:\n        if ambiguous_bases <= 1:\n            print(\"Sequence accepted\")\n        else:\n            print(\"Sequence rejected: too many ambiguous bases\")\n    else:\n        print(\"Sequence rejected: low quality\")\nelse:\n    print(\"Sequence rejected: too short\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSequence accepted\n```\n:::\n:::\n\n\n### Optional Extension\n\nHere is one way you might solve the optional extension for this problem:\n\n::: {#dfb8a75e .cell execution_count=12}\n``` {.python .cell-code}\nsequence_length = 250\nquality_score = 32\nambiguous_bases = 1\n\nif sequence_length < 200:\n    print(\"Sequence rejected: too short\")\nelif quality_score < 30:\n    print(\"Sequence rejected: low quality\")\nelif ambiguous_bases > 1:\n    print(\"Sequence rejected: too many ambiguous bases\")\nelse:\n    print(\"Sequence accepted\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSequence accepted\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}